<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Mockup Studio</title>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }

body {
  font-family: -apple-system, BlinkMacSystemFont, "SF Pro Display", "Segoe UI", sans-serif;
  background: #0a0a0a;
  color: #e0e0e0;
  height: 100vh;
  display: flex;
  flex-direction: column;
  user-select: none;
  overflow: hidden;
}

/* ---- Top Bar ---- */
.top-bar {
  height: 44px;
  background: rgba(18,18,18,0.95);
  backdrop-filter: blur(24px);
  border-bottom: 1px solid rgba(255,255,255,0.06);
  padding: 0 16px;
  display: flex;
  align-items: center;
  gap: 10px;
  z-index: 100;
  flex-shrink: 0;
}

.top-bar .logo {
  font-size: 13px;
  font-weight: 700;
  letter-spacing: -0.4px;
  margin-right: 12px;
  white-space: nowrap;
  background: linear-gradient(135deg, #60a5fa, #a78bfa);
  -webkit-background-clip: text;
  -webkit-text-fill-color: transparent;
}

.top-bar .sep { width: 1px; height: 20px; background: rgba(255,255,255,0.08); }

.top-bar label {
  font-size: 10px;
  color: #666;
  display: flex;
  align-items: center;
  gap: 4px;
  white-space: nowrap;
}

.top-bar select, .top-bar input[type="number"] {
  background: rgba(255,255,255,0.07);
  border: 1px solid rgba(255,255,255,0.1);
  border-radius: 5px;
  color: #ccc;
  padding: 3px 6px;
  font-size: 10px;
  font-family: inherit;
}
.top-bar input[type="number"] { width: 52px; }

.btn {
  background: rgba(255,255,255,0.07);
  border: 1px solid rgba(255,255,255,0.1);
  border-radius: 6px;
  color: #ccc;
  padding: 5px 10px;
  font-size: 10px;
  font-weight: 500;
  cursor: pointer;
  transition: all 0.15s;
  white-space: nowrap;
  font-family: inherit;
}
.btn:hover { background: rgba(255,255,255,0.13); color: #fff; }

.btn-primary {
  background: linear-gradient(135deg, #2563eb, #7c3aed);
  border-color: rgba(99,102,241,0.4);
  color: #fff;
}
.btn-primary:hover { opacity: 0.9; }
.btn-primary.recording {
  background: linear-gradient(135deg, #dc2626, #e11d48);
  border-color: rgba(220,38,38,0.5);
  animation: pulse 1.2s ease infinite;
}
@keyframes pulse { 0%,100%{opacity:1} 50%{opacity:0.7} }

.undo-btn {
  background: none; border: none; color: #555; font-size: 14px;
  cursor: pointer; padding: 2px 5px; border-radius: 4px;
  transition: color 0.15s, background 0.15s;
}
.undo-btn:hover:not(:disabled) { color: #ccc; background: rgba(255,255,255,0.06); }
.undo-btn:disabled { color: #333; cursor: default; }

.top-bar .spacer { flex: 1; }

/* ---- Main Layout ---- */
.main-layout {
  flex: 1;
  display: flex;
  overflow: hidden;
  min-height: 0;
}

/* ---- Panels ---- */
.panel {
  width: 220px;
  background: rgba(18,18,18,0.95);
  border-right: 1px solid rgba(255,255,255,0.06);
  overflow-y: auto;
  flex-shrink: 0;
  font-size: 11px;
  position: relative;
  transition: width 0.2s ease;
}
.panel.right-panel {
  border-right: none;
  border-left: 1px solid rgba(255,255,255,0.06);
}
.panel.collapsed {
  width: 36px;
  overflow: hidden;
}
.panel.collapsed .panel-section { display: none; }
.panel-toggle {
  position: absolute; top: 8px; z-index: 10;
  width: 20px; height: 20px; border-radius: 4px;
  background: rgba(255,255,255,0.06); border: 1px solid rgba(255,255,255,0.08);
  color: #666; font-size: 10px; cursor: pointer;
  display: flex; align-items: center; justify-content: center;
  font-family: inherit; transition: all 0.15s;
}
.panel-toggle:hover { background: rgba(255,255,255,0.12); color: #ccc; }
.left-panel .panel-toggle { right: 6px; }
.right-panel .panel-toggle { left: 6px; }
.panel-collapsed-label {
  display: none;
  writing-mode: vertical-rl;
  text-orientation: mixed;
  font-size: 10px; color: #555; letter-spacing: 0.5px;
  text-transform: uppercase; font-weight: 600;
  position: absolute; top: 36px; left: 0; right: 0;
  text-align: center;
  pointer-events: none;
}
.panel.collapsed .panel-collapsed-label { display: block; }

.panel-section {
  padding: 12px;
  border-bottom: 1px solid rgba(255,255,255,0.04);
}
.panel-section h3 {
  font-size: 10px;
  font-weight: 600;
  color: #888;
  text-transform: uppercase;
  letter-spacing: 0.5px;
  margin-bottom: 8px;
}

.device-grid {
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: 6px;
}
.device-grid .dev-btn {
  background: rgba(255,255,255,0.05);
  border: 1px solid rgba(255,255,255,0.08);
  border-radius: 6px;
  padding: 8px 4px;
  text-align: center;
  cursor: pointer;
  font-size: 9px;
  color: #999;
  transition: all 0.15s;
}
.device-grid .dev-btn:hover { background: rgba(255,255,255,0.1); color: #fff; }
.device-grid .dev-btn.active {
  background: rgba(96,165,250,0.15);
  border-color: rgba(96,165,250,0.4);
  color: #60a5fa;
}
.device-grid .dev-btn .icon { font-size: 20px; display: block; margin-bottom: 3px; }

.color-swatches {
  display: flex;
  gap: 6px;
  flex-wrap: wrap;
  margin-top: 6px;
}
.color-swatch {
  width: 22px;
  height: 22px;
  border-radius: 50%;
  border: 2px solid transparent;
  cursor: pointer;
  transition: all 0.15s;
  position: relative;
}
.color-swatch:hover { transform: scale(1.15); }
.color-swatch.active { border-color: #60a5fa; }

.toggle-row {
  display: flex;
  align-items: center;
  gap: 8px;
  margin-top: 8px;
}
.toggle-btn {
  background: rgba(255,255,255,0.05);
  border: 1px solid rgba(255,255,255,0.08);
  border-radius: 4px;
  padding: 4px 8px;
  font-size: 10px;
  color: #999;
  cursor: pointer;
  font-family: inherit;
}
.toggle-btn:hover { background: rgba(255,255,255,0.1); color:#fff; }
.toggle-btn.active { background: rgba(96,165,250,0.15); border-color: rgba(96,165,250,0.3); color: #60a5fa; }

/* Layer list */
/* Unified Layers Panel */
.unified-layers { display: flex; flex-direction: column; gap: 1px; }
.ul-item {
  display: flex; align-items: center; gap: 4px;
  padding: 4px 6px; border-radius: 4px;
  font-size: 10px; color: #888;
  cursor: pointer; position: relative;
  transition: background 0.15s;
}
.ul-item:hover { background: rgba(255,255,255,0.05); }
.ul-item.selected { background: rgba(96,165,250,0.1); color: #60a5fa; }
.ul-item.main-layer {
  border-left: 2px solid rgba(96,165,250,0.35);
  padding-left: 8px; color: #bbb;
}
.ul-item.hidden-layer { opacity: 0.35; }
.ul-eye {
  background: none; border: none; cursor: pointer;
  font-size: 10px; padding: 0; width: 14px; text-align: center;
  color: #4a90d9; opacity: 0.5; transition: opacity 0.15s;
  flex-shrink: 0;
}
.ul-eye:hover { opacity: 1; }
.ul-eye.off { opacity: 0.2; color: #555; }
.ul-icon { font-size: 11px; width: 16px; text-align: center; flex-shrink: 0; }
.ul-name { flex: 1; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
.ul-tag {
  font-size: 7px; text-transform: uppercase; letter-spacing: 0.5px;
  color: #60a5fa; background: rgba(96,165,250,0.1);
  padding: 1px 4px; border-radius: 3px; flex-shrink: 0;
}
.ul-controls { display: none; align-items: center; gap: 1px; flex-shrink: 0; }
.ul-item:hover .ul-controls, .ul-item.selected .ul-controls { display: flex; }
.ul-btn {
  background: none; border: none; cursor: pointer;
  color: #666; font-size: 9px; padding: 1px 3px; border-radius: 2px;
  transition: color 0.1s, background 0.1s;
}
.ul-btn:hover { color: #fff; background: rgba(255,255,255,0.1); }
.ul-btn.del { color: #a55; }
.ul-btn.del:hover { color: #f44; background: rgba(255,68,68,0.1); }
.ul-empty { font-size: 9px; color: #444; padding: 12px 6px; text-align: center; }
.layer-actions { display: flex; gap: 4px; margin-top: 6px; }
.layer-actions .btn { flex: 1; font-size: 9px; text-align: center; }
.layer-detail {
  margin-top: 8px; padding: 8px;
  background: rgba(255,255,255,0.02);
  border: 1px solid rgba(255,255,255,0.06);
  border-radius: 6px;
}
.layer-detail .detail-row {
  display: flex; align-items: center; gap: 6px;
  margin-bottom: 4px; font-size: 9px; color: #888;
}
.layer-detail .detail-row label { min-width: 46px; color: #666; }
.layer-detail .detail-row input[type="range"] { flex: 1; }
.layer-detail .detail-row span { min-width: 28px; text-align: right; font-size: 8px; color: #555; }
/* Advanced render order (hidden by default) */
.adv-stack { display: flex; flex-direction: column; gap: 1px; }
.adv-item {
  display: flex; align-items: center; gap: 6px;
  padding: 4px 6px; border-radius: 4px;
  cursor: grab; font-size: 9px; color: #555;
  background: rgba(255,255,255,0.02);
  border: 1px solid transparent;
  transition: background 0.15s;
}
.adv-item:hover { background: rgba(255,255,255,0.05); }
.adv-item.active { color: #999; border-color: rgba(255,255,255,0.06); }
.adv-item.dragging { opacity: 0.4; }
.adv-item.drag-over { border-color: rgba(96,165,250,0.4); background: rgba(96,165,250,0.06); }
.adv-item .adv-drag { cursor: grab; color: #444; font-size: 9px; }
.adv-item .adv-icon { font-size: 10px; width: 14px; text-align: center; }
.adv-item .adv-name { flex: 1; }
.adv-label { font-size: 7px; color: #444; text-transform: uppercase; letter-spacing: 0.5px; padding: 4px 6px 2px; }
/* Hidden layer list (backwards compat) */
.layer-list { list-style: none; display: none; }
.layer-item { display: none; }

/* Right panel controls */
.prop-row {
  display: flex;
  align-items: center;
  gap: 6px;
  margin-bottom: 6px;
}
.prop-row label { font-size: 10px; color: #777; min-width: 50px; }
.prop-row input[type="range"] { flex: 1; accent-color: #60a5fa; height: 14px; }
.prop-row input[type="color"] {
  width: 22px; height: 22px; border: 1px solid rgba(255,255,255,0.1);
  border-radius: 4px; cursor: pointer; background: none; padding: 0;
}
.prop-row input[type="number"] {
  width: 48px; background: rgba(255,255,255,0.07); border: 1px solid rgba(255,255,255,0.1);
  border-radius: 4px; color: #ccc; padding: 2px 4px; font-size: 10px; font-family: inherit;
}
.prop-row select {
  flex: 1; background: rgba(255,255,255,0.07); border: 1px solid rgba(255,255,255,0.1);
  border-radius: 4px; color: #ccc; padding: 3px 4px; font-size: 10px; font-family: inherit;
}
.prop-row input[type="text"] {
  flex: 1; background: rgba(255,255,255,0.07); border: 1px solid rgba(255,255,255,0.1);
  border-radius: 4px; color: #ccc; padding: 3px 6px; font-size: 10px; font-family: inherit;
}

/* Annotation toolbar */
.anno-toolbar {
  display: flex;
  gap: 4px;
  flex-wrap: wrap;
  margin-bottom: 8px;
}
.anno-btn {
  background: rgba(255,255,255,0.05);
  border: 1px solid rgba(255,255,255,0.08);
  border-radius: 4px;
  padding: 4px 7px;
  font-size: 10px;
  color: #aaa;
  cursor: pointer;
  font-family: inherit;
}
.anno-btn:hover { background: rgba(255,255,255,0.1); color: #fff; }
.anno-btn.active { background: rgba(96,165,250,0.15); border-color: rgba(96,165,250,0.3); color: #60a5fa; }

/* ---- Canvas Stage ---- */
.stage {
  flex: 1;
  display: flex;
  align-items: center;
  justify-content: center;
  background: #0d0d0d;
  position: relative;
  overflow: hidden;
  min-width: 0;
}

.canvas-wrap {
  position: relative;
  cursor: pointer;
  transition: transform 0.2s ease;
}

#renderCanvas { display: block; }

/* ---- Drop overlay ---- */
.drop-overlay {
  position: fixed; inset: 0; z-index: 200;
  background: rgba(37,99,235,0.15);
  border: 3px dashed #3b82f6;
  display: none; align-items: center; justify-content: center;
  font-size: 22px; color: #93c5fd; font-weight: 600;
  backdrop-filter: blur(6px);
}
.drop-overlay.active { display: flex; }

/* ---- Asset Browser Modal ---- */
.asset-browser {
  position: fixed; inset: 0; z-index: 300;
  background: rgba(0,0,0,0.8);
  backdrop-filter: blur(12px);
  display: none; flex-direction: column;
}
.asset-browser.open { display: flex; }
.asset-browser-header {
  height: 48px; padding: 0 16px;
  background: rgba(18,18,18,0.98);
  border-bottom: 1px solid rgba(255,255,255,0.08);
  display: flex; align-items: center; gap: 12px; flex-shrink: 0;
}
.asset-browser-header h2 {
  font-size: 14px; font-weight: 700;
  background: linear-gradient(135deg, #60a5fa, #a78bfa);
  -webkit-background-clip: text; -webkit-text-fill-color: transparent;
}
.asset-browser-header .ab-search {
  flex: 1; max-width: 300px;
  background: rgba(255,255,255,0.07); border: 1px solid rgba(255,255,255,0.1);
  border-radius: 6px; color: #ccc; padding: 6px 10px; font-size: 12px;
  font-family: inherit; outline: none;
}
.asset-browser-header .ab-search:focus { border-color: rgba(99,102,241,0.5); }
.ab-close {
  width: 30px; height: 30px; border-radius: 6px; border: none;
  background: rgba(255,255,255,0.07); color: #aaa; font-size: 16px;
  cursor: pointer; display: flex; align-items: center; justify-content: center;
}
.ab-close:hover { background: rgba(255,100,100,0.2); color: #f66; }
.asset-browser-body { display: flex; flex: 1; overflow: hidden; }
.ab-sidebar {
  width: 200px; background: rgba(18,18,18,0.95);
  border-right: 1px solid rgba(255,255,255,0.06);
  overflow-y: auto; flex-shrink: 0; padding: 8px 0;
}
.ab-folder {
  padding: 7px 14px; font-size: 11px; color: #999; cursor: pointer;
  display: flex; align-items: center; gap: 6px;
  border-left: 2px solid transparent; transition: all 0.1s;
}
.ab-folder:hover { color: #ccc; background: rgba(255,255,255,0.03); }
.ab-folder.active { color: #60a5fa; border-left-color: #60a5fa; background: rgba(96,165,250,0.06); }
.ab-folder .ab-icon { font-size: 13px; }
.ab-folder .ab-count { margin-left: auto; font-size: 9px; color: #555; }
.ab-content {
  flex: 1; overflow-y: auto; padding: 16px;
}
.ab-grid {
  display: grid; grid-template-columns: repeat(auto-fill, minmax(140px, 1fr));
  gap: 10px;
}
.ab-item {
  background: rgba(255,255,255,0.03); border: 1px solid rgba(255,255,255,0.06);
  border-radius: 8px; overflow: hidden; cursor: pointer; transition: all 0.15s;
}
.ab-item:hover { border-color: rgba(99,102,241,0.4); background: rgba(99,102,241,0.06); transform: translateY(-1px); }
.ab-item-preview {
  height: 80px; background: #111; display: flex; align-items: center;
  justify-content: center; font-size: 28px; color: #444;
  position: relative; overflow: hidden;
}
.ab-item-preview img { width: 100%; height: 100%; object-fit: cover; }
.ab-item-info { padding: 6px 8px; }
.ab-item-name { font-size: 9px; color: #aaa; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
.ab-item-type { font-size: 8px; color: #555; margin-top: 2px; }
.ab-item .ab-badge {
  position: absolute; top: 4px; right: 4px; padding: 1px 5px;
  border-radius: 3px; font-size: 8px; font-weight: 600;
}
.ab-badge-lut { background: rgba(74,222,128,0.2); color: #4ade80; }
.ab-badge-video { background: rgba(96,165,250,0.2); color: #60a5fa; }
.ab-badge-image { background: rgba(251,191,36,0.2); color: #fbbf24; }
.ab-badge-audio { background: rgba(244,114,182,0.2); color: #f472b6; }
.ab-empty {
  display: flex; flex-direction: column; align-items: center; justify-content: center;
  height: 100%; color: #555; font-size: 13px; gap: 12px;
}
.ab-empty .btn { font-size: 12px; padding: 8px 20px; }
.ab-breadcrumb { font-size: 10px; color: #666; margin-bottom: 12px; display: flex; gap: 4px; flex-wrap: wrap; }
.ab-breadcrumb span { cursor: pointer; }
.ab-breadcrumb span:hover { color: #60a5fa; }
.ab-breadcrumb .ab-sep { color: #444; cursor: default; }
.ab-loading { color: #666; font-size: 12px; text-align: center; padding: 40px; }

.canvas-prompt {
  position: absolute; inset: 0;
  display: flex; flex-direction: column; align-items: center; justify-content: center;
  pointer-events: none; opacity: 0; transition: opacity 0.2s;
}
.canvas-prompt.visible { opacity: 1; pointer-events: auto; }
.canvas-prompt svg { width: 44px; height: 44px; fill: rgba(255,255,255,0.4); margin-bottom: 10px; }
.canvas-prompt p { font-size: 13px; color: rgba(255,255,255,0.5); text-align: center; line-height: 1.6; }
.canvas-prompt .sub { font-size: 10px; color: rgba(255,255,255,0.25); margin-top: 4px; }

/* ---- Timeline ---- */
.timeline-bar {
  height: 80px;
  background: rgba(18,18,18,0.95);
  border-top: 1px solid rgba(255,255,255,0.06);
  display: flex;
  flex-direction: column;
  padding: 6px 16px;
  flex-shrink: 0;
  display: none;
}
.timeline-bar.visible { display: flex; }

.timeline-track {
  flex: 1;
  background: rgba(255,255,255,0.04);
  border-radius: 4px;
  position: relative;
  margin-bottom: 4px;
  cursor: pointer;
  overflow: hidden;
}
.timeline-track .clip-block {
  position: absolute; top: 4px; bottom: 4px;
  background: rgba(96,165,250,0.2);
  border: 1px solid rgba(96,165,250,0.3);
  border-radius: 3px;
  display: flex; align-items: center; justify-content: center;
  font-size: 9px; color: #60a5fa;
}
.trim-handle {
  position: absolute; top: 0; bottom: 0; width: 8px;
  background: rgba(96,165,250,0.6);
  cursor: ew-resize; z-index: 2;
}
.trim-handle.left { left: 0; border-radius: 3px 0 0 3px; }
.trim-handle.right { right: 0; border-radius: 0 3px 3px 0; }
.timeline-scrubber {
  position: absolute; top: 0; bottom: 0; width: 2px;
  background: #f59e0b; z-index: 3; pointer-events: none;
}
.keyframe-diamond {
  position: absolute; top: -2px; width: 10px; height: 10px;
  background: #f59e0b; transform: rotate(45deg);
  cursor: pointer; z-index: 4;
}

/* ---- Playback Bar ---- */
.playback-bar {
  height: 40px;
  background: rgba(18,18,18,0.95);
  border-top: 1px solid rgba(255,255,255,0.06);
  padding: 0 16px;
  display: flex;
  align-items: center;
  gap: 10px;
  flex-shrink: 0;
  transform: translateY(100%);
  transition: transform 0.3s ease;
}
.playback-bar.visible { transform: translateY(0); }

.play-btn {
  width: 28px; height: 28px; background: none; border: none;
  cursor: pointer; display: flex; align-items: center; justify-content: center;
}
.play-btn svg { width: 16px; height: 16px; fill: #e0e0e0; }

.progress-track {
  flex: 1; height: 4px; background: rgba(255,255,255,0.1);
  border-radius: 2px; cursor: pointer; position: relative;
  padding: 8px 0; background-clip: content-box;
  margin: -8px 0;
  transition: height 0.15s ease;
}
.progress-track:hover, .progress-track.scrubbing { height: 6px; }
.progress-fill {
  height: 100%; background: #60a5fa; border-radius: 2px; width: 0%;
  pointer-events: none; position: relative;
}
.progress-handle {
  position: absolute; right: -6px; top: 50%; transform: translateY(-50%);
  width: 12px; height: 12px; border-radius: 50%;
  background: #fff; box-shadow: 0 0 4px rgba(0,0,0,0.5);
  opacity: 0; transition: opacity 0.15s;
  pointer-events: none;
}
.progress-track:hover .progress-handle,
.progress-track.scrubbing .progress-handle { opacity: 1; }
.progress-tooltip {
  position: absolute; bottom: 18px; left: 50%; transform: translateX(-50%);
  background: rgba(18,18,18,0.92); border: 1px solid rgba(255,255,255,0.1);
  border-radius: 4px; padding: 2px 6px; font-size: 10px; color: #ccc;
  white-space: nowrap; pointer-events: none;
  display: none;
}
.progress-track.scrubbing .progress-tooltip { display: block; }

.time-label {
  font-size: 10px; color: #666; font-variant-numeric: tabular-nums;
  min-width: 80px; text-align: right;
}

.speed-select {
  background: rgba(255,255,255,0.07); border: 1px solid rgba(255,255,255,0.1);
  border-radius: 4px; color: #ccc; padding: 2px 4px; font-size: 10px; font-family: inherit;
}

/* ---- Export status ---- */
.export-status {
  position: fixed; top: 50px; right: 16px; z-index: 150;
  background: rgba(18,18,18,0.92); backdrop-filter: blur(20px);
  border: 1px solid rgba(255,255,255,0.08); border-radius: 10px;
  padding: 12px 16px; font-size: 11px; color: #aaa; display: none; min-width: 180px;
}
.export-status.visible { display: block; }
.export-status .bar { height: 3px; background: rgba(255,255,255,0.08); border-radius: 2px; margin-top: 6px; overflow: hidden; }
.export-status .bar-fill { height: 100%; background: linear-gradient(90deg, #2563eb, #7c3aed); width: 0%; transition: width 0.3s; }

input[type="file"] { display: none; }

/* ---- Facecam ---- */
.facecam-preview {
  position: absolute;
  border-radius: 50%;
  overflow: hidden;
  border: 2px solid rgba(255,255,255,0.2);
  pointer-events: none;
  display: none;
}
.facecam-preview video { width: 100%; height: 100%; object-fit: cover; }

/* Scrollbar styling for panels */
.panel::-webkit-scrollbar { width: 4px; }
.panel::-webkit-scrollbar-track { background: transparent; }
.panel::-webkit-scrollbar-thumb { background: rgba(255,255,255,0.1); border-radius: 2px; }

/* Checkerboard for transparent background */
.canvas-wrap.checker-bg {
  background-image:
    linear-gradient(45deg, #2a2a2a 25%, transparent 25%),
    linear-gradient(-45deg, #2a2a2a 25%, transparent 25%),
    linear-gradient(45deg, transparent 75%, #2a2a2a 75%),
    linear-gradient(-45deg, transparent 75%, #2a2a2a 75%);
  background-size: 20px 20px;
  background-position: 0 0, 0 10px, 10px -10px, -10px 0px;
  background-color: #1a1a1a;
}

.btn-danger {
  color: #f66;
  border-color: rgba(255,100,100,0.2);
}
.btn-danger:hover {
  background: rgba(255,100,100,0.1);
  color: #ff4444;
}

.section-header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  margin-bottom: 8px;
}
.section-header h3 { margin-bottom: 0; }
.section-header .btn { padding: 1px 6px; font-size: 9px; }

.comparison-controls { display: none; }
.comparison-controls.visible { display: block; }

/* Full preset templates */
.preset-grid {
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: 5px;
}
.preset-card {
  background: rgba(255,255,255,0.03);
  border: 1px solid rgba(255,255,255,0.06);
  border-radius: 8px;
  padding: 8px 4px 6px;
  text-align: center;
  cursor: pointer;
  font-size: 9px;
  color: #888;
  transition: all 0.15s;
}
.preset-card:hover { background: rgba(255,255,255,0.07); color: #ccc; border-color: rgba(255,255,255,0.12); }
.preset-card.active {
  background: linear-gradient(135deg, rgba(96,165,250,0.1), rgba(167,139,250,0.1));
  border-color: rgba(96,165,250,0.35);
  color: #60a5fa;
}
.preset-card .pc-icon { font-size: 18px; display: block; margin-bottom: 3px; }
.preset-card .pc-name { font-weight: 600; letter-spacing: -0.2px; }
.preset-card .pc-desc { font-size: 7px; color: #555; margin-top: 2px; line-height: 1.3; }
.preset-card.active .pc-desc { color: rgba(96,165,250,0.6); }

.panel-section.collapsed .collapsible-content { display: none; }
.collapse-toggle {
  background: none; border: none; color: #666; font-size: 10px;
  cursor: pointer; padding: 0 4px; font-family: inherit;
}
.collapse-toggle:hover { color: #aaa; }

/* Toast Notifications */
.toast-container {
  position: fixed;
  bottom: 24px;
  right: 24px;
  z-index: 500;
  display: flex;
  flex-direction: column-reverse;
  gap: 8px;
  pointer-events: none;
}
.toast-item {
  background: rgba(18,18,18,0.92);
  backdrop-filter: blur(16px);
  border: 1px solid rgba(255,255,255,0.08);
  border-radius: 10px;
  padding: 10px 16px;
  font-size: 12px;
  color: #ccc;
  white-space: nowrap;
  border-left: 3px solid rgba(255,255,255,0.15);
  transform: translateX(120%);
  opacity: 0;
  transition: transform 0.3s cubic-bezier(0.4,0,0.2,1), opacity 0.3s ease;
}
.toast-item.visible {
  transform: translateX(0);
  opacity: 1;
}
.toast-item.toast-success { border-left-color: #4ade80; }
.toast-item.toast-info { border-left-color: #60a5fa; }
.toast-item.toast-error { border-left-color: #f87171; }

/* Keyboard Shortcuts Overlay */
.kb-overlay {
  position: fixed; inset: 0; z-index: 600;
  background: rgba(0,0,0,0.7);
  backdrop-filter: blur(12px);
  display: none; align-items: center; justify-content: center;
}
.kb-overlay.open { display: flex; }
.kb-panel {
  background: rgba(18,18,18,0.96);
  border: 1px solid rgba(255,255,255,0.08);
  border-radius: 14px;
  padding: 28px 32px 20px;
  min-width: 340px;
  max-width: 400px;
}
.kb-panel h2 {
  font-size: 14px; font-weight: 700; margin-bottom: 18px;
  background: linear-gradient(135deg, #60a5fa, #a78bfa);
  -webkit-background-clip: text; -webkit-text-fill-color: transparent;
}
.kb-row {
  display: flex; justify-content: space-between; align-items: center;
  padding: 7px 0;
  border-bottom: 1px solid rgba(255,255,255,0.04);
  font-size: 12px;
}
.kb-row:last-child { border-bottom: none; }
.kb-key {
  display: inline-flex; gap: 4px;
}
.kb-key kbd {
  background: rgba(255,255,255,0.08);
  border: 1px solid rgba(255,255,255,0.12);
  border-radius: 5px;
  padding: 2px 8px;
  font-size: 11px; font-family: inherit;
  color: #ccc;
}
.kb-action { color: #888; font-size: 11px; }
.kb-tip {
  margin-top: 16px; padding-top: 12px;
  border-top: 1px solid rgba(255,255,255,0.04);
  font-size: 10px; color: #555; text-align: center;
}
.kb-close {
  position: absolute; top: 12px; right: 16px;
  width: 28px; height: 28px; border-radius: 6px; border: none;
  background: rgba(255,255,255,0.07); color: #aaa; font-size: 15px;
  cursor: pointer; display: flex; align-items: center; justify-content: center;
}
.kb-close:hover { background: rgba(255,255,255,0.13); color: #fff; }

/* Export Dialog */
.export-dialog {
  position: fixed; inset: 0; z-index: 600;
  background: rgba(0,0,0,0.7);
  backdrop-filter: blur(12px);
  display: none; align-items: center; justify-content: center;
}
.export-dialog.open { display: flex; }
.export-dialog-panel {
  background: rgba(18,18,18,0.96);
  border: 1px solid rgba(255,255,255,0.08);
  border-radius: 14px;
  padding: 24px 28px 20px;
  width: 400px;
  position: relative;
}
.export-dialog-panel h2 {
  font-size: 14px; font-weight: 700; margin-bottom: 16px;
  background: linear-gradient(135deg, #60a5fa, #a78bfa);
  -webkit-background-clip: text; -webkit-text-fill-color: transparent;
}
.ed-row {
  display: flex; justify-content: space-between; align-items: center;
  padding: 7px 0;
  border-bottom: 1px solid rgba(255,255,255,0.04);
  font-size: 12px; color: #aaa;
}
.ed-row:last-child { border-bottom: none; }
.ed-row label { color: #888; font-size: 11px; min-width: 90px; }
.ed-row select, .ed-row input[type="checkbox"] {
  background: rgba(255,255,255,0.07);
  border: 1px solid rgba(255,255,255,0.1);
  border-radius: 5px; color: #ccc;
  padding: 4px 8px; font-size: 11px; font-family: inherit;
}
.ed-row input[type="checkbox"] { width: 15px; height: 15px; accent-color: #60a5fa; }
.ed-estimate {
  margin-top: 12px; padding: 8px 12px;
  background: rgba(255,255,255,0.03);
  border: 1px solid rgba(255,255,255,0.05);
  border-radius: 8px;
  font-size: 11px; color: #666; text-align: center;
}
.ed-actions {
  display: flex; gap: 8px; margin-top: 16px; justify-content: flex-end;
}
</style>
</head>
<body>

<div class="toast-container" id="toastContainer"></div>

<!-- Top Bar -->
<div class="top-bar">
  <span class="logo">Mockup Studio</span>
  <div class="sep"></div>

  <label>Preset
    <select id="presetSelect">
      <option value="device">Device Only</option>
      <option value="reels" selected>Reels/TikTok (1080x1920)</option>
      <option value="twitter">Twitter/X (1080x1350)</option>
      <option value="youtube">YouTube (1920x1080)</option>
      <option value="square">Square (1080x1080)</option>
      <option value="custom">Custom</option>
    </select>
  </label>
  <span id="customSizeWrap" style="display:none">
    <input type="number" id="customW" value="1080" min="100" max="3840"> x
    <input type="number" id="customH" value="1920" min="100" max="3840">
  </span>

  <div class="sep"></div>

  <label>Entrance
    <select id="entranceSelect">
      <option value="none">None</option>
      <option value="fadeIn">Fade In</option>
      <option value="slideUp">Slide Up</option>
      <option value="scaleIn">Scale In</option>
      <option value="rotateIn">Rotate In</option>
    </select>
  </label>
  <label>Dur <input type="range" id="entranceDur" min="500" max="3000" value="1000" style="width:60px;accent-color:#60a5fa"> <span id="entranceDurVal">1.0s</span></label>

  <div class="spacer"></div>

  <button class="undo-btn" id="undoBtn" title="Undo (Ctrl+Z)" disabled>‚Ü©</button>
  <button class="undo-btn" id="redoBtn" title="Redo (Ctrl+Shift+Z)" disabled>‚Ü™</button>
  <div class="sep"></div>

  <button class="btn" id="assetBrowserBtn" style="background:linear-gradient(135deg,rgba(99,102,241,0.2),rgba(168,85,247,0.2));border-color:rgba(139,92,246,0.3)">üìÇ Assets</button>
  <button class="btn" id="loadBtn">Load Video</button>
  <button class="btn" id="loopBtn">Loop</button>
  <button class="btn" id="ssBtn">Screenshot</button>
  <button class="btn" id="thumbBtn">Thumbnail</button>
  <button class="btn" id="kbHelpBtn" title="Keyboard shortcuts (?)">‚å®</button>
  <button class="btn btn-primary" id="exportBtn">Export</button>
</div>

<!-- Keyboard Shortcuts Overlay -->
<div class="kb-overlay" id="kbOverlay">
  <div class="kb-panel" style="position:relative">
    <button class="kb-close" id="kbClose">&times;</button>
    <h2>Keyboard Shortcuts</h2>
    <div class="kb-row"><span class="kb-key"><kbd>Space</kbd></span><span class="kb-action">Play / Pause</span></div>
    <div class="kb-row"><span class="kb-key"><kbd>‚Üê</kbd> <kbd>‚Üí</kbd></span><span class="kb-action">Seek ¬±5 seconds</span></div>
    <div class="kb-row"><span class="kb-key"><kbd>Ctrl</kbd><kbd>S</kbd></span><span class="kb-action">Save Screenshot</span></div>
    <div class="kb-row"><span class="kb-key"><kbd>Ctrl</kbd><kbd>Z</kbd></span><span class="kb-action">Undo</span></div>
    <div class="kb-row"><span class="kb-key"><kbd>Ctrl</kbd><kbd>‚áß</kbd><kbd>Z</kbd></span><span class="kb-action">Redo</span></div>
    <div class="kb-row"><span class="kb-key"><kbd>[</kbd> <kbd>]</kbd></span><span class="kb-action">Toggle sidebars</span></div>
    <div class="kb-row"><span class="kb-key"><kbd>?</kbd></span><span class="kb-action">Show this help</span></div>
    <div class="kb-tip">Tip: Press <kbd style="background:rgba(255,255,255,0.06);border:1px solid rgba(255,255,255,0.1);border-radius:4px;padding:1px 5px;font-size:9px;font-family:inherit;color:#666">?</kbd> anytime to see shortcuts</div>
  </div>
</div>

<!-- Export Dialog -->
<div class="export-dialog" id="exportDialog">
  <div class="export-dialog-panel">
    <h2>Export Settings</h2>
    <div class="ed-row"><label>Format</label><select id="edFormat" disabled><option value="webm">WebM</option></select></div>
    <div class="ed-row"><label>Resolution</label>
      <select id="edResolution">
        <option value="original">Original</option>
        <option value="1080">1080p</option>
        <option value="720">720p</option>
      </select>
    </div>
    <div class="ed-row"><label>Quality</label>
      <select id="edQuality">
        <option value="5000000">Low (5 Mbps)</option>
        <option value="10000000" selected>Medium (10 Mbps)</option>
        <option value="20000000">High (20 Mbps)</option>
        <option value="40000000">Max (40 Mbps)</option>
      </select>
    </div>
    <div class="ed-row"><label>Framerate</label>
      <select id="edFramerate">
        <option value="24">24 fps</option>
        <option value="30" selected>30 fps</option>
        <option value="60">60 fps</option>
      </select>
    </div>
    <div class="ed-row"><label>Include Audio</label><input type="checkbox" id="edAudio" checked></div>
    <div class="ed-estimate" id="edEstimate"></div>
    <div class="ed-actions">
      <button class="btn" id="edCancel">Cancel</button>
      <button class="btn btn-primary" id="edStart">Start Export</button>
    </div>
  </div>
</div>

<!-- Main Layout -->
<div class="main-layout">

  <!-- Left Panel -->
  <div class="panel left-panel" id="leftPanel">
    <button class="panel-toggle" id="leftPanelToggle" title="Toggle left panel [">¬´</button>
    <div class="panel-collapsed-label">Templates</div>
    <div class="panel-section">
      <div class="section-header">
        <h3>Studio Templates</h3>
        <button class="btn btn-danger" id="resetFullPresetBtn">Custom</button>
      </div>
      <div class="preset-grid" id="fullPresetGrid">
        <div class="preset-card" data-fp="appShowcase"><span class="pc-icon">üì±</span><span class="pc-name">App Showcase</span><span class="pc-desc">Cinematic device promo</span></div>
        <div class="preset-card" data-fp="tiktokViral"><span class="pc-icon">üî•</span><span class="pc-name">TikTok Viral</span><span class="pc-desc">Sunset vibes, trending</span></div>
        <div class="preset-card" data-fp="cleanProduct"><span class="pc-icon">‚ú®</span><span class="pc-name">Clean Product</span><span class="pc-desc">Minimal white showcase</span></div>
        <div class="preset-card" data-fp="darkCinematic"><span class="pc-icon">üé¨</span><span class="pc-name">Dark Cinema</span><span class="pc-desc">Moody film look</span></div>
        <div class="preset-card" data-fp="neonPop"><span class="pc-icon">üíú</span><span class="pc-name">Neon Pop</span><span class="pc-desc">Neon glow effects</span></div>
        <div class="preset-card" data-fp="cleanSocial"><span class="pc-icon">üì∏</span><span class="pc-name">Clean Social</span><span class="pc-desc">No device, video only</span></div>
        <div class="preset-card" data-fp="retroFilm"><span class="pc-icon">üéû</span><span class="pc-name">Retro Film</span><span class="pc-desc">Vintage film grain</span></div>
        <div class="preset-card" data-fp="laptopReview"><span class="pc-icon">üíª</span><span class="pc-name">Laptop Review</span><span class="pc-desc">MacBook ocean vibe</span></div>
        <div class="preset-card" data-fp="rawVideo"><span class="pc-icon">‚ñ∂Ô∏è</span><span class="pc-name">Raw Video</span><span class="pc-desc">No device, no effects</span></div>
        <div class="preset-card" data-fp="ipadPresent"><span class="pc-icon">üì≤</span><span class="pc-name">iPad Present</span><span class="pc-desc">iPad Pro minimal</span></div>
      </div>
    </div>

    <div class="panel-section" id="deviceSection">
      <div class="section-header">
        <h3>Device Frame</h3>
        <button class="collapse-toggle" id="deviceCollapseBtn">‚ñº</button>
      </div>
      <div class="collapsible-content" id="deviceContent">
        <div class="device-grid" id="deviceGrid">
          <div class="dev-btn" data-device="none"><span class="icon">üö´</span>None</div>
          <div class="dev-btn active" data-device="iphone16"><span class="icon">üì±</span>iPhone 16</div>
          <div class="dev-btn" data-device="ipadpro"><span class="icon">üì≤</span>iPad Pro</div>
          <div class="dev-btn" data-device="macbookpro"><span class="icon">üíª</span>MacBook</div>
          <div class="dev-btn" data-device="applewatch"><span class="icon">‚åö</span>Watch</div>
        </div>
        <div id="colorSwatches" class="color-swatches"></div>
        <div class="toggle-row" id="deviceToggles">
          <button class="toggle-btn" id="landscapeBtn">Landscape</button>
          <button class="toggle-btn" id="comparisonBtn">Compare</button>
        </div>
      </div>
    </div>

    <div class="panel-section comparison-controls" id="comparisonControls">
      <div class="section-header">
        <h3>Device 2</h3>
        <button class="btn btn-danger" id="disableCompareBtn">Disable</button>
      </div>
      <div class="device-grid" id="device2Grid">
        <div class="dev-btn active" data-device="ipadpro"><span class="icon">üì≤</span>iPad Pro</div>
        <div class="dev-btn" data-device="iphone16"><span class="icon">üì±</span>iPhone 16</div>
        <div class="dev-btn" data-device="macbookpro"><span class="icon">üíª</span>MacBook</div>
        <div class="dev-btn" data-device="applewatch"><span class="icon">‚åö</span>Watch</div>
      </div>
      <div id="colorSwatches2" class="color-swatches"></div>
      <button class="btn" id="loadVideo2Btn" style="width:100%;margin-top:6px">Load Video for Device 2</button>
      <input type="file" id="video2Input" accept="video/*" style="display:none">
      <p id="video2Status" style="font-size:9px;color:#555;margin-top:4px">No video loaded for Device 2</p>
    </div>

    <div class="panel-section">
      <div class="section-header">
        <h3>Layers</h3>
        <button class="btn btn-danger" id="clearLayersBtn">Clear</button>
      </div>
      <div class="unified-layers" id="unifiedLayers"></div>
      <div class="layer-actions">
        <button class="btn" id="quickAddText">+ Text</button>
        <button class="btn" id="quickAddLogo">+ Logo</button>
      </div>
      <div class="layer-detail" id="layerDetail" style="display:none"></div>
      <div style="margin-top:8px">
        <button class="btn" id="advLayerToggle" style="width:100%;font-size:8px;color:#555">Advanced Render Order</button>
        <div id="advLayerPanel" style="display:none;margin-top:6px">
          <div class="adv-label">Drag to reorder render groups</div>
          <div class="adv-stack" id="advStack"></div>
        </div>
      </div>
      <ul class="layer-list" id="layerList"></ul>
    </div>

    <div class="panel-section">
      <div class="section-header">
        <h3>Hand Overlay</h3>
        <button class="btn btn-danger" id="resetHandBtn" style="display:none">Off</button>
      </div>
      <div class="toggle-row">
        <button class="toggle-btn" id="handBtn">Enable Hand</button>
        <select id="handStyle" style="background:rgba(255,255,255,0.07);border:1px solid rgba(255,255,255,0.1);border-radius:4px;color:#ccc;padding:2px 4px;font-size:10px">
          <option value="right">Right Hand</option>
          <option value="left">Left Hand</option>
        </select>
      </div>
    </div>

    <div class="panel-section">
      <div class="section-header">
        <h3>Scene Templates</h3>
        <button class="btn btn-danger" id="resetSceneBtn">Reset</button>
      </div>
      <div class="device-grid" id="sceneGrid">
        <div class="dev-btn active" data-scene="custom"><span class="icon">üé®</span>Custom</div>
        <div class="dev-btn" data-scene="floating"><span class="icon">üåå</span>Floating</div>
        <div class="dev-btn" data-scene="neon"><span class="icon">üíú</span>Neon Glow</div>
        <div class="dev-btn" data-scene="sunset"><span class="icon">üåÖ</span>Sunset</div>
        <div class="dev-btn" data-scene="minimal"><span class="icon">‚¨ú</span>Minimal</div>
        <div class="dev-btn" data-scene="ocean"><span class="icon">üåä</span>Ocean</div>
        <div class="dev-btn" data-scene="forest"><span class="icon">üå≤</span>Forest</div>
        <div class="dev-btn" data-scene="cinematic"><span class="icon">üé¨</span>Cinematic</div>
      </div>
    </div>

    <div class="panel-section">
      <div class="section-header">
        <h3>Animation Presets</h3>
        <button class="btn btn-danger" id="clearAnimPresetBtn">Stop</button>
      </div>
      <div class="device-grid" id="animPresetGrid">
        <div class="dev-btn active" data-anim="none"><span class="icon">‚èπ</span>None</div>
        <div class="dev-btn" data-anim="zoomBeat"><span class="icon">üéµ</span>Zoom Beat</div>
        <div class="dev-btn" data-anim="velocityEdit"><span class="icon">‚ö°</span>Velocity</div>
        <div class="dev-btn" data-anim="smoothSlide"><span class="icon">‚û°Ô∏è</span>Slide</div>
        <div class="dev-btn" data-anim="bounceIn"><span class="icon">üèÄ</span>Bounce</div>
        <div class="dev-btn" data-anim="glitch"><span class="icon">üì∫</span>Glitch</div>
        <div class="dev-btn" data-anim="cinematicPan"><span class="icon">üé•</span>Cine Pan</div>
        <div class="dev-btn" data-anim="shake"><span class="icon">üì≥</span>Shake</div>
      </div>
      <div class="prop-row" style="margin-top:8px"><label>Intensity</label><input type="range" id="animIntensity" min="10" max="200" value="100"></div>
      <div class="prop-row"><label>BPM</label><input type="range" id="animBPM" min="60" max="200" value="120"><span id="animBPMVal" style="font-size:9px;color:#666;min-width:30px">120</span></div>
      <div style="margin-top:6px">
        <button class="btn" id="importCapcutBtn" style="width:100%;font-size:9px">Import CapCut Draft</button>
        <input type="file" id="capcutFileInput" accept=".json,application/json" style="display:none">
        <p style="font-size:8px;color:#555;margin-top:3px">Upload draft_content.json from CapCut Desktop project folder</p>
      </div>
    </div>
  </div>

  <!-- Canvas Stage -->
  <div class="stage" id="stage">
    <div class="canvas-wrap" id="canvasWrap">
      <canvas id="renderCanvas"></canvas>
      <div class="canvas-prompt visible" id="prompt">
        <svg viewBox="0 0 24 24"><path d="M19 13h-6v6h-2v-6H5v-2h6V5h2v6h6v2z"/></svg>
        <p>Drop a screen recording here<br>or click to load</p>
        <p class="sub">MP4 / MOV / WebM</p>
      </div>
    </div>
  </div>

  <!-- Right Panel -->
  <div class="panel right-panel" id="rightPanel">
    <button class="panel-toggle" id="rightPanelToggle" title="Toggle right panel ]">¬ª</button>
    <div class="panel-collapsed-label">Effects</div>
    <div class="panel-section">
      <div class="section-header">
        <h3>Background</h3>
        <button class="btn btn-danger" id="resetBgBtn">Reset</button>
      </div>
      <div class="prop-row">
        <label>Type</label>
        <select id="bgType">
          <option value="solid">Solid</option>
          <option value="gradient">Gradient</option>
          <option value="transparent">Transparent</option>
        </select>
      </div>
      <div id="bgSolidControls">
        <div class="prop-row"><label>Color</label><input type="color" id="bgColor" value="#0a0a0a"></div>
      </div>
      <div id="bgGradientControls" style="display:none">
        <div class="prop-row"><label>Color 1</label><input type="color" id="gradColor1" value="#0f0c29"></div>
        <div class="prop-row"><label>Color 2</label><input type="color" id="gradColor2" value="#302b63"></div>
        <div class="prop-row"><label>Color 3</label><input type="color" id="gradColor3" value="#24243e"></div>
        <div class="prop-row"><label>Angle</label><input type="range" id="gradAngle" min="0" max="360" value="135"></div>
        <div class="prop-row"><label>Animate</label>
          <select id="gradAnimated"><option value="false">Off</option><option value="true">On</option></select>
        </div>
      </div>
      <div class="prop-row"><label>Shadow</label><input type="range" id="shadowSlider" min="0" max="100" value="60"></div>
      <div style="margin-top:8px;border-top:1px solid rgba(255,255,255,0.04);padding-top:8px">
        <div class="section-header" style="margin-bottom:4px">
          <label style="font-size:9px;color:#666;font-weight:600">BG VIDEO</label>
          <button class="btn btn-danger" id="removeBgVideoBtn" style="display:none;padding:1px 6px;font-size:8px">Remove</button>
        </div>
        <button class="btn" id="loadBgVideoBtn" style="width:100%;font-size:9px">Load Background Video</button>
        <input type="file" id="bgVideoInput" accept="video/*" style="display:none">
        <p id="bgVideoStatus" style="font-size:8px;color:#555;margin-top:3px"></p>
        <div id="bgVideoControls" style="display:none">
          <div class="prop-row"><label>Opacity</label><input type="range" id="bgVideoOpacity" min="0" max="100" value="100"><span id="bgVideoOpacityVal" style="font-size:9px;color:#666;min-width:28px">100%</span></div>
          <div class="prop-row"><label>Fit</label>
            <select id="bgVideoFit">
              <option value="cover">Cover</option>
              <option value="contain">Contain</option>
              <option value="stretch">Stretch</option>
            </select>
          </div>
        </div>
      </div>
    </div>

    <div class="panel-section">
      <div class="section-header">
        <h3>Chroma Key (BG Remove)</h3>
        <button class="btn btn-danger" id="resetChromaBtn">Off</button>
      </div>
      <div class="prop-row"><label>Enable</label>
        <select id="chromaToggle"><option value="false">Off</option><option value="true">On</option></select>
      </div>
      <div id="chromaControls" style="display:none">
        <div class="prop-row"><label>Key Color</label><input type="color" id="chromaColor" value="#00ff00"></div>
        <div class="prop-row"><label>Tolerance</label><input type="range" id="chromaTolerance" min="10" max="200" value="80"></div>
        <div class="prop-row"><label>Softness</label><input type="range" id="chromaSoftness" min="0" max="80" value="10"></div>
        <p style="font-size:9px;color:#555;margin-top:4px">Pick the background color from your video to remove it. Works best with solid-color backgrounds.</p>
      </div>
    </div>

    <div class="panel-section">
      <div class="section-header">
        <h3>Effects</h3>
        <button class="btn btn-danger" id="resetEffectsBtn">Reset</button>
      </div>
      <div class="prop-row"><label>Particles</label>
        <select id="particleType">
          <option value="off">Off</option>
          <option value="bokeh">Bokeh</option>
          <option value="sparkle">Sparkle</option>
          <option value="confetti">Confetti</option>
          <option value="snow">Snow</option>
        </select>
      </div>
      <div class="prop-row"><label>Count</label><input type="range" id="particleCount" min="5" max="80" value="30"></div>
      <div class="prop-row"><label>Color</label><input type="color" id="particleColor" value="#ffffff"></div>
      <div class="prop-row"><label>Orbit</label>
        <select id="orbitToggle"><option value="false">Off</option><option value="true">On</option></select>
      </div>
      <div class="prop-row"><label>Speed</label><input type="range" id="orbitSpeed" min="5" max="100" value="30"></div>
      <div class="prop-row"><label>Blur</label>
        <select id="motionBlurToggle"><option value="false">Off</option><option value="true">On</option></select>
      </div>
    </div>

    <div class="panel-section">
      <div class="section-header">
        <h3>Overlays</h3>
        <button class="btn btn-danger" id="resetOverlaysBtn">Reset</button>
      </div>
      <div class="prop-row"><label>Progress</label>
        <select id="progressToggle"><option value="false">Off</option><option value="true">On</option></select>
        <input type="color" id="progressColor" value="#60a5fa">
      </div>
      <div class="prop-row"><label>Waveform</label>
        <select id="waveformToggle"><option value="false">Off</option><option value="true">On</option></select>
        <input type="color" id="waveformColor" value="#60a5fa">
      </div>
      <div class="prop-row"><label>Glass CTA</label>
        <select id="glassToggle"><option value="false">Off</option><option value="true">On</option></select>
      </div>
      <div id="glassControls" style="display:none">
        <div class="prop-row"><label>Text</label><input type="text" id="glassText" value="Your CTA Here"></div>
        <div class="prop-row"><label>Blur</label><input type="range" id="glassBlur" min="4" max="30" value="12"></div>
        <div class="prop-row"><label>Opacity</label><input type="range" id="glassOpacity" min="5" max="50" value="15"></div>
      </div>
    </div>

    <div class="panel-section">
      <div class="section-header">
        <h3>Video Overlays</h3>
        <button class="btn btn-danger" id="clearVideoOverlaysBtn">Clear</button>
      </div>
      <p style="font-size:8px;color:#555;margin-bottom:6px">Built-in effects (no files needed):</p>
      <div class="device-grid" id="builtinOverlayGrid" style="margin-bottom:8px">
        <div class="dev-btn" data-builtin="filmGrain">Film Grain</div>
        <div class="dev-btn" data-builtin="lightLeak">Light Leak</div>
        <div class="dev-btn" data-builtin="bokehLights">Bokeh</div>
        <div class="dev-btn" data-builtin="dust">Dust</div>
        <div class="dev-btn" data-builtin="vignette">Vignette</div>
        <div class="dev-btn" data-builtin="chromatic">Chromatic</div>
        <div class="dev-btn" data-builtin="scanlines">Scanlines</div>
        <div class="dev-btn" data-builtin="filmBurn">Film Burn</div>
      </div>
      <p style="font-size:8px;color:#555;margin-bottom:4px">Or load your own overlay videos:</p>
      <button class="btn" id="addVideoOverlayBtn" style="width:100%;margin-bottom:6px">+ Add Overlay Video</button>
      <input type="file" id="videoOverlayInput" accept="video/*" style="display:none" multiple>
      <div id="videoOverlayList"></div>
    </div>

    <div class="panel-section">
      <div class="section-header">
        <h3>Color Grading (LUT)</h3>
        <button class="btn btn-danger" id="clearLutBtn">Remove</button>
      </div>
      <p style="font-size:8px;color:#555;margin-bottom:6px">Quick presets:</p>
      <div class="device-grid" id="lutPresetGrid" style="margin-bottom:8px">
        <div class="dev-btn" data-lut-preset="none">None</div>
        <div class="dev-btn" data-lut-preset="cinematic">Cinematic</div>
        <div class="dev-btn" data-lut-preset="warmVintage">Warm Vintage</div>
        <div class="dev-btn" data-lut-preset="coolTeal">Cool Teal</div>
        <div class="dev-btn" data-lut-preset="bleachBypass">Bleach</div>
        <div class="dev-btn" data-lut-preset="moody">Moody</div>
        <div class="dev-btn" data-lut-preset="orangeTeal">Orange&Teal</div>
        <div class="dev-btn" data-lut-preset="bw">B&W Film</div>
      </div>
      <p style="font-size:8px;color:#555;margin-bottom:4px">Or load a .CUBE file:</p>
      <button class="btn" id="loadLutBtn" style="width:100%;margin-bottom:6px">Load .CUBE LUT</button>
      <input type="file" id="lutFileInput" accept=".cube,.CUBE" style="display:none">
      <div id="lutInfo" style="font-size:9px;color:#666;margin-top:4px"></div>
      <div id="lutControls" style="display:none">
        <div class="prop-row"><label>Intensity</label><input type="range" id="lutIntensity" min="0" max="100" value="100"><span id="lutIntensityVal" style="font-size:9px;color:#666;min-width:28px">100%</span></div>
      </div>
    </div>

    <div class="panel-section">
      <div class="section-header">
        <h3>Device Transform</h3>
        <button class="btn btn-danger" id="resetTransformBtn">Reset</button>
      </div>
      <div class="prop-row">
        <label>Scale</label>
        <input type="range" id="scaleSlider" min="15" max="100" value="45">
        <span id="scaleVal" style="font-size:10px;color:#777;min-width:28px">45%</span>
      </div>
      <div class="prop-row">
        <label>Fit</label>
        <select id="videoFitMode">
          <option value="cover">Cover</option>
          <option value="contain">Contain</option>
          <option value="stretch">Stretch</option>
        </select>
      </div>
      <div class="prop-row">
        <label>Tilt X</label>
        <input type="range" id="tiltX" min="-30" max="30" value="0">
      </div>
      <div class="prop-row">
        <label>Tilt Y</label>
        <input type="range" id="tiltY" min="-30" max="30" value="0">
      </div>
    </div>

    <div class="panel-section">
      <h3>Content</h3>
      <button class="btn" id="addTextBtn" style="width:100%;margin-bottom:6px">+ Add Text</button>
      <button class="btn" id="addLogoBtn" style="width:100%;margin-bottom:6px">+ Add Logo</button>
    </div>

    <div class="panel-section" id="textProps" style="display:none">
      <h3>Text Properties</h3>
      <div class="prop-row"><label>Text</label><input type="text" id="textContent" value="Title"></div>
      <div class="prop-row"><label>Font</label>
        <select id="textFont">
          <option value="SF Pro Display, -apple-system, sans-serif">SF Pro</option>
          <option value="Georgia, serif">Georgia</option>
          <option value="Courier New, monospace">Courier</option>
          <option value="Impact, sans-serif">Impact</option>
          <option value="Arial, sans-serif">Arial</option>
        </select>
      </div>
      <div class="prop-row"><label>Size</label><input type="range" id="textSize" min="12" max="120" value="36"></div>
      <div class="prop-row"><label>Color</label><input type="color" id="textColor" value="#ffffff"></div>
      <div class="prop-row"><label>Weight</label>
        <select id="textWeight">
          <option value="400">Regular</option>
          <option value="600">Semi Bold</option>
          <option value="700" selected>Bold</option>
          <option value="900">Black</option>
        </select>
      </div>
      <div class="prop-row"><label>Shadow</label><input type="range" id="textShadow" min="0" max="20" value="0"></div>
      <div class="prop-row"><label>Outline</label><input type="range" id="textOutline" min="0" max="10" value="0"></div>
    </div>

    <div class="panel-section" id="logoProps" style="display:none">
      <h3>Logo Properties</h3>
      <div class="prop-row"><label>Opacity</label><input type="range" id="logoOpacity" min="0" max="100" value="100"></div>
      <div class="prop-row"><label>Width</label><input type="range" id="logoWidth" min="20" max="400" value="100"></div>
    </div>

    <div class="panel-section">
      <div class="section-header">
        <h3>Annotations</h3>
        <button class="btn btn-danger" id="clearAnnotationsBtn">Clear</button>
      </div>
      <div class="anno-toolbar" id="annoToolbar">
        <button class="anno-btn" data-tool="arrow">Arrow</button>
        <button class="anno-btn" data-tool="circle">Circle</button>
        <button class="anno-btn" data-tool="rect">Rect</button>
        <button class="anno-btn" data-tool="freehand">Draw</button>
        <button class="anno-btn" data-tool="callout">Callout</button>
      </div>
      <div class="prop-row"><label>Color</label><input type="color" id="annoColor" value="#ff4444"></div>
      <div class="prop-row"><label>Width</label><input type="range" id="annoWidth" min="1" max="10" value="3"></div>
    </div>

    <div class="panel-section">
      <h3>Facecam</h3>
      <div style="display:flex;gap:4px;margin-bottom:6px">
        <button class="btn" id="facecamBtn" style="flex:1">Webcam</button>
        <button class="btn" id="facecamFileBtn" style="flex:1">Video File</button>
      </div>
      <input type="file" id="facecamFileInput" accept="video/*">
      <div id="facecamProps" style="display:none">
        <div class="prop-row"><label>Size</label><input type="range" id="facecamSize" min="5" max="35" value="15"><span id="facecamSizeVal" style="font-size:9px;color:#666;min-width:24px">15%</span></div>
        <div class="prop-row"><label>Shape</label>
          <select id="facecamShape">
            <option value="circle">Circle</option>
            <option value="roundrect">Rounded Rect</option>
            <option value="square">Square</option>
          </select>
        </div>
        <div class="prop-row"><label>Corner</label>
          <select id="facecamCorner">
            <option value="BR">Bottom Right</option>
            <option value="BL">Bottom Left</option>
            <option value="TR">Top Right</option>
            <option value="TL">Top Left</option>
            <option value="custom">Free Position</option>
          </select>
        </div>
        <div class="prop-row"><label>Border</label><input type="color" id="facecamBorderColor" value="#ffffff"><input type="range" id="facecamBorderWidth" min="0" max="8" value="3" style="flex:1"></div>
        <div class="prop-row"><label>Shadow</label>
          <select id="facecamShadow">
            <option value="true">On</option>
            <option value="false">Off</option>
          </select>
        </div>
        <button class="btn" id="facecamDisableBtn" style="width:100%;margin-top:4px;color:#f66;border-color:rgba(255,100,100,0.2)">Disable Facecam</button>
        <p style="font-size:9px;color:#555;margin-top:4px">Drag the facecam circle on the canvas to reposition</p>
      </div>
    </div>

    <div class="panel-section">
      <div class="section-header">
        <h3>Zoom Keyframes</h3>
        <button class="btn btn-danger" id="clearKeyframesBtn">Clear</button>
      </div>
      <button class="btn" id="addKeyframeBtn" style="width:100%;margin-bottom:6px">+ Add Keyframe</button>
      <div class="prop-row"><label>Zoom</label><input type="range" id="kfZoom" min="100" max="300" value="100"></div>
      <div class="prop-row"><label>Pan X</label><input type="range" id="kfPanX" min="-200" max="200" value="0"></div>
      <div class="prop-row"><label>Pan Y</label><input type="range" id="kfPanY" min="-200" max="200" value="0"></div>
    </div>

    <div class="panel-section">
      <h3>Project</h3>
      <div style="display:flex;gap:4px;margin-bottom:6px">
        <button class="btn" id="saveProjectBtn" style="flex:1">Save Project</button>
        <button class="btn" id="loadProjectBtn" style="flex:1">Load Project</button>
      </div>
      <input type="file" id="projectFileInput" accept=".json,application/json" style="display:none">
      <button class="btn" id="resetAllBtn" style="width:100%;color:#f66;border-color:rgba(255,100,100,0.2)">Reset All</button>
    </div>
  </div>
</div>

<!-- Timeline -->
<div class="timeline-bar" id="timelineBar">
  <div class="timeline-track" id="timelineTrack">
    <div class="timeline-scrubber" id="timelineScrubber"></div>
  </div>
  <div style="display:flex;gap:8px;align-items:center">
    <button class="btn" id="addClipBtn" style="font-size:9px">+ Add Clip</button>
    <label style="font-size:9px;color:#666">Transition
      <select id="transitionSelect" style="background:rgba(255,255,255,0.07);border:1px solid rgba(255,255,255,0.1);border-radius:3px;color:#ccc;padding:1px 3px;font-size:9px">
        <option value="cut">Cut</option>
        <option value="crossfade">Crossfade</option>
        <option value="slide">Slide</option>
      </select>
    </label>
  </div>
</div>

<!-- Playback Bar -->
<div class="playback-bar" id="playbackBar">
  <button class="play-btn" id="playBtn">
    <svg id="iconPlay" viewBox="0 0 24 24"><path d="M8 5v14l11-7z"/></svg>
    <svg id="iconPause" viewBox="0 0 24 24" style="display:none"><path d="M6 19h4V5H6v14zm8-14v14h4V5h-4z"/></svg>
  </button>
  <div class="progress-track" id="progressTrack">
    <div class="progress-fill" id="progressFill">
      <div class="progress-handle">
        <div class="progress-tooltip" id="progressTooltip"></div>
      </div>
    </div>
  </div>
  <span class="time-label" id="timeLabel">0:00 / 0:00</span>
  <span id="videoFileName" style="font-size:10px;color:#666;max-width:200px;overflow:hidden;text-overflow:ellipsis;white-space:nowrap"></span>
  <select class="speed-select" id="speedSelect">
    <option value="0.25">0.25x</option>
    <option value="0.5">0.5x</option>
    <option value="1" selected>1x</option>
    <option value="1.5">1.5x</option>
    <option value="2">2x</option>
  </select>
</div>

<!-- Drop overlay -->
<div class="drop-overlay" id="dropOverlay">Drop video file</div>

<!-- Asset Browser Modal -->
<div class="asset-browser" id="assetBrowser">
  <div class="asset-browser-header">
    <h2>Asset Library</h2>
    <input type="text" class="ab-search" id="abSearch" placeholder="Search assets...">
    <div style="flex:1"></div>
    <button class="ab-close" id="abClose">&times;</button>
  </div>
  <div class="asset-browser-body">
    <div class="ab-sidebar" id="abSidebar"></div>
    <div class="ab-content" id="abContent">
      <div class="ab-empty" id="abEmpty">
        <div style="font-size:40px">üìÇ</div>
        <div>Connect your asset folder</div>
        <p style="font-size:10px;color:#444;max-width:250px;text-align:center">Pick your Google Drive or local folder with LUTs, overlays, and video assets</p>
        <button class="btn btn-primary" id="abPickFolder">Choose Folder</button>
      </div>
    </div>
  </div>
</div>

<!-- Export status -->
<div class="export-status" id="exportStatus">
  <span id="exportText">Exporting...</span>
  <div class="bar"><div class="bar-fill" id="exportBarFill"></div></div>
</div>

<!-- Hidden elements -->
<input type="file" id="fileInput" accept="video/*">
<input type="file" id="logoInput" accept="image/*">
<input type="file" id="clipInput" accept="video/*">
<video id="srcVideo" style="display:none" playsinline></video>
<video id="srcVideo2" style="display:none" playsinline loop></video>
<video id="bgVideo" style="display:none" playsinline loop muted></video>

<script>
// ============================================================
// TOAST NOTIFICATIONS
// ============================================================
const toastContainer = document.getElementById('toastContainer');
function showToast(message, type) {
  type = type || 'info';
  const el = document.createElement('div');
  el.className = 'toast-item toast-' + type;
  el.textContent = message;
  // Enforce max 3 toasts
  while (toastContainer.children.length >= 3) {
    toastContainer.firstChild.remove();
  }
  toastContainer.appendChild(el);
  // Trigger slide-in
  requestAnimationFrame(() => { requestAnimationFrame(() => { el.classList.add('visible'); }); });
  // Auto-dismiss after 3s
  setTimeout(() => {
    el.classList.remove('visible');
    setTimeout(() => el.remove(), 300);
  }, 3000);
}

// ============================================================
// DEVICE REGISTRY
// ============================================================
const DEVICES = {
  iphone16: {
    id: 'iphone16', name: 'iPhone 16',
    baseW: 420, baseH: 864,
    screenX: 10, screenY: 10, screenW: 400, screenH: 844, screenR: 48, cornerR: 56,
    islandX: 149, islandY: 21, islandW: 122, islandH: 36, islandR: 18,
    camX: 244, camY: 39, camR: 5,
    colors: {
      black:    { edge:'#404042', mid:'#0f0f11', body:'#141416', bezel:'#07070a', label:'Black' },
      white:    { edge:'#e8e8e8', mid:'#f5f5f5', body:'#fafafa', bezel:'#e0e0e0', label:'White' },
      titanium: { edge:'#8a8580', mid:'#6b6560', body:'#7a756f', bezel:'#3a3530', label:'Titanium' },
      blue:     { edge:'#394860', mid:'#2a3548', body:'#313f55', bezel:'#0a0f18', label:'Blue' },
      pink:     { edge:'#e8c4c8', mid:'#dba8ae', body:'#e0b5ba', bezel:'#6a4548', label:'Pink' },
    },
    defaultColor: 'black',
    draw: function(c, S, pal) { drawIPhone16(c, S, this, pal); }
  },
  ipadpro: {
    id: 'ipadpro', name: 'iPad Pro',
    baseW: 620, baseH: 860,
    screenX: 16, screenY: 16, screenW: 588, screenH: 828, screenR: 20, cornerR: 28,
    colors: {
      spaceblack: { edge:'#2a2a2c', mid:'#1a1a1c', body:'#222224', bezel:'#111113', label:'Space Black' },
      silver:     { edge:'#d8d8d8', mid:'#e8e8e8', body:'#f0f0f0', bezel:'#c8c8c8', label:'Silver' },
    },
    defaultColor: 'spaceblack',
    draw: function(c, S, pal) { drawIPadPro(c, S, this, pal); }
  },
  macbookpro: {
    id: 'macbookpro', name: 'MacBook Pro',
    baseW: 800, baseH: 520,
    screenX: 48, screenY: 20, screenW: 704, screenH: 440, screenR: 8, cornerR: 16,
    colors: {
      spaceblack: { edge:'#2a2a2c', mid:'#1a1a1c', body:'#222224', bezel:'#111113', label:'Space Black' },
      silver:     { edge:'#d4d4d4', mid:'#e0e0e0', body:'#e8e8e8', bezel:'#c0c0c0', label:'Silver' },
    },
    defaultColor: 'spaceblack',
    draw: function(c, S, pal) { drawMacBookPro(c, S, this, pal); }
  },
  applewatch: {
    id: 'applewatch', name: 'Apple Watch',
    baseW: 260, baseH: 320,
    screenX: 24, screenY: 36, screenW: 212, screenH: 248, screenR: 40, cornerR: 56,
    colors: {
      midnight:  { edge:'#1a1a2e', mid:'#0f0f1a', body:'#151520', bezel:'#0a0a12', label:'Midnight' },
      starlight: { edge:'#e8e0d0', mid:'#f0e8d8', body:'#f5ede0', bezel:'#d8d0c0', label:'Starlight' },
      silver:    { edge:'#c8c8c8', mid:'#d8d8d8', body:'#e0e0e0', bezel:'#b0b0b0', label:'Silver' },
    },
    defaultColor: 'midnight',
    draw: function(c, S, pal) { drawAppleWatch(c, S, this, pal); }
  },
  none: {
    id: 'none', name: 'No Device',
    baseW: 1080, baseH: 1920,
    screenX: 0, screenY: 0, screenW: 1080, screenH: 1920, screenR: 0, cornerR: 0,
    colors: { default: { edge:'#000', mid:'#000', body:'#000', bezel:'#000', label:'None' } },
    defaultColor: 'default',
    draw: function() {}
  }
};

// ============================================================
// SOCIAL MEDIA PRESETS
// ============================================================
const PRESETS = {
  device: null, // tight crop
  reels:   { w: 1080, h: 1920 },
  twitter: { w: 1080, h: 1350 },
  youtube: { w: 1920, h: 1080 },
  square:  { w: 1080, h: 1080 },
  custom:  { w: 1080, h: 1920 },
};

// ============================================================
// STATE
// ============================================================
const state = {
  device: { type: 'iphone16', color: 'black', landscape: false, scale: 0.45 },
  videoFit: 'cover',
  perspective: { x: 0, y: 0 },
  background: { color: '#0a0a0a' },
  shadow: 0.6,
  preset: 'reels',
  layers: [],
  timeline: { trimIn: 0, trimOut: 1, speed: 1, clips: [], currentClip: 0, keyframes: [] },
  entrance: { type: 'none', duration: 1000 },
  facecam: { enabled: false, size: 0.15, x: -1, y: -1, shape: 'circle', borderColor: '#ffffff', borderWidth: 3, shadow: true, source: 'camera', stream: null },
  hand: { enabled: false, style: 'right' },
  comparison: { enabled: false, device2: null, video2: null },
  annotation: { tool: null, color: '#ff4444', width: 3, items: [] },
  gradient: { enabled: false, type: 'linear', color1: '#0f0c29', color2: '#302b63', color3: '#24243e', angle: 135, animated: false, speed: 1 },
  particles: { enabled: false, type: 'bokeh', count: 30, color: '#ffffff', speed: 0.5 },
  orbit: { enabled: false, speed: 0.3, axis: 'y', range: 15 },
  motionBlur: { enabled: false, amount: 0.15 },
  waveform: { enabled: false, color: '#60a5fa', height: 0.06, position: 'bottom', style: 'bars' },
  progressBar: { enabled: false, color: '#60a5fa', height: 4, position: 'top' },
  glassmorphism: { enabled: false, text: 'Your CTA Here', x: -1, y: -1, width: 280, height: 60, blur: 12, opacity: 0.15, borderOpacity: 0.2 },
  chromaKey: { enabled: false, color: '#00ff00', tolerance: 80, softness: 10 },
  videoOverlays: [],
  lut: { enabled: false, data: null, size: 0, intensity: 1.0, name: '' },
  bgVideo: { enabled: false, opacity: 1.0, fit: 'cover' },
  bgType: 'solid',
  animPreset: { type: 'none', intensity: 1.0, bpm: 120 },
  scene: 'custom',
  selectedLayer: -1,
  nextLayerId: 1,
  renderStack: [
    { id: 'bgVideo', name: 'BG Video', icon: 'üé¨' },
    { id: 'particles', name: 'Particles', icon: '‚ú®' },
    { id: 'device', name: 'Device', icon: 'üì±' },
    { id: 'device2', name: 'Device 2', icon: 'üì≤' },
    { id: 'content', name: 'Content', icon: 'T' },
    { id: 'facecam', name: 'Facecam', icon: 'üì∑' },
    { id: 'videoOverlays', name: 'Overlays', icon: 'üéû' },
    { id: 'uiOverlays', name: 'UI Effects', icon: 'üìä' },
  ],
  _particles: [], // runtime particle positions
};

// ============================================================
// UNDO / REDO
// ============================================================
const UNDO_MAX = 30;
const undoStack = [];
const redoStack = [];

function getUndoSnapshot() {
  return {
    device: { type: state.device.type, color: state.device.color, landscape: state.device.landscape, scale: state.device.scale },
    videoFit: state.videoFit,
    perspective: { x: state.perspective.x, y: state.perspective.y },
    background: { color: state.background.color },
    shadow: state.shadow,
    preset: state.preset,
    bgType: state.bgType,
    gradient: { ...state.gradient },
    particles: { enabled: state.particles.enabled, type: state.particles.type, count: state.particles.count, color: state.particles.color, speed: state.particles.speed },
    orbit: { enabled: state.orbit.enabled, speed: state.orbit.speed, axis: state.orbit.axis, range: state.orbit.range },
    motionBlur: { enabled: state.motionBlur.enabled, amount: state.motionBlur.amount },
    entrance: { type: state.entrance.type, duration: state.entrance.duration },
    animPreset: { type: state.animPreset.type, intensity: state.animPreset.intensity, bpm: state.animPreset.bpm },
    scene: state.scene,
    chromaKey: { enabled: state.chromaKey.enabled, color: state.chromaKey.color, tolerance: state.chromaKey.tolerance, softness: state.chromaKey.softness },
    lut: { enabled: state.lut.enabled, intensity: state.lut.intensity, name: state.lut.name, _presetKey: state.lut._presetKey || '' },
    waveform: { enabled: state.waveform.enabled, color: state.waveform.color, height: state.waveform.height, position: state.waveform.position, style: state.waveform.style },
    progressBar: { enabled: state.progressBar.enabled, color: state.progressBar.color, height: state.progressBar.height, position: state.progressBar.position },
    glassmorphism: { enabled: state.glassmorphism.enabled, text: state.glassmorphism.text, blur: state.glassmorphism.blur, opacity: state.glassmorphism.opacity },
    hand: { enabled: state.hand.enabled, style: state.hand.style },
    layers: state.layers.map(l => {
      const copy = { ...l };
      delete copy.img; // non-serializable
      if (l.type === 'annotation') copy.points = [...l.points];
      return copy;
    }),
    annotation: { tool: state.annotation.tool, color: state.annotation.color, width: state.annotation.width },
    videoOverlays: state.videoOverlays.filter(ov => ov.builtin).map(ov => ov.builtin),
    selectedLayer: state.selectedLayer,
  };
}

function applyUndoSnapshot(snap) {
  // Device
  state.device.type = snap.device.type;
  state.device.color = snap.device.color;
  state.device.landscape = snap.device.landscape;
  state.device.scale = snap.device.scale;
  frameCache = {};

  state.videoFit = snap.videoFit;
  state.perspective.x = snap.perspective.x;
  state.perspective.y = snap.perspective.y;
  state.background.color = snap.background.color;
  state.shadow = snap.shadow;
  state.preset = snap.preset;
  state.bgType = snap.bgType;
  Object.assign(state.gradient, snap.gradient);
  Object.assign(state.particles, snap.particles);
  Object.assign(state.orbit, snap.orbit);
  state.motionBlur.enabled = snap.motionBlur.enabled;
  state.motionBlur.amount = snap.motionBlur.amount;
  state.entrance.type = snap.entrance.type;
  state.entrance.duration = snap.entrance.duration;
  Object.assign(state.animPreset, snap.animPreset);
  state.scene = snap.scene;
  Object.assign(state.chromaKey, snap.chromaKey);
  state.lut.enabled = snap.lut.enabled;
  state.lut.intensity = snap.lut.intensity;
  state.lut.name = snap.lut.name;
  state.lut._presetKey = snap.lut._presetKey;
  if (snap.lut.enabled && snap.lut._presetKey) {
    const lut = generateLUTPreset(snap.lut._presetKey);
    state.lut.data = lut; state.lut.size = lut.size;
  } else if (!snap.lut.enabled) {
    state.lut.data = null; state.lut.size = 0;
  }
  Object.assign(state.waveform, snap.waveform);
  Object.assign(state.progressBar, snap.progressBar);
  Object.assign(state.glassmorphism, snap.glassmorphism);
  state.hand.enabled = snap.hand.enabled;
  state.hand.style = snap.hand.style;
  state.annotation.color = snap.annotation.color;
  state.annotation.width = snap.annotation.width;

  // Restore layers (rebuild non-serializable refs)
  state.layers = snap.layers.map(l => {
    const copy = { ...l };
    if (l.type === 'annotation') copy.points = [...l.points];
    return copy;
  });
  state.selectedLayer = snap.selectedLayer;

  // Restore builtin overlays
  state.videoOverlays = state.videoOverlays.filter(ov => !ov.builtin);
  for (const type of snap.videoOverlays) {
    state.videoOverlays.push({ id: Date.now() + Math.random(), builtin: type, name: type, opacity: 0.5, blendMode: 'screen' });
  }
}

function pushUndoState() {
  undoStack.push(getUndoSnapshot());
  if (undoStack.length > UNDO_MAX) undoStack.shift();
  redoStack.length = 0;
  updateUndoButtons();
}

function undo() {
  if (undoStack.length === 0) return;
  redoStack.push(getUndoSnapshot());
  const snap = undoStack.pop();
  applyUndoSnapshot(snap);
  updateUndoUI();
  updateUndoButtons();
  scheduleSave();
}

function redo() {
  if (redoStack.length === 0) return;
  undoStack.push(getUndoSnapshot());
  const snap = redoStack.pop();
  applyUndoSnapshot(snap);
  updateUndoUI();
  updateUndoButtons();
  scheduleSave();
}

function updateUndoButtons() {
  document.getElementById('undoBtn').disabled = undoStack.length === 0;
  document.getElementById('redoBtn').disabled = redoStack.length === 0;
}

function updateUndoUI() {
  // Device grid
  document.querySelectorAll('#deviceGrid .dev-btn').forEach(b => b.classList.toggle('active', b.dataset.device === state.device.type));
  if (typeof updateColorSwatches === 'function') updateColorSwatches();
  document.getElementById('landscapeBtn').classList.toggle('active', state.device.landscape);
  const toggles = document.getElementById('deviceToggles');
  if (toggles) toggles.style.display = state.device.type === 'none' ? 'none' : 'flex';

  // Transform controls
  document.getElementById('scaleSlider').value = Math.round(state.device.scale * 100);
  document.getElementById('videoFitMode').value = state.videoFit;
  document.getElementById('tiltX').value = state.perspective.x;
  document.getElementById('tiltY').value = state.perspective.y;
  document.getElementById('shadowSlider').value = Math.round(state.shadow * 100);

  // Background
  document.getElementById('bgColor').value = state.background.color;
  document.getElementById('bgType').value = state.bgType;
  document.getElementById('bgSolidControls').style.display = state.bgType === 'solid' ? 'block' : 'none';
  document.getElementById('bgGradientControls').style.display = state.bgType === 'gradient' ? 'block' : 'none';
  document.getElementById('gradColor1').value = state.gradient.color1;
  document.getElementById('gradColor2').value = state.gradient.color2;
  document.getElementById('gradColor3').value = state.gradient.color3;
  document.getElementById('gradAngle').value = state.gradient.angle;
  document.getElementById('gradAnimated').value = String(state.gradient.animated);

  // Preset
  document.getElementById('presetSelect').value = state.preset;
  resizeCanvas();

  // Particles
  document.getElementById('particleType').value = state.particles.enabled ? state.particles.type : 'off';
  document.getElementById('particleCount').value = state.particles.count;
  document.getElementById('particleColor').value = state.particles.color;

  // Orbit + motion blur
  document.getElementById('orbitToggle').value = String(state.orbit.enabled);
  document.getElementById('orbitSpeed').value = Math.round(state.orbit.speed * 100);
  document.getElementById('motionBlurToggle').value = String(state.motionBlur.enabled);

  // Entrance
  document.getElementById('entranceSelect').value = state.entrance.type;
  document.getElementById('entranceDur').value = state.entrance.duration;
  document.getElementById('entranceDurVal').textContent = (state.entrance.duration / 1000).toFixed(1) + 's';

  // Animation preset
  document.querySelectorAll('#animPresetGrid .dev-btn').forEach(b => b.classList.toggle('active', b.dataset.anim === state.animPreset.type));
  document.getElementById('animIntensity').value = Math.round(state.animPreset.intensity * 100);
  document.getElementById('animBPM').value = state.animPreset.bpm;
  document.getElementById('animBPMVal').textContent = state.animPreset.bpm;

  // Scene
  document.querySelectorAll('#sceneGrid .dev-btn').forEach(b => b.classList.toggle('active', b.dataset.scene === state.scene));

  // Chroma key
  document.getElementById('chromaToggle').value = String(state.chromaKey.enabled);
  document.getElementById('chromaControls').style.display = state.chromaKey.enabled ? 'block' : 'none';

  // LUT
  document.querySelectorAll('#lutPresetGrid .dev-btn').forEach(b => b.classList.remove('active'));
  if (state.lut._presetKey) {
    const lb = document.querySelector('#lutPresetGrid .dev-btn[data-lut-preset="' + state.lut._presetKey + '"]');
    if (lb) lb.classList.add('active');
  }
  document.getElementById('lutControls').style.display = state.lut.enabled ? 'block' : 'none';

  // Overlays UI
  document.getElementById('progressToggle').value = String(state.progressBar.enabled);
  document.getElementById('waveformToggle').value = String(state.waveform.enabled);
  document.getElementById('glassToggle').value = String(state.glassmorphism.enabled);
  document.getElementById('glassControls').style.display = state.glassmorphism.enabled ? 'block' : 'none';

  // Hand
  const handBtn = document.getElementById('handBtn');
  handBtn.classList.toggle('active', state.hand.enabled);
  handBtn.textContent = state.hand.enabled ? 'Disable Hand' : 'Enable Hand';
  document.getElementById('resetHandBtn').style.display = state.hand.enabled ? 'inline-block' : 'none';
  document.getElementById('handStyle').value = state.hand.style;

  // Builtin overlays
  document.querySelectorAll('#builtinOverlayGrid .dev-btn').forEach(b => b.classList.remove('active'));
  state.videoOverlays.filter(ov => ov.builtin).forEach(ov => {
    const ob = document.querySelector('#builtinOverlayGrid .dev-btn[data-builtin="' + ov.builtin + '"]');
    if (ob) ob.classList.add('active');
  });

  // Full preset grid
  document.querySelectorAll('#fullPresetGrid .preset-card').forEach(b => b.classList.remove('active'));

  // Layers
  if (typeof rebuildLayerList === 'function') rebuildLayerList();
  if (typeof rebuildUnifiedLayers === 'function') rebuildUnifiedLayers();
  if (typeof rebuildOverlayList === 'function') rebuildOverlayList();

  updatePerspective();
  updateDisplaySize();
}

// ============================================================
// RENDER SCALE + CANVAS
// ============================================================
const RENDER_SCALE = 3;
const canvas = document.getElementById('renderCanvas');
const ctx = canvas.getContext('2d');

function getCanvasSize() {
  const dev = DEVICES[state.device.type];
  const preset = PRESETS[state.preset];
  if (!preset) {
    // Device-only mode ‚Äî no device means default to reels
    if (state.device.type === 'none') return { w: 1080, h: 1920 };
    let w = dev.baseW, h = dev.baseH;
    if (state.device.landscape) { let t = w; w = h; h = t; }
    return { w: w * RENDER_SCALE, h: h * RENDER_SCALE };
  }
  return { w: preset.w, h: preset.h };
}

function resizeCanvas() {
  const sz = getCanvasSize();
  canvas.width = sz.w;
  canvas.height = sz.h;
  updateDisplaySize();
}

// ============================================================
// DOM REFS
// ============================================================
const video = document.getElementById('srcVideo');
const fileInput = document.getElementById('fileInput');
const logoInput = document.getElementById('logoInput');
const clipInput = document.getElementById('clipInput');
const promptEl = document.getElementById('prompt');
const dropOverlay = document.getElementById('dropOverlay');
const playbackBar = document.getElementById('playbackBar');
const playBtn = document.getElementById('playBtn');
const iconPlay = document.getElementById('iconPlay');
const iconPause = document.getElementById('iconPause');
const progressTrack = document.getElementById('progressTrack');
const progressFill = document.getElementById('progressFill');
const timeLabel = document.getElementById('timeLabel');
const bgColorInput = document.getElementById('bgColor');
const scaleSlider = document.getElementById('scaleSlider');
const scaleVal = document.getElementById('scaleVal');
const shadowSlider = document.getElementById('shadowSlider');
const loadBtn = document.getElementById('loadBtn');
const loopBtn = document.getElementById('loopBtn');
const ssBtn = document.getElementById('ssBtn');
const thumbBtn = document.getElementById('thumbBtn');
const exportBtn = document.getElementById('exportBtn');
const exportStatus = document.getElementById('exportStatus');
const exportText = document.getElementById('exportText');
const exportBarFill = document.getElementById('exportBarFill');
const canvasWrap = document.getElementById('canvasWrap');
const presetSelect = document.getElementById('presetSelect');
const customSizeWrap = document.getElementById('customSizeWrap');
const customW = document.getElementById('customW');
const customH = document.getElementById('customH');
const deviceGrid = document.getElementById('deviceGrid');
const layerList = document.getElementById('layerList');
const tiltXSlider = document.getElementById('tiltX');
const tiltYSlider = document.getElementById('tiltY');
const speedSelect = document.getElementById('speedSelect');
const entranceSelect = document.getElementById('entranceSelect');
const entranceDur = document.getElementById('entranceDur');
const entranceDurVal = document.getElementById('entranceDurVal');
const timelineBar = document.getElementById('timelineBar');
const timelineTrack = document.getElementById('timelineTrack');
const timelineScrubber = document.getElementById('timelineScrubber');

let hasVideo = false;
let isLooping = true;
let isExporting = false;
let playbackStartTime = 0;

// ============================================================
// HELPER: Rounded rect path
// ============================================================
function rrPath(c, x, y, w, h, r) {
  c.beginPath();
  c.moveTo(x + r, y);
  c.lineTo(x + w - r, y);
  c.quadraticCurveTo(x + w, y, x + w, y + r);
  c.lineTo(x + w, y + h - r);
  c.quadraticCurveTo(x + w, y + h, x + w - r, y + h);
  c.lineTo(x + r, y + h);
  c.quadraticCurveTo(x, y + h, x, y + h - r);
  c.lineTo(x, y + r);
  c.quadraticCurveTo(x, y, x + r, y);
  c.closePath();
}

function pillPath(c, x, y, w, h) {
  const r = h / 2;
  c.beginPath();
  c.moveTo(x + r, y);
  c.lineTo(x + w - r, y);
  c.arc(x + w - r, y + r, r, -Math.PI/2, Math.PI/2);
  c.lineTo(x + r, y + h);
  c.arc(x + r, y + r, r, Math.PI/2, -Math.PI/2);
  c.closePath();
}

// ============================================================
// DEVICE DRAW FUNCTIONS
// ============================================================
function drawIPhone16(c, S, dev, pal) {
  // Outer body
  rrPath(c, 0, 0, dev.baseW*S, dev.baseH*S, dev.cornerR*S);
  const bodyH = c.createLinearGradient(0, 0, dev.baseW*S, 0);
  bodyH.addColorStop(0, pal.edge);
  bodyH.addColorStop(0.015, pal.mid);
  bodyH.addColorStop(0.04, pal.body);
  bodyH.addColorStop(0.15, pal.body);
  bodyH.addColorStop(0.5, pal.mid);
  bodyH.addColorStop(0.85, pal.body);
  bodyH.addColorStop(0.96, pal.body);
  bodyH.addColorStop(0.985, pal.mid);
  bodyH.addColorStop(1, pal.edge);
  c.fillStyle = bodyH;
  c.fill();

  // Vertical ambient
  rrPath(c, 0, 0, dev.baseW*S, dev.baseH*S, dev.cornerR*S);
  const bodyV = c.createLinearGradient(0, 0, 0, dev.baseH*S);
  bodyV.addColorStop(0, 'rgba(255,255,255,0.07)');
  bodyV.addColorStop(0.03, 'rgba(255,255,255,0.03)');
  bodyV.addColorStop(0.15, 'rgba(255,255,255,0)');
  bodyV.addColorStop(0.85, 'rgba(255,255,255,0)');
  bodyV.addColorStop(0.97, 'rgba(255,255,255,0.02)');
  bodyV.addColorStop(1, 'rgba(255,255,255,0.05)');
  c.fillStyle = bodyV;
  c.fill();

  // Chamfered edge
  rrPath(c, 0.4*S, 0.4*S, (dev.baseW-0.8)*S, (dev.baseH-0.8)*S, (dev.cornerR-0.4)*S);
  c.strokeStyle = 'rgba(255,255,255,0.15)';
  c.lineWidth = 0.8*S;
  c.stroke();

  // Inner lip shadow
  rrPath(c, 3.5*S, 3.5*S, (dev.baseW-7)*S, (dev.baseH-7)*S, (dev.cornerR-3.5)*S);
  c.strokeStyle = 'rgba(0,0,0,0.6)';
  c.lineWidth = 1.5*S;
  c.stroke();

  // Screen bezel
  rrPath(c, 5*S, 5*S, (dev.baseW-10)*S, (dev.baseH-10)*S, (dev.cornerR-5)*S);
  c.fillStyle = pal.bezel;
  c.fill();

  // Screen cutout
  c.save();
  rrPath(c, dev.screenX*S, dev.screenY*S, dev.screenW*S, dev.screenH*S, dev.screenR*S);
  c.globalCompositeOperation = 'destination-out';
  c.fillStyle = '#000';
  c.fill();
  c.restore();

  // Dynamic Island
  pillPath(c, dev.islandX*S, dev.islandY*S, dev.islandW*S, dev.islandH*S);
  c.fillStyle = '#000000';
  c.fill();
  pillPath(c, dev.islandX*S, dev.islandY*S, dev.islandW*S, dev.islandH*S);
  c.strokeStyle = 'rgba(255,255,255,0.035)';
  c.lineWidth = 0.6*S;
  c.stroke();

  // Front camera
  const cx = dev.camX*S, cy = dev.camY*S;
  c.beginPath(); c.arc(cx, cy, 5.5*S, 0, Math.PI*2); c.fillStyle = '#0a0a14'; c.fill();
  c.beginPath(); c.arc(cx, cy, 4.5*S, 0, Math.PI*2);
  c.strokeStyle = 'rgba(80,80,140,0.3)'; c.lineWidth = 0.6*S; c.stroke();
  c.beginPath(); c.arc(cx, cy, 3*S, 0, Math.PI*2);
  const lg = c.createRadialGradient(cx, cy, 0, cx, cy, 3*S);
  lg.addColorStop(0, '#14142a'); lg.addColorStop(0.7, '#0d0d1a'); lg.addColorStop(1, '#06060e');
  c.fillStyle = lg; c.fill();
  c.beginPath(); c.arc(cx-1.2*S, cy-1.2*S, 1*S, 0, Math.PI*2);
  c.fillStyle = 'rgba(150,160,220,0.2)'; c.fill();

  // Side buttons
  const btnFill = pal.body === '#fafafa' ? '#d0d0d0' : '#252527';
  rrPath(c, (dev.baseW-0.2)*S, 218*S, 2.8*S, 72*S, 1.4*S);
  c.fillStyle = btnFill; c.fill();
  rrPath(c, -2.6*S, 192*S, 2.8*S, 42*S, 1.4*S);
  c.fillStyle = btnFill; c.fill();
  rrPath(c, -2.6*S, 245*S, 2.8*S, 42*S, 1.4*S);
  c.fillStyle = btnFill; c.fill();
  rrPath(c, -2.6*S, 146*S, 2.8*S, 26*S, 1.4*S);
  c.fillStyle = btnFill; c.fill();

  // Bottom details
  const bY = (dev.baseH - 4.5)*S;
  c.fillStyle = pal.bezel === '#e0e0e0' ? '#b0b0b0' : '#1c1c1e';
  for (let i = 0; i < 6; i++) {
    c.beginPath(); c.arc((dev.baseW/2 - 34 + i*9.5)*S, bY, 1.6*S, 0, Math.PI*2); c.fill();
  }
  for (let i = 0; i < 6; i++) {
    c.beginPath(); c.arc((dev.baseW/2 + 12 + i*9.5)*S, bY, 1.6*S, 0, Math.PI*2); c.fill();
  }
  rrPath(c, (dev.baseW/2 - 11)*S, (dev.baseH-5.5)*S, 22*S, 4.8*S, 2.4*S);
  c.fillStyle = pal.bezel === '#e0e0e0' ? '#c0c0c0' : '#18181b'; c.fill();
  rrPath(c, (dev.baseW/2 - 11)*S, (dev.baseH-5.5)*S, 22*S, 4.8*S, 2.4*S);
  c.strokeStyle = 'rgba(255,255,255,0.03)'; c.lineWidth = 0.3*S; c.stroke();
}

function drawIPadPro(c, S, dev, pal) {
  // Body
  rrPath(c, 0, 0, dev.baseW*S, dev.baseH*S, dev.cornerR*S);
  const bg = c.createLinearGradient(0, 0, dev.baseW*S, 0);
  bg.addColorStop(0, pal.edge); bg.addColorStop(0.02, pal.body);
  bg.addColorStop(0.98, pal.body); bg.addColorStop(1, pal.edge);
  c.fillStyle = bg; c.fill();

  // Edge highlight
  rrPath(c, 0.5*S, 0.5*S, (dev.baseW-1)*S, (dev.baseH-1)*S, (dev.cornerR-0.5)*S);
  c.strokeStyle = 'rgba(255,255,255,0.1)'; c.lineWidth = 0.6*S; c.stroke();

  // Bezel area
  rrPath(c, 8*S, 8*S, (dev.baseW-16)*S, (dev.baseH-16)*S, (dev.cornerR-8)*S);
  c.fillStyle = pal.bezel; c.fill();

  // Screen cutout
  c.save();
  rrPath(c, dev.screenX*S, dev.screenY*S, dev.screenW*S, dev.screenH*S, dev.screenR*S);
  c.globalCompositeOperation = 'destination-out';
  c.fillStyle = '#000'; c.fill();
  c.restore();

  // Front camera (landscape edge - top center)
  const camCx = (dev.baseW/2)*S, camCy = 8*S;
  c.beginPath(); c.arc(camCx, camCy, 3*S, 0, Math.PI*2);
  c.fillStyle = '#0a0a14'; c.fill();
  c.beginPath(); c.arc(camCx, camCy, 2*S, 0, Math.PI*2);
  c.fillStyle = '#06060e'; c.fill();

  // USB-C bottom
  rrPath(c, (dev.baseW/2 - 10)*S, (dev.baseH-4)*S, 20*S, 3.5*S, 1.7*S);
  c.fillStyle = pal.bezel === '#c8c8c8' ? '#a0a0a0' : '#18181b'; c.fill();
}

function drawMacBookPro(c, S, dev, pal) {
  const screenH = dev.screenY + dev.screenH + 16;
  const baseY = screenH;
  const baseH = dev.baseH - screenH;

  // Screen lid
  rrPath(c, 0, 0, dev.baseW*S, screenH*S, dev.cornerR*S);
  const bg = c.createLinearGradient(0, 0, dev.baseW*S, 0);
  bg.addColorStop(0, pal.edge); bg.addColorStop(0.02, pal.body);
  bg.addColorStop(0.98, pal.body); bg.addColorStop(1, pal.edge);
  c.fillStyle = bg; c.fill();

  // Bezel
  rrPath(c, 20*S, 10*S, (dev.baseW-40)*S, (screenH-12)*S, 8*S);
  c.fillStyle = pal.bezel; c.fill();

  // Screen cutout
  c.save();
  rrPath(c, dev.screenX*S, dev.screenY*S, dev.screenW*S, dev.screenH*S, dev.screenR*S);
  c.globalCompositeOperation = 'destination-out';
  c.fillStyle = '#000'; c.fill();
  c.restore();

  // Notch
  const notchW = 120, notchH = 18;
  const notchX = (dev.baseW - notchW) / 2;
  rrPath(c, notchX*S, dev.screenY*S, notchW*S, notchH*S, 6*S);
  c.fillStyle = pal.bezel; c.fill();
  // Camera in notch
  c.beginPath(); c.arc((dev.baseW/2)*S, (dev.screenY + notchH/2)*S, 2.5*S, 0, Math.PI*2);
  c.fillStyle = '#0a0a14'; c.fill();

  // Base / keyboard area
  c.fillStyle = pal.body;
  c.beginPath();
  c.moveTo(4*S, baseY*S);
  c.lineTo((dev.baseW-4)*S, baseY*S);
  c.lineTo((dev.baseW-2)*S, (baseY+3)*S);
  c.lineTo((dev.baseW-2)*S, (dev.baseH-6)*S);
  c.quadraticCurveTo((dev.baseW-2)*S, dev.baseH*S, (dev.baseW-8)*S, dev.baseH*S);
  c.lineTo(8*S, dev.baseH*S);
  c.quadraticCurveTo(2*S, dev.baseH*S, 2*S, (dev.baseH-6)*S);
  c.lineTo(2*S, (baseY+3)*S);
  c.closePath();
  c.fill();

  // Hinge line
  c.fillStyle = 'rgba(0,0,0,0.3)';
  c.fillRect(4*S, baseY*S, (dev.baseW-8)*S, 2*S);

  // Trackpad
  const tpW = 240, tpH = 80;
  const tpX = (dev.baseW - tpW)/2, tpY = baseY + baseH/2 - 10;
  rrPath(c, tpX*S, tpY*S, tpW*S, tpH*S, 6*S);
  c.strokeStyle = 'rgba(255,255,255,0.06)'; c.lineWidth = 0.5*S; c.stroke();
}

function drawAppleWatch(c, S, dev, pal) {
  // Body
  rrPath(c, 0, 0, dev.baseW*S, dev.baseH*S, dev.cornerR*S);
  const bg = c.createLinearGradient(0, 0, dev.baseW*S, 0);
  bg.addColorStop(0, pal.edge); bg.addColorStop(0.03, pal.body);
  bg.addColorStop(0.97, pal.body); bg.addColorStop(1, pal.edge);
  c.fillStyle = bg; c.fill();

  // Edge highlight
  rrPath(c, 0.5*S, 0.5*S, (dev.baseW-1)*S, (dev.baseH-1)*S, (dev.cornerR-0.5)*S);
  c.strokeStyle = 'rgba(255,255,255,0.1)'; c.lineWidth = 0.6*S; c.stroke();

  // Bezel
  rrPath(c, 10*S, 18*S, (dev.baseW-20)*S, (dev.baseH-36)*S, (dev.screenR+4)*S);
  c.fillStyle = pal.bezel; c.fill();

  // Screen cutout
  c.save();
  rrPath(c, dev.screenX*S, dev.screenY*S, dev.screenW*S, dev.screenH*S, dev.screenR*S);
  c.globalCompositeOperation = 'destination-out';
  c.fillStyle = '#000'; c.fill();
  c.restore();

  // Digital Crown (right side)
  rrPath(c, (dev.baseW-1)*S, 100*S, 6*S, 40*S, 3*S);
  c.fillStyle = pal.edge; c.fill();
  // Side button
  rrPath(c, (dev.baseW-0.5)*S, 160*S, 5*S, 24*S, 2*S);
  c.fillStyle = pal.edge; c.fill();
}

// ============================================================
// FRAME CACHE
// ============================================================
let frameCache = {};
function getDeviceFrame(deviceId, colorKey) {
  const key = deviceId + '_' + colorKey;
  if (frameCache[key]) return frameCache[key];

  const dev = DEVICES[deviceId];
  const pal = dev.colors[colorKey];
  const fc = document.createElement('canvas');
  fc.width = dev.baseW * RENDER_SCALE;
  fc.height = dev.baseH * RENDER_SCALE;
  const fCtx = fc.getContext('2d');
  dev.draw(fCtx, RENDER_SCALE, pal);
  frameCache[key] = fc;
  return fc;
}

// ============================================================
// HAND OVERLAY SVG PATHS
// ============================================================
function drawHandOverlay(c, dev, S, style, devX, devY) {
  if (dev.id !== 'iphone16' && dev.id !== 'applewatch') return;
  c.save();
  c.translate(devX, devY);

  const w = dev.baseW * S;
  const h = dev.baseH * S;

  c.fillStyle = '#e8c4a0';
  c.strokeStyle = '#c8a080';
  c.lineWidth = 1.5 * S;

  if (style === 'right') {
    // Right hand - fingers wrapping around left side, thumb on right
    // Palm behind phone
    c.beginPath();
    c.ellipse(w * 0.5, h * 1.02, w * 0.42, h * 0.12, 0, 0, Math.PI * 2);
    c.fill(); c.stroke();

    // Fingers on left
    for (let i = 0; i < 4; i++) {
      const fy = h * (0.35 + i * 0.1);
      c.beginPath();
      c.ellipse(-w * 0.04, fy, w * 0.06, h * 0.035, -0.2, 0, Math.PI * 2);
      c.fill(); c.stroke();
    }

    // Thumb on right
    c.beginPath();
    c.ellipse(w * 1.03, h * 0.55, w * 0.05, h * 0.08, 0.3, 0, Math.PI * 2);
    c.fill(); c.stroke();
  } else {
    // Left hand - mirror
    c.beginPath();
    c.ellipse(w * 0.5, h * 1.02, w * 0.42, h * 0.12, 0, 0, Math.PI * 2);
    c.fill(); c.stroke();

    for (let i = 0; i < 4; i++) {
      const fy = h * (0.35 + i * 0.1);
      c.beginPath();
      c.ellipse(w * 1.04, fy, w * 0.06, h * 0.035, 0.2, 0, Math.PI * 2);
      c.fill(); c.stroke();
    }

    c.beginPath();
    c.ellipse(-w * 0.03, h * 0.55, w * 0.05, h * 0.08, -0.3, 0, Math.PI * 2);
    c.fill(); c.stroke();
  }

  c.restore();
}

// ============================================================
// GRADIENT BACKGROUND
// ============================================================
let gradientAngleOffset = 0;

function drawGradientBG(c, CW, CH) {
  const g = state.gradient;
  if (g.animated) gradientAngleOffset += g.speed * 0.3;
  const angle = (g.angle + gradientAngleOffset) % 360;
  const rad = angle * Math.PI / 180;
  const cx = CW/2, cy = CH/2;
  const len = Math.max(CW, CH);
  const x1 = cx - Math.cos(rad) * len/2;
  const y1 = cy - Math.sin(rad) * len/2;
  const x2 = cx + Math.cos(rad) * len/2;
  const y2 = cy + Math.sin(rad) * len/2;
  const grad = c.createLinearGradient(x1, y1, x2, y2);
  grad.addColorStop(0, g.color1);
  grad.addColorStop(0.5, g.color2);
  grad.addColorStop(1, g.color3);
  c.fillStyle = grad;
  c.fillRect(0, 0, CW, CH);
}

// ============================================================
// PARTICLE SYSTEM
// ============================================================
function initParticles(CW, CH) {
  state._particles = [];
  for (let i = 0; i < state.particles.count; i++) {
    state._particles.push({
      x: Math.random() * CW, y: Math.random() * CH,
      size: Math.random() * 15 + 3,
      speedX: (Math.random() - 0.5) * 0.8,
      speedY: (Math.random() - 0.5) * 0.8 - 0.3,
      opacity: Math.random() * 0.5 + 0.2,
      phase: Math.random() * Math.PI * 2,
      hue: Math.random() * 360,
    });
  }
}

function drawParticles(c, CW, CH) {
  if (state._particles.length !== state.particles.count) initParticles(CW, CH);
  const t = performance.now() * 0.001;
  const spd = state.particles.speed;
  for (const p of state._particles) {
    p.x += p.speedX * spd; p.y += p.speedY * spd;
    if (p.y < -20) { p.y = CH + 20; p.x = Math.random() * CW; }
    if (p.x < -20) p.x = CW + 20;
    if (p.x > CW + 20) p.x = -20;
    if (p.y > CH + 20) { p.y = -20; p.x = Math.random() * CW; }
    const flicker = Math.sin(t * 1.5 + p.phase) * 0.3 + 0.7;
    c.save(); c.globalAlpha = p.opacity * flicker;
    if (state.particles.type === 'bokeh') {
      const grad = c.createRadialGradient(p.x, p.y, 0, p.x, p.y, p.size);
      grad.addColorStop(0, state.particles.color); grad.addColorStop(0.4, state.particles.color); grad.addColorStop(1, 'transparent');
      c.fillStyle = grad; c.beginPath(); c.arc(p.x, p.y, p.size, 0, Math.PI*2); c.fill();
    } else if (state.particles.type === 'sparkle') {
      c.fillStyle = state.particles.color; c.translate(p.x, p.y); c.rotate(t + p.phase);
      for (let j = 0; j < 4; j++) { c.fillRect(-0.5, -p.size*0.5, 1, p.size); c.rotate(Math.PI/4); }
    } else if (state.particles.type === 'confetti') {
      c.fillStyle = `hsl(${p.hue}, 80%, 65%)`; c.translate(p.x, p.y); c.rotate(t*2 + p.phase);
      c.fillRect(-p.size/2, -p.size/4, p.size, p.size/2);
    } else if (state.particles.type === 'snow') {
      c.fillStyle = '#fff'; p.x += Math.sin(t + p.phase)*0.3; p.speedY = Math.abs(p.speedY) || 0.5;
      c.beginPath(); c.arc(p.x, p.y, p.size*0.4, 0, Math.PI*2); c.fill();
    }
    c.restore();
  }
}

// ============================================================
// ORBIT (auto-spin)
// ============================================================
function getOrbitAngle() {
  if (!state.orbit.enabled) return 0;
  return Math.sin(performance.now() * 0.001 * state.orbit.speed) * state.orbit.range;
}

// ============================================================
// WAVEFORM VISUALIZER
// ============================================================
let audioAnalyser = null, analyserData = null;
function setupAudioAnalyser() {
  if (audioAnalyser) return;
  try {
    const actx = new (window.AudioContext || window.webkitAudioContext)();
    const source = actx.createMediaElementSource(document.getElementById('srcVideo'));
    audioAnalyser = actx.createAnalyser(); audioAnalyser.fftSize = 128;
    source.connect(audioAnalyser); audioAnalyser.connect(actx.destination);
    analyserData = new Uint8Array(audioAnalyser.frequencyBinCount);
  } catch(e) {}
}
function drawWaveform(c, CW, CH) {
  if (!audioAnalyser || !analyserData) return;
  audioAnalyser.getByteFrequencyData(analyserData);
  const barCount = analyserData.length, barW = CW / barCount;
  const maxH = CH * state.waveform.height;
  c.save();
  for (let i = 0; i < barCount; i++) {
    const val = analyserData[i] / 255; const h = val * maxH;
    c.fillStyle = state.waveform.color; c.globalAlpha = 0.6 + val*0.4;
    if (state.waveform.position === 'top') c.fillRect(i*barW, 0, barW-1, h);
    else c.fillRect(i*barW, CH-h, barW-1, h);
  }
  c.restore();
}

// ============================================================
// PROGRESS BAR OVERLAY
// ============================================================
function drawProgressBar(c, CW, CH) {
  const vid = document.getElementById('srcVideo');
  if (!vid || !vid.duration) return;
  const pct = vid.currentTime / vid.duration;
  const h = state.progressBar.height;
  const y = state.progressBar.position === 'top' ? 0 : CH - h;
  c.save();
  c.fillStyle = 'rgba(255,255,255,0.1)'; c.fillRect(0, y, CW, h);
  c.fillStyle = state.progressBar.color; c.fillRect(0, y, CW*pct, h);
  c.restore();
}

// ============================================================
// GLASSMORPHISM OVERLAY
// ============================================================
function drawGlassmorphism(c, CW, CH) {
  const g = state.glassmorphism;
  const gx = g.x >= 0 ? g.x : (CW - g.width)/2;
  const gy = g.y >= 0 ? g.y : CH*0.82;
  if (g.x < 0) { g.x = gx; g.y = gy; }
  c.save();
  rrPath(c, gx, gy, g.width, g.height, 16);
  c.fillStyle = `rgba(255,255,255,${g.opacity/100})`; c.fill();
  rrPath(c, gx, gy, g.width, g.height, 16);
  c.strokeStyle = `rgba(255,255,255,${g.borderOpacity})`; c.lineWidth = 1.5; c.stroke();
  rrPath(c, gx, gy, g.width, g.height*0.5, 16);
  c.fillStyle = `rgba(255,255,255,${g.opacity/300})`; c.fill();
  c.fillStyle = '#fff'; c.font = `600 ${Math.round(g.height*0.32)}px -apple-system, sans-serif`;
  c.textAlign = 'center'; c.textBaseline = 'middle';
  c.fillText(g.text, gx + g.width/2, gy + g.height/2);
  c.restore();
}

// ============================================================
// ANIMATION PRESETS (CapCut-style)
// ============================================================
function getAnimPresetTransform(time) {
  const preset = state.animPreset;
  if (preset.type === 'none') return { zoom: 1, panX: 0, panY: 0, rotation: 0 };

  const intensity = preset.intensity;
  const beatInterval = 60 / preset.bpm; // seconds per beat
  const t = time || 0;
  const beatPhase = (t % beatInterval) / beatInterval; // 0-1 within each beat
  const halfBeat = (t % (beatInterval/2)) / (beatInterval/2);

  switch (preset.type) {
    case 'zoomBeat': {
      // Zoom in on each beat, snap back
      const zoomPulse = Math.sin(beatPhase * Math.PI) * 0.12 * intensity;
      return { zoom: 1 + zoomPulse, panX: 0, panY: 0, rotation: 0 };
    }
    case 'velocityEdit': {
      // Speed ramp feel: alternating zoom + subtle rotation
      const cycle = (t % (beatInterval * 4)) / (beatInterval * 4);
      const slowPhase = cycle < 0.3;
      const zv = slowPhase
        ? Math.sin(cycle / 0.3 * Math.PI) * 0.08 * intensity
        : Math.sin((cycle - 0.3) / 0.7 * Math.PI * 3) * 0.04 * intensity;
      const rv = Math.sin(t * 1.5) * 1.5 * intensity;
      return { zoom: 1 + zv, panX: 0, panY: 0, rotation: rv };
    }
    case 'smoothSlide': {
      // Smooth horizontal pan, oscillating
      const cycle = (t % (beatInterval * 8)) / (beatInterval * 8);
      const px = Math.sin(cycle * Math.PI * 2) * 60 * intensity;
      const py = Math.cos(cycle * Math.PI * 2) * 20 * intensity;
      return { zoom: 1.02, panX: px, panY: py, rotation: 0 };
    }
    case 'bounceIn': {
      // Elastic bounce on each beat
      const decay = Math.exp(-beatPhase * 6);
      const bounce = Math.sin(beatPhase * Math.PI * 4) * decay;
      return { zoom: 1 + bounce * 0.15 * intensity, panX: 0, panY: bounce * -30 * intensity, rotation: 0 };
    }
    case 'glitch': {
      // Glitch: random jitter on half-beats
      const isGlitchFrame = halfBeat < 0.15;
      if (isGlitchFrame) {
        const seed = Math.floor(t * 30);
        const rx = ((seed * 9301 + 49297) % 233280) / 233280 - 0.5;
        const ry = ((seed * 7841 + 23497) % 133280) / 133280 - 0.5;
        return { zoom: 1 + rx * 0.04 * intensity, panX: rx * 25 * intensity, panY: ry * 15 * intensity, rotation: rx * 2 * intensity };
      }
      return { zoom: 1, panX: 0, panY: 0, rotation: 0 };
    }
    case 'cinematicPan': {
      // Slow dramatic zoom + pan
      const longCycle = (t % 10) / 10;
      const zoom = 1 + longCycle * 0.15 * intensity;
      const px = Math.sin(longCycle * Math.PI) * 40 * intensity;
      const py = Math.cos(longCycle * Math.PI * 0.5) * 15 * intensity;
      return { zoom, panX: px, panY: py, rotation: Math.sin(longCycle * Math.PI) * 0.8 * intensity };
    }
    case 'shake': {
      // Camera shake - fast random displacement
      const freq = 20;
      const px = Math.sin(t * freq * 2.3) * 8 * intensity + Math.sin(t * freq * 3.7) * 4 * intensity;
      const py = Math.cos(t * freq * 1.9) * 6 * intensity + Math.cos(t * freq * 4.1) * 3 * intensity;
      const rr = Math.sin(t * freq * 1.5) * 0.8 * intensity;
      return { zoom: 1, panX: px, panY: py, rotation: rr };
    }
    case 'capcut_imported': {
      // Imported keyframes - interpolate
      return interpolateImportedKeyframes(t);
    }
    default:
      return { zoom: 1, panX: 0, panY: 0, rotation: 0 };
  }
}

// Glitch post-processing (RGB split)
function drawGlitchEffect(c, CW, CH, time) {
  if (state.animPreset.type !== 'glitch') return;
  const beatInterval = 60 / state.animPreset.bpm;
  const halfBeat = (time % (beatInterval/2)) / (beatInterval/2);
  if (halfBeat > 0.15) return;

  const intensity = state.animPreset.intensity;
  const shift = Math.round(3 + intensity * 5);
  c.save();
  c.globalCompositeOperation = 'screen';
  c.globalAlpha = 0.6;
  // Red channel shift
  c.drawImage(canvas, shift, 0, CW - shift, CH, 0, 0, CW - shift, CH);
  // Blue channel shift
  c.globalAlpha = 0.4;
  c.drawImage(canvas, 0, 0, CW - shift, CH, shift, 0, CW - shift, CH);
  c.restore();

  // Scanlines
  c.save();
  c.globalAlpha = 0.08;
  c.fillStyle = '#000';
  for (let y = 0; y < CH; y += 4) {
    c.fillRect(0, y, CW, 2);
  }
  c.restore();
}

// ============================================================
// LUT PARSER & APPLICATOR
// ============================================================
function parseCubeLUT(text) {
  const lines = text.split('\n');
  let size = 0;
  const data = [];
  let title = '';
  for (const line of lines) {
    const trimmed = line.trim();
    if (!trimmed || trimmed.startsWith('#')) continue;
    if (trimmed.startsWith('TITLE')) { title = trimmed.replace(/^TITLE\s*"?/, '').replace(/"?\s*$/, ''); continue; }
    if (trimmed.startsWith('LUT_3D_SIZE')) { size = parseInt(trimmed.split(/\s+/)[1]); continue; }
    if (trimmed.startsWith('DOMAIN_MIN') || trimmed.startsWith('DOMAIN_MAX')) continue;
    const parts = trimmed.split(/\s+/).map(Number);
    if (parts.length >= 3 && !isNaN(parts[0])) {
      data.push(parts[0], parts[1], parts[2]);
    }
  }
  if (size === 0 || data.length < size * size * size * 3) return null;
  return { size, data: new Float32Array(data), title };
}

let lutCanvas = null, lutCtx = null;
function applyLUT(sourceCanvas, lut, intensity) {
  if (!lut || !lut.data) return;
  const fullW = sourceCanvas.width, fullH = sourceCanvas.height;
  // Downscale for performance ‚Äî process at max 480p then upscale back
  const maxDim = 480;
  const scale = Math.min(1, maxDim / Math.max(fullW, fullH));
  const w = Math.round(fullW * scale), h = Math.round(fullH * scale);
  if (!lutCanvas || lutCanvas.width !== w || lutCanvas.height !== h) {
    lutCanvas = document.createElement('canvas');
    lutCanvas.width = w; lutCanvas.height = h;
    lutCtx = lutCanvas.getContext('2d', { willReadFrequently: true });
  }
  lutCtx.drawImage(sourceCanvas, 0, 0, w, h);
  const imgData = lutCtx.getImageData(0, 0, w, h);
  const px = imgData.data;
  const sz = lut.size;
  const d = lut.data;
  const maxIdx = sz - 1;
  for (let i = 0; i < px.length; i += 4) {
    const r = px[i] / 255, g = px[i+1] / 255, b = px[i+2] / 255;
    const ri = r * maxIdx, gi = g * maxIdx, bi = b * maxIdx;
    const r0 = Math.floor(ri), r1 = Math.min(r0 + 1, maxIdx);
    const g0 = Math.floor(gi), g1 = Math.min(g0 + 1, maxIdx);
    const b0 = Math.floor(bi), b1 = Math.min(b0 + 1, maxIdx);
    const rf = ri - r0, gf = gi - g0, bf = bi - b0;
    const idx = (bv, gv, rv) => (bv * sz * sz + gv * sz + rv) * 3;
    const c000 = idx(b0, g0, r0), c100 = idx(b0, g0, r1);
    const c010 = idx(b0, g1, r0), c110 = idx(b0, g1, r1);
    const c001 = idx(b1, g0, r0), c101 = idx(b1, g0, r1);
    const c011 = idx(b1, g1, r0), c111 = idx(b1, g1, r1);
    for (let ch = 0; ch < 3; ch++) {
      const v000 = d[c000+ch], v100 = d[c100+ch], v010 = d[c010+ch], v110 = d[c110+ch];
      const v001 = d[c001+ch], v101 = d[c101+ch], v011 = d[c011+ch], v111 = d[c111+ch];
      const c00 = v000 + (v100 - v000) * rf;
      const c10 = v010 + (v110 - v010) * rf;
      const c01 = v001 + (v101 - v001) * rf;
      const c11 = v011 + (v111 - v011) * rf;
      const c0 = c00 + (c10 - c00) * gf;
      const c1 = c01 + (c11 - c01) * gf;
      const lutVal = (c0 + (c1 - c0) * bf) * 255;
      const orig = px[i + ch];
      px[i + ch] = Math.round(orig + (lutVal - orig) * intensity);
    }
  }
  lutCtx.putImageData(imgData, 0, 0);
  const srcCtx = sourceCanvas.getContext('2d');
  srcCtx.drawImage(lutCanvas, 0, 0, fullW, fullH);
}

// ============================================================
// VIDEO OVERLAY COMPOSITING
// ============================================================
function drawVideoOverlays(ctx, CW, CH) {
  for (const ov of state.videoOverlays) {
    if (ov.hidden) continue;
    // Built-in overlays (canvas-generated)
    if (ov.builtin) {
      drawBuiltinOverlay(ctx, CW, CH, ov);
      continue;
    }
    if (!ov.video || ov.video.readyState < 2) continue;
    ctx.save();
    ctx.globalAlpha = ov.opacity;
    ctx.globalCompositeOperation = ov.blendMode;
    const vw = ov.video.videoWidth, vh = ov.video.videoHeight;
    const vRatio = vw / vh, cRatio = CW / CH;
    let dw, dh, dx, dy;
    if (vRatio > cRatio) { dh = CH; dw = CH * vRatio; dx = (CW - dw) / 2; dy = 0; }
    else { dw = CW; dh = CW / vRatio; dx = 0; dy = (CH - dh) / 2; }
    ctx.drawImage(ov.video, dx, dy, dw, dh);
    ctx.restore();
  }
}

function drawBuiltinOverlay(ctx, CW, CH, ov) {
  const t = performance.now() * 0.001;
  ctx.save();
  ctx.globalAlpha = ov.opacity;

  if (ov.builtin === 'filmGrain') {
    ctx.globalCompositeOperation = 'overlay';
    const imgData = ctx.getImageData(0, 0, Math.min(CW, 640), Math.min(CH, 640));
    // Only process a sampled region for performance
    const grainCanvas = ov._cache || document.createElement('canvas');
    if (!ov._cache) { ov._cache = grainCanvas; grainCanvas.width = 320; grainCanvas.height = 320; }
    const gc = grainCanvas.getContext('2d');
    const gd = gc.createImageData(320, 320);
    const px = gd.data;
    for (let i = 0; i < px.length; i += 4) {
      const v = Math.random() * 255;
      px[i] = px[i+1] = px[i+2] = v; px[i+3] = 40;
    }
    gc.putImageData(gd, 0, 0);
    ctx.drawImage(grainCanvas, 0, 0, CW, CH);

  } else if (ov.builtin === 'lightLeak') {
    ctx.globalCompositeOperation = 'screen';
    const g = ctx.createRadialGradient(
      CW * (0.3 + 0.4 * Math.sin(t * 0.5)), CH * (0.3 + 0.2 * Math.cos(t * 0.3)),
      0,
      CW * 0.5, CH * 0.5, CW * 0.7
    );
    const hue = (t * 20) % 360;
    g.addColorStop(0, `hsla(${hue}, 80%, 60%, 0.4)`);
    g.addColorStop(0.4, `hsla(${(hue + 40) % 360}, 70%, 50%, 0.15)`);
    g.addColorStop(1, 'transparent');
    ctx.fillStyle = g;
    ctx.fillRect(0, 0, CW, CH);
    // Second leak
    const g2 = ctx.createRadialGradient(
      CW * (0.7 + 0.2 * Math.cos(t * 0.4)), CH * (0.6 + 0.3 * Math.sin(t * 0.6)),
      0,
      CW * 0.6, CH * 0.4, CW * 0.5
    );
    g2.addColorStop(0, `hsla(${(hue + 180) % 360}, 70%, 55%, 0.25)`);
    g2.addColorStop(1, 'transparent');
    ctx.fillStyle = g2;
    ctx.fillRect(0, 0, CW, CH);

  } else if (ov.builtin === 'bokehLights') {
    ctx.globalCompositeOperation = 'screen';
    if (!ov._bokeh || ov._bokeh.length === 0) {
      ov._bokeh = [];
      for (let i = 0; i < 20; i++) {
        ov._bokeh.push({
          x: Math.random(), y: Math.random(),
          r: 0.02 + Math.random() * 0.06,
          speed: 0.1 + Math.random() * 0.3,
          hue: Math.random() * 360,
          phase: Math.random() * Math.PI * 2
        });
      }
    }
    for (const b of ov._bokeh) {
      const bx = CW * ((b.x + Math.sin(t * b.speed + b.phase) * 0.05) % 1);
      const by = CH * ((b.y + t * b.speed * 0.02) % 1);
      const br = Math.min(CW, CH) * b.r;
      const alpha = 0.15 + 0.1 * Math.sin(t * b.speed * 2 + b.phase);
      const g = ctx.createRadialGradient(bx, by, 0, bx, by, br);
      g.addColorStop(0, `hsla(${b.hue}, 60%, 70%, ${alpha})`);
      g.addColorStop(0.7, `hsla(${b.hue}, 60%, 70%, ${alpha * 0.3})`);
      g.addColorStop(1, 'transparent');
      ctx.fillStyle = g;
      ctx.fillRect(bx - br, by - br, br * 2, br * 2);
    }

  } else if (ov.builtin === 'dust') {
    ctx.globalCompositeOperation = 'screen';
    if (!ov._dust || ov._dust.length === 0) {
      ov._dust = [];
      for (let i = 0; i < 60; i++) {
        ov._dust.push({
          x: Math.random(), y: Math.random(),
          size: 1 + Math.random() * 3,
          speed: 0.01 + Math.random() * 0.03,
          drift: (Math.random() - 0.5) * 0.02,
          alpha: 0.3 + Math.random() * 0.5
        });
      }
    }
    ctx.fillStyle = '#fff';
    for (const d of ov._dust) {
      const dx = CW * ((d.x + d.drift * t) % 1);
      const dy = CH * ((d.y - d.speed * t * 0.5) % 1 + 1) % CH;
      ctx.globalAlpha = ov.opacity * d.alpha * (0.5 + 0.5 * Math.sin(t * 2 + d.x * 10));
      ctx.beginPath();
      ctx.arc(dx, dy, d.size, 0, Math.PI * 2);
      ctx.fill();
    }

  } else if (ov.builtin === 'vignette') {
    ctx.globalCompositeOperation = 'multiply';
    const g = ctx.createRadialGradient(CW/2, CH/2, CW * 0.25, CW/2, CH/2, CW * 0.75);
    g.addColorStop(0, 'rgba(255,255,255,1)');
    g.addColorStop(1, 'rgba(0,0,0,1)');
    ctx.fillStyle = g;
    ctx.fillRect(0, 0, CW, CH);

  } else if (ov.builtin === 'chromatic') {
    ctx.globalCompositeOperation = 'screen';
    const shift = 3 + 2 * Math.sin(t);
    ctx.globalAlpha = 0.15 * ov.opacity;
    ctx.drawImage(ctx.canvas, shift, 0, CW - shift, CH, 0, 0, CW - shift, CH);
    ctx.globalAlpha = 0.1 * ov.opacity;
    ctx.drawImage(ctx.canvas, 0, 0, CW - shift, CH, shift, 0, CW - shift, CH);

  } else if (ov.builtin === 'scanlines') {
    ctx.globalCompositeOperation = 'multiply';
    ctx.fillStyle = 'rgba(0,0,0,1)';
    for (let y = 0; y < CH; y += 4) {
      ctx.globalAlpha = 0.08 * ov.opacity;
      ctx.fillRect(0, y, CW, 2);
    }

  } else if (ov.builtin === 'filmBurn') {
    ctx.globalCompositeOperation = 'screen';
    const phase = t * 0.3;
    const g = ctx.createLinearGradient(
      CW * (0.5 + 0.5 * Math.sin(phase)), 0,
      CW * (0.5 + 0.5 * Math.cos(phase + 1)), CH
    );
    g.addColorStop(0, `hsla(30, 90%, 50%, ${0.15 + 0.1 * Math.sin(t)})`);
    g.addColorStop(0.3, `hsla(15, 80%, 40%, ${0.08 + 0.05 * Math.cos(t * 1.3)})`);
    g.addColorStop(0.6, 'transparent');
    g.addColorStop(1, `hsla(350, 70%, 30%, ${0.05 + 0.03 * Math.sin(t * 0.7)})`);
    ctx.fillStyle = g;
    ctx.fillRect(0, 0, CW, CH);
  }

  ctx.restore();
}

// CapCut draft importer
let importedKeyframes = [];

function parseCapcutDraft(json) {
  try {
    const draft = typeof json === 'string' ? JSON.parse(json) : json;
    const keyframes = [];

    // CapCut stores tracks > segments > common_keyframes
    const tracks = draft.tracks || draft.materials?.tracks || [];
    for (const track of tracks) {
      const segments = track.segments || track.segment_list || [];
      for (const seg of segments) {
        const kfGroups = seg.common_keyframes || seg.keyframes || [];
        for (const kfGroup of kfGroups) {
          const propType = kfGroup.property_type || kfGroup.type || '';
          const kfList = kfGroup.keyframe_list || kfGroup.keyframes || [];
          for (const kf of kfList) {
            const time = (kf.time_offset || kf.time || 0) / 1000000; // microseconds to seconds
            const values = kf.values || [0];
            keyframes.push({ time, property: propType, value: values[0], curve: kf.curveType || 'Linear' });
          }
        }

        // Also extract transform data
        const clip = seg.clip || {};
        const transform = clip.transform || {};
        if (transform.scale_x !== undefined) {
          const startTime = (seg.target_timerange?.start || 0) / 1000000;
          keyframes.push({ time: startTime, property: 'scale', value: transform.scale_x, curve: 'Linear' });
        }
        if (transform.rotation !== undefined) {
          const startTime = (seg.target_timerange?.start || 0) / 1000000;
          keyframes.push({ time: startTime, property: 'rotation', value: transform.rotation, curve: 'Linear' });
        }
        if (transform.position_x !== undefined) {
          const startTime = (seg.target_timerange?.start || 0) / 1000000;
          keyframes.push({ time: startTime, property: 'positionX', value: transform.position_x, curve: 'Linear' });
        }

        // Speed data for velocity edits
        if (clip.speed !== undefined && clip.speed !== 1) {
          const startTime = (seg.target_timerange?.start || 0) / 1000000;
          keyframes.push({ time: startTime, property: 'speed', value: clip.speed, curve: 'Linear' });
        }
      }
    }

    keyframes.sort((a, b) => a.time - b.time);
    return keyframes;
  } catch (e) {
    console.error('CapCut parse error:', e);
    return [];
  }
}

function interpolateImportedKeyframes(time) {
  if (importedKeyframes.length === 0) return { zoom: 1, panX: 0, panY: 0, rotation: 0 };

  let zoom = 1, panX = 0, panY = 0, rotation = 0;

  // Group by property
  const byProp = {};
  for (const kf of importedKeyframes) {
    if (!byProp[kf.property]) byProp[kf.property] = [];
    byProp[kf.property].push(kf);
  }

  function lerp(kfs, t) {
    if (kfs.length === 0) return 0;
    if (kfs.length === 1) return kfs[0].value;
    if (t <= kfs[0].time) return kfs[0].value;
    if (t >= kfs[kfs.length - 1].time) return kfs[kfs.length - 1].value;
    for (let i = 0; i < kfs.length - 1; i++) {
      if (t >= kfs[i].time && t <= kfs[i + 1].time) {
        const p = (t - kfs[i].time) / (kfs[i + 1].time - kfs[i].time);
        return kfs[i].value + (kfs[i + 1].value - kfs[i].value) * p;
      }
    }
    return kfs[kfs.length - 1].value;
  }

  if (byProp['scale'] || byProp['KFTypePositionScale']) {
    zoom = lerp(byProp['scale'] || byProp['KFTypePositionScale'], time);
    if (zoom > 0) zoom = zoom; else zoom = 1;
  }
  if (byProp['positionX'] || byProp['KFTypePositionX']) {
    panX = lerp(byProp['positionX'] || byProp['KFTypePositionX'], time) * state.animPreset.intensity;
  }
  if (byProp['positionY'] || byProp['KFTypePositionY']) {
    panY = lerp(byProp['positionY'] || byProp['KFTypePositionY'], time) * state.animPreset.intensity;
  }
  if (byProp['rotation'] || byProp['KFTypeRotation']) {
    rotation = lerp(byProp['rotation'] || byProp['KFTypeRotation'], time);
  }

  return { zoom, panX, panY, rotation };
}

// ============================================================
// CHROMA KEY (BACKGROUND REMOVER)
// ============================================================
let chromaCanvas = null, chromaCtx = null;

function getChromaKeyFrame(srcVideo) {
  if (!state.chromaKey.enabled || !srcVideo || srcVideo.readyState < 2) return null;

  const maxW = 640; // limit processing size for performance
  const vw = srcVideo.videoWidth, vh = srcVideo.videoHeight;
  const w = Math.min(vw, maxW);
  const h = Math.round(w * vh / vw);

  if (!chromaCanvas || chromaCanvas.width !== w || chromaCanvas.height !== h) {
    chromaCanvas = document.createElement('canvas');
    chromaCanvas.width = w;
    chromaCanvas.height = h;
    chromaCtx = chromaCanvas.getContext('2d', { willReadFrequently: true });
  }

  chromaCtx.drawImage(srcVideo, 0, 0, w, h);
  const imageData = chromaCtx.getImageData(0, 0, w, h);
  const data = imageData.data;

  const ck = state.chromaKey;
  const r0 = parseInt(ck.color.substr(1,2), 16);
  const g0 = parseInt(ck.color.substr(3,2), 16);
  const b0 = parseInt(ck.color.substr(5,2), 16);
  const tol = ck.tolerance;
  const soft = ck.softness;

  for (let i = 0; i < data.length; i += 4) {
    const dr = data[i] - r0;
    const dg = data[i+1] - g0;
    const db = data[i+2] - b0;
    const dist = Math.sqrt(dr*dr + dg*dg + db*db);

    if (dist < tol) {
      data[i+3] = 0; // fully transparent
    } else if (dist < tol + soft) {
      data[i+3] = Math.round(255 * (dist - tol) / soft);
    }
  }

  chromaCtx.putImageData(imageData, 0, 0);
  return chromaCanvas;
}

// ============================================================
// SCENE TEMPLATES
// ============================================================
// ============================================================
// FULL PRESET TEMPLATES
// ============================================================
const FULL_PRESETS = {
  appShowcase: {
    device: { type: 'iphone16', color: 'black' },
    preset: 'reels', scale: 0.45,
    bg: { type: 'gradient', color: '#0a0a0a', gradient: { enabled:true, color1:'#000000', color2:'#1a1a2e', color3:'#000000', angle:90, animated:false, speed:0 } },
    shadow: 0.8, lut: 'cinematic', overlays: ['vignette'],
    entrance: { type: 'scaleIn', duration: 1000 }, animPreset: 'none',
    particles: { enabled:true, type:'bokeh', count:10, color:'#fbbf24', speed:0.15 },
    orbit: { enabled:true, speed:0.1, range:4 },
    text: [{ content: 'Your App Name', fontSize: 44, color: '#ffffff', weight: '700', yPct: 0.07 }],
  },
  tiktokViral: {
    device: { type: 'iphone16', color: 'pink' },
    preset: 'reels', scale: 0.45,
    bg: { type: 'gradient', color: '#0a0a0a', gradient: { enabled:true, color1:'#f97316', color2:'#db2777', color3:'#7c3aed', angle:160, animated:true, speed:0.3 } },
    shadow: 0.5, lut: 'warmVintage', overlays: ['filmGrain'],
    entrance: { type: 'slideUp', duration: 800 }, animPreset: 'zoomBeat',
    particles: { enabled:true, type:'bokeh', count:15, color:'#fbbf24', speed:0.2 },
    orbit: { enabled:false },
    text: [{ content: 'Watch This', fontSize: 52, color: '#ffffff', weight: '900', yPct: 0.06 }],
  },
  cleanProduct: {
    device: { type: 'iphone16', color: 'white' },
    preset: 'reels', scale: 0.42,
    bg: { type: 'solid', color: '#f5f5f5', gradient: { enabled:false } },
    shadow: 0.3, lut: null, overlays: [],
    entrance: { type: 'fadeIn', duration: 800 }, animPreset: 'none',
    particles: { enabled:false }, orbit: { enabled:false },
    text: [],
  },
  darkCinematic: {
    device: { type: 'iphone16', color: 'black' },
    preset: 'reels', scale: 0.45,
    bg: { type: 'gradient', color: '#0a0a0a', gradient: { enabled:true, color1:'#000000', color2:'#0f0f1a', color3:'#000000', angle:180, animated:false, speed:0 } },
    shadow: 1.0, lut: 'moody', overlays: ['filmBurn', 'vignette'],
    entrance: { type: 'fadeIn', duration: 1500 }, animPreset: 'cinematicPan',
    particles: { enabled:false }, orbit: { enabled:true, speed:0.08, range:3 },
    text: [],
  },
  neonPop: {
    device: { type: 'iphone16', color: 'blue' },
    preset: 'reels', scale: 0.45,
    bg: { type: 'gradient', color: '#0a0a0a', gradient: { enabled:true, color1:'#0a0015', color2:'#1a0030', color3:'#0a0015', angle:180, animated:true, speed:0.8 } },
    shadow: 1.0, lut: 'coolTeal', overlays: ['chromatic'],
    entrance: { type: 'scaleIn', duration: 600 }, animPreset: 'none',
    particles: { enabled:true, type:'sparkle', count:20, color:'#c084fc', speed:0.4 },
    orbit: { enabled:false },
    text: [],
  },
  cleanSocial: {
    device: { type: 'none', color: 'default' },
    preset: 'reels', scale: 0.45,
    bg: { type: 'solid', color: '#0a0a0a', gradient: { enabled:false } },
    shadow: 0, lut: 'orangeTeal', overlays: ['vignette'],
    entrance: { type: 'none', duration: 1000 }, animPreset: 'none',
    particles: { enabled:false }, orbit: { enabled:false },
    text: [],
  },
  retroFilm: {
    device: { type: 'iphone16', color: 'titanium' },
    preset: 'reels', scale: 0.45,
    bg: { type: 'gradient', color: '#0a0a0a', gradient: { enabled:true, color1:'#1a1008', color2:'#2a1a10', color3:'#1a1008', angle:135, animated:false, speed:0 } },
    shadow: 0.6, lut: 'warmVintage', overlays: ['filmGrain', 'scanlines', 'vignette'],
    entrance: { type: 'fadeIn', duration: 1200 }, animPreset: 'none',
    particles: { enabled:true, type:'bokeh', count:8, color:'#fbbf2440', speed:0.1 },
    orbit: { enabled:false },
    text: [],
  },
  laptopReview: {
    device: { type: 'macbookpro', color: 'spaceblack' },
    preset: 'youtube', scale: 0.55,
    bg: { type: 'gradient', color: '#0a0a0a', gradient: { enabled:true, color1:'#0c4a6e', color2:'#155e75', color3:'#164e63', angle:180, animated:true, speed:0.4 } },
    shadow: 0.6, lut: 'cinematic', overlays: ['vignette'],
    entrance: { type: 'scaleIn', duration: 1000 }, animPreset: 'none',
    particles: { enabled:true, type:'bokeh', count:12, color:'#22d3ee', speed:0.2 },
    orbit: { enabled:true, speed:0.1, range:5 },
    text: [],
  },
  rawVideo: {
    device: { type: 'none', color: 'default' },
    preset: 'reels', scale: 0.45,
    bg: { type: 'solid', color: '#000000', gradient: { enabled:false } },
    shadow: 0, lut: null, overlays: [],
    entrance: { type: 'none', duration: 1000 }, animPreset: 'none',
    particles: { enabled:false }, orbit: { enabled:false },
    text: [],
  },
  ipadPresent: {
    device: { type: 'ipadpro', color: 'spaceblack' },
    preset: 'reels', scale: 0.50,
    bg: { type: 'solid', color: '#f5f5f5', gradient: { enabled:false } },
    shadow: 0.4, lut: null, overlays: [],
    entrance: { type: 'fadeIn', duration: 800 }, animPreset: 'none',
    particles: { enabled:false }, orbit: { enabled:false },
    text: [],
  },
};

function applyFullPreset(key) {
  const fp = FULL_PRESETS[key];
  if (!fp) return;

  // --- Reset everything first ---
  // Reset render stack to default order
  state.renderStack = [
    { id: 'bgVideo', name: 'BG Video', icon: 'üé¨' },
    { id: 'particles', name: 'Particles', icon: '‚ú®' },
    { id: 'device', name: 'Device', icon: 'üì±' },
    { id: 'device2', name: 'Device 2', icon: 'üì≤' },
    { id: 'content', name: 'Content', icon: 'T' },
    { id: 'facecam', name: 'Facecam', icon: 'üì∑' },
    { id: 'videoOverlays', name: 'Overlays', icon: 'üéû' },
    { id: 'uiOverlays', name: 'UI Effects', icon: 'üìä' },
  ];
  // Clear layers (text only - keep user's logos/annotations)
  state.layers = state.layers.filter(l => l.type !== 'text');
  // Clear video overlays (built-in only)
  state.videoOverlays = state.videoOverlays.filter(ov => !ov.builtin);
  document.querySelectorAll('#builtinOverlayGrid .dev-btn').forEach(b => b.classList.remove('active'));
  // Reset LUT
  state.lut = { enabled: false, data: null, size: 0, intensity: 1.0, name: '' };

  // --- Apply device ---
  state.device.type = fp.device.type;
  state.device.color = fp.device.color;
  state.device.scale = fp.scale;
  frameCache = {};
  // Update device grid UI
  document.querySelectorAll('#deviceGrid .dev-btn').forEach(b => {
    b.classList.toggle('active', b.dataset.device === fp.device.type);
  });
  updateColorSwatches();

  // --- Apply export preset ---
  state.preset = fp.preset;
  document.getElementById('presetSelect').value = fp.preset;
  document.getElementById('customSizeWrap').style.display = fp.preset === 'custom' ? '' : 'none';

  // --- Apply background ---
  state.bgType = fp.bg.type;
  state.background.color = fp.bg.color;
  document.getElementById('bgType').value = fp.bg.type;
  document.getElementById('bgColor').value = fp.bg.color;
  document.getElementById('bgSolidControls').style.display = fp.bg.type === 'solid' ? 'block' : 'none';
  document.getElementById('bgGradientControls').style.display = fp.bg.type === 'gradient' ? 'block' : 'none';
  canvasWrap.classList.remove('checker-bg');

  if (fp.bg.gradient) {
    Object.assign(state.gradient, fp.bg.gradient);
    if (fp.bg.gradient.color1) document.getElementById('gradColor1').value = fp.bg.gradient.color1;
    if (fp.bg.gradient.color2) document.getElementById('gradColor2').value = fp.bg.gradient.color2;
    if (fp.bg.gradient.color3) document.getElementById('gradColor3').value = fp.bg.gradient.color3;
  }

  // --- Apply shadow ---
  state.shadow = fp.shadow;
  document.getElementById('shadowSlider').value = Math.round(fp.shadow * 100);

  // --- Apply scale + transform ---
  state.device.scale = fp.scale;
  document.getElementById('scaleSlider').value = Math.round(fp.scale * 100);
  document.getElementById('scaleVal').textContent = Math.round(fp.scale * 100) + '%';
  state.perspective = { x: 0, y: 0 };
  document.getElementById('tiltX').value = 0;
  document.getElementById('tiltY').value = 0;

  // --- Apply LUT ---
  if (fp.lut) {
    const lutData = generateLUTPreset(fp.lut);
    state.lut = { enabled: true, data: lutData, size: lutData.size, intensity: 1.0, name: fp.lut };
    document.getElementById('lutInfo').innerHTML = '<span style="color:#4ade80">Active:</span> ' + fp.lut;
    document.getElementById('lutControls').style.display = 'block';
    document.querySelectorAll('#lutPresetGrid .dev-btn').forEach(b => {
      b.classList.toggle('active', b.dataset.lutPreset === fp.lut);
    });
  } else {
    document.getElementById('lutInfo').textContent = '';
    document.getElementById('lutControls').style.display = 'none';
    document.querySelectorAll('#lutPresetGrid .dev-btn').forEach(b => b.classList.remove('active'));
  }

  // --- Apply built-in overlays ---
  for (const ovType of (fp.overlays || [])) {
    const existing = state.videoOverlays.find(ov => ov.builtin === ovType);
    if (!existing) {
      state.videoOverlays.push({ id: Date.now() + Math.random(), builtin: ovType, name: ovType, opacity: 0.5, blendMode: 'screen' });
    }
    const btn = document.querySelector(`#builtinOverlayGrid .dev-btn[data-builtin="${ovType}"]`);
    if (btn) btn.classList.add('active');
  }
  rebuildOverlayList();

  // --- Apply entrance ---
  state.entrance = { type: fp.entrance.type, duration: fp.entrance.duration };
  document.getElementById('entranceSelect').value = fp.entrance.type;
  document.getElementById('entranceDur').value = fp.entrance.duration;
  document.getElementById('entranceDurVal').textContent = (fp.entrance.duration / 1000).toFixed(1) + 's';

  // --- Apply animation preset ---
  state.animPreset.type = fp.animPreset;
  document.querySelectorAll('#animPresetGrid .dev-btn').forEach(b => {
    b.classList.toggle('active', b.dataset.anim === fp.animPreset);
  });

  // --- Apply particles ---
  if (fp.particles) {
    Object.assign(state.particles, fp.particles);
    document.getElementById('particleType').value = fp.particles.enabled ? fp.particles.type : 'off';
    state._particles = [];
  }

  // --- Apply orbit ---
  if (fp.orbit) {
    Object.assign(state.orbit, fp.orbit);
    document.getElementById('orbitToggle').value = String(fp.orbit.enabled);
  }

  // --- Add text placeholders ---
  const sz = getCanvasSize();
  for (const t of (fp.text || [])) {
    state.layers.push({
      id: state.nextLayerId++, type: 'text',
      content: t.content, x: sz.w / 2, y: sz.h * (t.yPct || 0.08),
      fontSize: t.fontSize, fontFamily: t.fontFamily || 'SF Pro Display, -apple-system, sans-serif',
      color: t.color, weight: t.weight, align: 'center',
      shadow: 0, outline: 0,
    });
  }

  // --- Update UI state ---
  resizeCanvas();
  updatePerspective();
  updateDisplaySize();

  // Update full preset grid
  document.querySelectorAll('#fullPresetGrid .preset-card').forEach(b => {
    b.classList.toggle('active', b.dataset.fp === key);
  });

  // Reset scene grid (full presets supersede scene templates)
  document.querySelectorAll('#sceneGrid .dev-btn').forEach(b => b.classList.remove('active'));
  document.querySelector('#sceneGrid .dev-btn[data-scene="custom"]').classList.add('active');
}

const SCENES = {
  custom: null,
  floating: {
    gradient: { enabled:true, color1:'#0f0c29', color2:'#302b63', color3:'#24243e', angle:135, animated:true, speed:0.5 },
    particles: { enabled:true, type:'bokeh', count:25, color:'#8b5cf6', speed:0.3 },
    shadow:0.8, orbit:{ enabled:true, speed:0.2, range:8 },
  },
  neon: {
    gradient: { enabled:true, color1:'#0a0015', color2:'#1a0030', color3:'#0a0015', angle:180, animated:true, speed:0.8 },
    particles: { enabled:true, type:'sparkle', count:20, color:'#c084fc', speed:0.4 },
    shadow:1.0, orbit:{ enabled:false },
  },
  sunset: {
    gradient: { enabled:true, color1:'#f97316', color2:'#db2777', color3:'#7c3aed', angle:160, animated:true, speed:0.3 },
    particles: { enabled:true, type:'bokeh', count:15, color:'#fbbf24', speed:0.2 },
    shadow:0.5, orbit:{ enabled:false },
  },
  minimal: { gradient:{ enabled:false }, bg:'#f5f5f5', particles:{ enabled:false }, shadow:0.3, orbit:{ enabled:false } },
  ocean: {
    gradient: { enabled:true, color1:'#0c4a6e', color2:'#155e75', color3:'#164e63', angle:180, animated:true, speed:0.4 },
    particles: { enabled:true, type:'bokeh', count:20, color:'#22d3ee', speed:0.3 },
    shadow:0.6, orbit:{ enabled:true, speed:0.15, range:5 },
  },
  forest: {
    gradient: { enabled:true, color1:'#052e16', color2:'#14532d', color3:'#1a2e05', angle:170, animated:true, speed:0.3 },
    particles: { enabled:true, type:'snow', count:15, color:'#86efac', speed:0.2 },
    shadow:0.5, orbit:{ enabled:false },
  },
  cinematic: {
    gradient: { enabled:true, color1:'#000000', color2:'#1a1a2e', color3:'#000000', angle:90, animated:false, speed:0 },
    particles: { enabled:true, type:'bokeh', count:10, color:'#fbbf24', speed:0.15 },
    shadow:1.0, orbit:{ enabled:true, speed:0.1, range:4 }, motionBlur:true,
  },
};
function applyScene(name) {
  state.scene = name;
  const scene = SCENES[name];
  if (!scene) return;
  // Always remove transparent mode when applying a scene
  canvasWrap.classList.remove('checker-bg');
  if (scene.gradient) {
    Object.assign(state.gradient, scene.gradient);
    state.bgType = scene.gradient.enabled ? 'gradient' : 'solid';
    document.getElementById('bgType').value = state.bgType;
    document.getElementById('bgSolidControls').style.display = scene.gradient.enabled ? 'none' : 'block';
    document.getElementById('bgGradientControls').style.display = scene.gradient.enabled ? 'block' : 'none';
    if (scene.gradient.enabled) {
      document.getElementById('gradColor1').value = scene.gradient.color1;
      document.getElementById('gradColor2').value = scene.gradient.color2;
      document.getElementById('gradColor3').value = scene.gradient.color3;
    }
  }
  if (scene.bg) { state.background.color = scene.bg; document.getElementById('bgColor').value = scene.bg; }
  if (scene.particles) {
    Object.assign(state.particles, scene.particles);
    document.getElementById('particleType').value = scene.particles.enabled ? scene.particles.type : 'off';
    state._particles = [];
  }
  if (scene.shadow !== undefined) { state.shadow = scene.shadow; document.getElementById('shadowSlider').value = scene.shadow*100; }
  if (scene.orbit) { Object.assign(state.orbit, scene.orbit); document.getElementById('orbitToggle').value = String(scene.orbit.enabled); }
  if (scene.motionBlur !== undefined) { state.motionBlur.enabled = scene.motionBlur; document.getElementById('motionBlurToggle').value = String(scene.motionBlur); }
}

// ============================================================
// ENTRANCE ANIMATION
// ============================================================
function getEntranceTransform(elapsed) {
  const e = state.entrance;
  if (e.type === 'none') return { opacity: 1, x: 0, y: 0, scale: 1, rotate: 0 };
  const t = Math.min(1, elapsed / e.duration);
  const ease = t < 0.5 ? 2*t*t : 1 - Math.pow(-2*t + 2, 2)/2; // ease in-out quad

  switch (e.type) {
    case 'fadeIn':
      return { opacity: ease, x: 0, y: 0, scale: 1, rotate: 0 };
    case 'slideUp':
      return { opacity: ease, x: 0, y: (1 - ease) * 300, scale: 1, rotate: 0 };
    case 'scaleIn':
      return { opacity: ease, x: 0, y: 0, scale: 0.3 + ease * 0.7, rotate: 0 };
    case 'rotateIn':
      return { opacity: ease, x: 0, y: 0, scale: 0.5 + ease * 0.5, rotate: (1 - ease) * -15 };
    default:
      return { opacity: 1, x: 0, y: 0, scale: 1, rotate: 0 };
  }
}

// ============================================================
// KEYFRAME INTERPOLATION
// ============================================================
function getKeyframeValues(time) {
  const kfs = state.timeline.keyframes;
  if (kfs.length === 0) return { zoom: 1, panX: 0, panY: 0 };
  if (kfs.length === 1) return { zoom: kfs[0].zoom, panX: kfs[0].panX, panY: kfs[0].panY };

  // Find surrounding keyframes
  let before = kfs[0], after = kfs[kfs.length - 1];
  for (let i = 0; i < kfs.length - 1; i++) {
    if (time >= kfs[i].time && time <= kfs[i+1].time) {
      before = kfs[i];
      after = kfs[i+1];
      break;
    }
  }
  if (time <= before.time) return { zoom: before.zoom, panX: before.panX, panY: before.panY };
  if (time >= after.time) return { zoom: after.zoom, panX: after.panX, panY: after.panY };

  const t = (time - before.time) / (after.time - before.time);
  const ease = t < 0.5 ? 2*t*t : 1 - Math.pow(-2*t+2, 2)/2;
  return {
    zoom: before.zoom + (after.zoom - before.zoom) * ease,
    panX: before.panX + (after.panX - before.panX) * ease,
    panY: before.panY + (after.panY - before.panY) * ease,
  };
}

// ============================================================
// RENDER LAYER FUNCTIONS (stack-based)
// ============================================================

function renderBackground(ctx, CW, CH) {
  if (state.bgType === 'transparent') return;
  if (state.gradient.enabled) {
    drawGradientBG(ctx, CW, CH);
  } else {
    ctx.fillStyle = state.background.color;
    ctx.fillRect(0, 0, CW, CH);
  }
}

function calcDevicePosition(CW, CH) {
  const dev = DEVICES[state.device.type];
  let devW = dev.baseW, devH = dev.baseH;
  if (state.device.landscape) { let t = devW; devW = devH; devH = t; }
  const preset = PRESETS[state.preset];
  let devScale, devX, devY;
  const isComparing = state.comparison.enabled && state.comparison.device2;
  if (!preset) {
    devScale = RENDER_SCALE;
    devX = 0; devY = 0;
  } else {
    const padFrac = 0.12;
    const areaW = isComparing ? CW * 0.45 : CW;
    const availW = areaW * (1 - padFrac*2);
    const availH = CH * (1 - padFrac*2);
    const fitScale = Math.min(availW / devW, availH / devH);
    devScale = fitScale * state.device.scale;
    if (isComparing) {
      devX = CW * 0.25 - (devW * devScale) / 2;
    } else {
      devX = (CW - devW * devScale) / 2;
    }
    devY = (CH - devH * devScale) / 2;
  }
  return { dev, devW, devH, devScale, devX, devY, isComparing };
}

function calcSceneTransform() {
  const elapsed = hasVideo ? (video.currentTime * 1000) : 0;
  const ent = getEntranceTransform(elapsed);
  const kf = getKeyframeValues(hasVideo ? video.currentTime : 0);
  const animT = getAnimPresetTransform(hasVideo ? video.currentTime : performance.now() * 0.001);
  return { ent, kf, animT };
}

function applySceneTransform(ctx, CW, CH, t) {
  const combinedZoom = t.kf.zoom * t.animT.zoom;
  const combinedPanX = t.kf.panX + t.animT.panX;
  const combinedPanY = t.kf.panY + t.animT.panY;
  ctx.translate(CW/2, CH/2);
  ctx.scale(combinedZoom, combinedZoom);
  ctx.rotate(t.animT.rotation * Math.PI / 180);
  ctx.translate(-CW/2 + combinedPanX, -CH/2 + combinedPanY);
  ctx.globalAlpha = t.ent.opacity;
  ctx.translate(CW/2, CH/2);
  ctx.translate(t.ent.x, t.ent.y);
  ctx.scale(t.ent.scale, t.ent.scale);
  ctx.rotate(t.ent.rotate * Math.PI/180);
  ctx.translate(-CW/2, -CH/2);
}

function renderBgVideoLayer(ctx, CW, CH) {
  if (!state.bgVideo.enabled) return;
  const bgVid = document.getElementById('bgVideo');
  if (!bgVid || bgVid.readyState < 2) return;
  ctx.save();
  ctx.globalAlpha = state.bgVideo.opacity;
  const vw = bgVid.videoWidth, vh = bgVid.videoHeight;
  let dx = 0, dy = 0, dw = CW, dh = CH;
  if (state.bgVideo.fit === 'cover') {
    const cRatio = CW / CH, vRatio = vw / vh;
    if (vRatio > cRatio) { dh = CH; dw = CH * vRatio; dx = (CW - dw) / 2; }
    else { dw = CW; dh = CW / vRatio; dy = (CH - dh) / 2; }
  } else if (state.bgVideo.fit === 'contain') {
    const cRatio = CW / CH, vRatio = vw / vh;
    if (vRatio > cRatio) { dw = CW; dh = CW / vRatio; dy = (CH - dh) / 2; }
    else { dh = CH; dw = CH * vRatio; dx = (CW - dw) / 2; }
  }
  ctx.drawImage(bgVid, dx, dy, dw, dh);
  ctx.restore();
}

function renderParticlesLayer(ctx, CW, CH) {
  if (state.particles.enabled) drawParticles(ctx, CW, CH);
}

function renderDeviceLayer(ctx, CW, CH, dc) {
  // No-device mode: render video full-bleed
  if (state.device.type === 'none') {
    if (hasVideo && video.readyState >= 2) {
      const chromaFrame = getChromaKeyFrame(video);
      const vidSrc = chromaFrame || video;
      const vw = chromaFrame ? chromaFrame.width : video.videoWidth;
      const vh = chromaFrame ? chromaFrame.height : video.videoHeight;
      const cRatio = CW / CH, vRatio = vw / vh;
      let dw, dh, dx, dy;
      if (state.videoFit === 'stretch') {
        dx = 0; dy = 0; dw = CW; dh = CH;
      } else if (state.videoFit === 'contain') {
        if (vRatio > cRatio) { dw = CW; dh = CW / vRatio; dx = 0; dy = (CH - dh) / 2; }
        else { dh = CH; dw = CH * vRatio; dx = (CW - dw) / 2; dy = 0; }
      } else {
        if (vRatio > cRatio) { dh = CH; dw = CH * vRatio; dx = (CW - dw) / 2; dy = 0; }
        else { dw = CW; dh = CW / vRatio; dx = 0; dy = (CH - dh) / 2; }
      }
      ctx.drawImage(vidSrc, dx, dy, dw, dh);
    }
    return;
  }

  const { dev, devW, devH, devScale, devX, devY } = dc;

  // Hand overlay (behind device)
  if (state.hand.enabled) {
    drawHandOverlay(ctx, dev, devScale, state.hand.style, devX, devY);
  }

  // Drop shadow
  if (state.shadow > 0) {
    ctx.save();
    ctx.shadowColor = 'rgba(0,0,0,' + (0.55 * state.shadow) + ')';
    ctx.shadowBlur = 70 * (devScale/RENDER_SCALE) * state.shadow;
    ctx.shadowOffsetY = 18 * (devScale/RENDER_SCALE) * state.shadow;
    ctx.translate(devX, devY);
    if (state.device.landscape) {
      ctx.translate(devW*devScale/2, devH*devScale/2);
      ctx.rotate(-Math.PI/2);
      ctx.translate(-dev.baseW*devScale/2, -dev.baseH*devScale/2);
    }
    rrPath(ctx, 3*(devScale/RENDER_SCALE), 3*(devScale/RENDER_SCALE),
      (dev.baseW-6)*devScale, (dev.baseH-6)*devScale, (dev.cornerR-3)*devScale);
    ctx.fillStyle = '#000'; ctx.fill();
    ctx.restore();
  }

  // Draw video into screen
  ctx.save();
  ctx.translate(devX, devY);
  if (state.device.landscape) {
    ctx.translate(devW*devScale/2, devH*devScale/2);
    ctx.rotate(-Math.PI/2);
    ctx.translate(-dev.baseW*devScale/2, -dev.baseH*devScale/2);
  }

  if (hasVideo && video.readyState >= 2) {
    ctx.save();
    rrPath(ctx, dev.screenX*devScale, dev.screenY*devScale, dev.screenW*devScale, dev.screenH*devScale, dev.screenR*devScale);
    ctx.clip();
    const sw = dev.screenW * devScale, sh = dev.screenH * devScale;
    const chromaFrame = getChromaKeyFrame(video);
    const vidSrc = chromaFrame || video;
    const vw = chromaFrame ? chromaFrame.width : video.videoWidth;
    const vh = chromaFrame ? chromaFrame.height : video.videoHeight;
    const sRatio = sw/sh, vRatio = vw/vh;
    let dw, dh, dx, dy;
    if (state.videoFit === 'stretch') {
      dx = dev.screenX*devScale; dy = dev.screenY*devScale; dw = sw; dh = sh;
    } else if (state.videoFit === 'contain') {
      if (vRatio > sRatio) { dw = sw; dh = sw/vRatio; dx = dev.screenX*devScale; dy = dev.screenY*devScale+(sh-dh)/2; }
      else { dh = sh; dw = sh*vRatio; dx = dev.screenX*devScale+(sw-dw)/2; dy = dev.screenY*devScale; }
    } else {
      if (vRatio > sRatio) { dh = sh; dw = sh*vRatio; dx = dev.screenX*devScale+(sw-dw)/2; dy = dev.screenY*devScale; }
      else { dw = sw; dh = sw/vRatio; dx = dev.screenX*devScale; dy = dev.screenY*devScale+(sh-dh)/2; }
    }
    ctx.drawImage(vidSrc, dx, dy, dw, dh);
    ctx.restore();
  } else {
    ctx.save();
    rrPath(ctx, dev.screenX*devScale, dev.screenY*devScale, dev.screenW*devScale, dev.screenH*devScale, dev.screenR*devScale);
    ctx.fillStyle = '#000'; ctx.fill();
    ctx.restore();
  }

  // Device frame
  const frame = getDeviceFrame(state.device.type, state.device.color);
  ctx.drawImage(frame, 0, 0, frame.width, frame.height, 0, 0, dev.baseW*devScale, dev.baseH*devScale);

  // Glass reflection
  if (hasVideo) {
    ctx.save();
    rrPath(ctx, dev.screenX*devScale, dev.screenY*devScale, dev.screenW*devScale, dev.screenH*devScale, dev.screenR*devScale);
    ctx.clip();
    const g = ctx.createLinearGradient(0, 0, dev.screenW*devScale*0.7, dev.screenH*devScale*0.4);
    g.addColorStop(0, 'rgba(255,255,255,0.025)');
    g.addColorStop(0.35, 'rgba(255,255,255,0)');
    ctx.fillStyle = g;
    ctx.fillRect(0, 0, dev.baseW*devScale, dev.baseH*devScale);
    ctx.restore();
  }

  ctx.restore(); // device translate
}

function renderDevice2Layer(ctx, CW, CH, dc) {
  if (!dc.isComparing) return;
  const dev2Id = state.comparison.device2.type;
  const dev2Color = state.comparison.device2.color;
  const dev2 = DEVICES[dev2Id];
  if (!dev2) return;

  let d2W = dev2.baseW, d2H = dev2.baseH;
  if (state.device.landscape) { let t = d2W; d2W = d2H; d2H = t; }
  const padFrac = 0.12;
  const areaW = CW * 0.45;
  const availW2 = areaW * (1 - padFrac*2);
  const availH2 = CH * (1 - padFrac*2);
  const fitScale2 = Math.min(availW2 / d2W, availH2 / d2H);
  const d2Scale = fitScale2 * state.device.scale;
  const d2X = CW * 0.75 - (d2W * d2Scale) / 2;
  const d2Y = (CH - d2H * d2Scale) / 2;

  // Shadow for device 2
  if (state.shadow > 0) {
    ctx.save();
    ctx.shadowColor = 'rgba(0,0,0,' + (0.55 * state.shadow) + ')';
    ctx.shadowBlur = 70 * (d2Scale/RENDER_SCALE) * state.shadow;
    ctx.shadowOffsetY = 18 * (d2Scale/RENDER_SCALE) * state.shadow;
    ctx.translate(d2X, d2Y);
    rrPath(ctx, 3*(d2Scale/RENDER_SCALE), 3*(d2Scale/RENDER_SCALE),
      (dev2.baseW-6)*d2Scale, (dev2.baseH-6)*d2Scale, (dev2.cornerR-3)*d2Scale);
    ctx.fillStyle = '#000'; ctx.fill();
    ctx.restore();
  }

  ctx.save();
  ctx.translate(d2X, d2Y);
  if (state.device.landscape) {
    ctx.translate(d2W*d2Scale/2, d2H*d2Scale/2);
    ctx.rotate(-Math.PI/2);
    ctx.translate(-dev2.baseW*d2Scale/2, -dev2.baseH*d2Scale/2);
  }

  // Black screen for device 2
  ctx.save();
  rrPath(ctx, dev2.screenX*d2Scale, dev2.screenY*d2Scale, dev2.screenW*d2Scale, dev2.screenH*d2Scale, dev2.screenR*d2Scale);
  ctx.fillStyle = '#000'; ctx.fill();
  ctx.restore();

  // Draw device 2 video if available
  const vid2 = document.getElementById('srcVideo2');
  if (vid2 && vid2.readyState >= 2 && vid2.src) {
    ctx.save();
    rrPath(ctx, dev2.screenX*d2Scale, dev2.screenY*d2Scale, dev2.screenW*d2Scale, dev2.screenH*d2Scale, dev2.screenR*d2Scale);
    ctx.clip();
    const sw2 = dev2.screenW*d2Scale, sh2 = dev2.screenH*d2Scale;
    const chromaFrame2 = getChromaKeyFrame(vid2);
    const vid2Src = chromaFrame2 || vid2;
    const vw2 = chromaFrame2 ? chromaFrame2.width : vid2.videoWidth;
    const vh2 = chromaFrame2 ? chromaFrame2.height : vid2.videoHeight;
    const sR2 = sw2/sh2, vR2 = vw2/vh2;
    let dw2, dh2, dx2, dy2;
    if (state.videoFit === 'stretch') {
      dx2 = dev2.screenX*d2Scale; dy2 = dev2.screenY*d2Scale; dw2 = sw2; dh2 = sh2;
    } else if (state.videoFit === 'contain') {
      if (vR2 > sR2) { dw2=sw2; dh2=sw2/vR2; dx2=dev2.screenX*d2Scale; dy2=dev2.screenY*d2Scale+(sh2-dh2)/2; }
      else { dh2=sh2; dw2=sh2*vR2; dx2=dev2.screenX*d2Scale+(sw2-dw2)/2; dy2=dev2.screenY*d2Scale; }
    } else {
      if (vR2 > sR2) { dh2=sh2; dw2=sh2*vR2; dx2=dev2.screenX*d2Scale+(sw2-dw2)/2; dy2=dev2.screenY*d2Scale; }
      else { dw2=sw2; dh2=sw2/vR2; dx2=dev2.screenX*d2Scale; dy2=dev2.screenY*d2Scale+(sh2-dh2)/2; }
    }
    ctx.drawImage(vid2Src, dx2, dy2, dw2, dh2);
    ctx.restore();
  }

  const frame2 = getDeviceFrame(dev2Id, dev2Color);
  ctx.drawImage(frame2, 0, 0, frame2.width, frame2.height, 0, 0, dev2.baseW*d2Scale, dev2.baseH*d2Scale);
  ctx.restore();
}

function renderContentLayer(ctx, CW, CH) {
  if (state.layers.length === 0) return;
  const currentTime = hasVideo ? video.currentTime : 0;
  for (const layer of state.layers) {
    if (layer.visible === false) continue; // hidden via unified layers panel
    if (layer.type === 'text') {
      ctx.save();
      if (layer.opacity !== undefined) ctx.globalAlpha = layer.opacity;
      ctx.font = layer.weight + ' ' + layer.fontSize + 'px ' + layer.fontFamily;
      ctx.fillStyle = layer.color;
      ctx.textAlign = layer.align || 'left';
      ctx.textBaseline = 'top';
      if (layer.shadow > 0) {
        ctx.shadowColor = 'rgba(0,0,0,0.5)';
        ctx.shadowBlur = layer.shadow;
        ctx.shadowOffsetX = 2; ctx.shadowOffsetY = 2;
      }
      if (layer.outline > 0) {
        ctx.strokeStyle = 'rgba(0,0,0,0.7)';
        ctx.lineWidth = layer.outline;
        ctx.strokeText(layer.content, layer.x, layer.y);
      }
      ctx.fillText(layer.content, layer.x, layer.y);
      ctx.restore();
    } else if (layer.type === 'logo' && layer.img) {
      ctx.save();
      ctx.globalAlpha = layer.opacity;
      const aspect = layer.img.naturalWidth / layer.img.naturalHeight;
      const lh = layer.width / aspect;
      ctx.drawImage(layer.img, layer.x, layer.y, layer.width, lh);
      ctx.restore();
    } else if (layer.type === 'annotation') {
      if (layer.startTime !== undefined && (currentTime < layer.startTime || currentTime > layer.endTime)) continue;
      ctx.save();
      ctx.strokeStyle = layer.color;
      ctx.fillStyle = layer.color;
      ctx.lineWidth = layer.lineWidth;
      ctx.lineCap = 'round';
      ctx.lineJoin = 'round';
      if (layer.annoType === 'arrow' && layer.points && layer.points.length >= 2) {
        const p = layer.points;
        ctx.beginPath();
        ctx.moveTo(p[0].x, p[0].y);
        ctx.lineTo(p[1].x, p[1].y);
        ctx.stroke();
        const angle = Math.atan2(p[1].y - p[0].y, p[1].x - p[0].x);
        const headLen = 15;
        ctx.beginPath();
        ctx.moveTo(p[1].x, p[1].y);
        ctx.lineTo(p[1].x - headLen*Math.cos(angle - 0.4), p[1].y - headLen*Math.sin(angle - 0.4));
        ctx.lineTo(p[1].x - headLen*Math.cos(angle + 0.4), p[1].y - headLen*Math.sin(angle + 0.4));
        ctx.closePath();
        ctx.fill();
      } else if (layer.annoType === 'circle' && layer.points && layer.points.length >= 2) {
        const cx = (layer.points[0].x + layer.points[1].x) / 2;
        const cy = (layer.points[0].y + layer.points[1].y) / 2;
        const rx = Math.abs(layer.points[1].x - layer.points[0].x) / 2;
        const ry = Math.abs(layer.points[1].y - layer.points[0].y) / 2;
        ctx.beginPath();
        ctx.ellipse(cx, cy, rx, ry, 0, 0, Math.PI*2);
        ctx.stroke();
      } else if (layer.annoType === 'rect' && layer.points && layer.points.length >= 2) {
        const rx = Math.min(layer.points[0].x, layer.points[1].x);
        const ry = Math.min(layer.points[0].y, layer.points[1].y);
        const rw = Math.abs(layer.points[1].x - layer.points[0].x);
        const rh = Math.abs(layer.points[1].y - layer.points[0].y);
        ctx.strokeRect(rx, ry, rw, rh);
      } else if (layer.annoType === 'freehand' && layer.points && layer.points.length > 1) {
        ctx.beginPath();
        ctx.moveTo(layer.points[0].x, layer.points[0].y);
        for (let i = 1; i < layer.points.length; i++) {
          ctx.lineTo(layer.points[i].x, layer.points[i].y);
        }
        ctx.stroke();
      } else if (layer.annoType === 'callout' && layer.points && layer.points.length >= 1) {
        const p = layer.points[0];
        ctx.fillStyle = 'rgba(0,0,0,0.7)';
        rrPath(ctx, p.x, p.y, 140, 40, 6);
        ctx.fill();
        ctx.fillStyle = layer.color;
        ctx.font = '14px -apple-system, sans-serif';
        ctx.textBaseline = 'middle';
        ctx.fillText(layer.content || 'Note', p.x + 10, p.y + 20);
      }
      ctx.restore();
    }
  }
}

function renderFacecamLayer(ctx, CW, CH) {
  if (!state.facecam.enabled || !state.facecam.stream) return;
  const fcVideo = document.getElementById('facecamVideo');
  if (!fcVideo || fcVideo.readyState < 2) return;

  const sz2 = Math.round(Math.min(CW, CH) * state.facecam.size);
  const margin = Math.round(Math.min(CW, CH) * 0.03);
  let fx, fy;
  if (state.facecam.x >= 0 && state.facecam.y >= 0) {
    fx = state.facecam.x; fy = state.facecam.y;
  } else {
    switch (state.facecam.corner) {
      case 'TL': fx = margin; fy = margin; break;
      case 'TR': fx = CW - sz2 - margin; fy = margin; break;
      case 'BL': fx = margin; fy = CH - sz2 - margin; break;
      case 'custom': fx = state.facecam.x >= 0 ? state.facecam.x : CW/2 - sz2/2; fy = state.facecam.y >= 0 ? state.facecam.y : CH/2 - sz2/2; break;
      default:   fx = CW - sz2 - margin; fy = CH - sz2 - margin;
    }
    state.facecam.x = fx; state.facecam.y = fy;
  }
  // Drop shadow
  if (state.facecam.shadow) {
    ctx.save();
    ctx.shadowColor = 'rgba(0,0,0,0.5)';
    ctx.shadowBlur = sz2 * 0.15;
    ctx.shadowOffsetX = 0;
    ctx.shadowOffsetY = sz2 * 0.04;
    ctx.fillStyle = 'rgba(0,0,0,0.01)';
    if (state.facecam.shape === 'circle') {
      ctx.beginPath(); ctx.arc(fx+sz2/2, fy+sz2/2, sz2/2, 0, Math.PI*2); ctx.fill();
    } else if (state.facecam.shape === 'roundrect') {
      rrPath(ctx, fx, fy, sz2, sz2, sz2*0.2); ctx.fill();
    } else {
      ctx.fillRect(fx, fy, sz2, sz2);
    }
    ctx.restore();
  }
  // Clip to shape and draw video
  ctx.save();
  if (state.facecam.shape === 'circle') {
    ctx.beginPath(); ctx.arc(fx+sz2/2, fy+sz2/2, sz2/2, 0, Math.PI*2); ctx.clip();
  } else if (state.facecam.shape === 'roundrect') {
    rrPath(ctx, fx, fy, sz2, sz2, sz2*0.2); ctx.clip();
  } else {
    ctx.beginPath(); ctx.rect(fx, fy, sz2, sz2); ctx.clip();
  }
  const vw = fcVideo.videoWidth, vh = fcVideo.videoHeight;
  const vAspect = vw/vh;
  let dw, dh, dx, dy;
  if (vAspect > 1) { dh = sz2; dw = sz2*vAspect; dx = fx-(dw-sz2)/2; dy = fy; }
  else { dw = sz2; dh = sz2/vAspect; dx = fx; dy = fy-(dh-sz2)/2; }
  ctx.drawImage(fcVideo, dx, dy, dw, dh);
  ctx.restore();
  // Border
  if (state.facecam.borderWidth > 0) {
    ctx.save();
    ctx.strokeStyle = state.facecam.borderColor;
    ctx.lineWidth = state.facecam.borderWidth;
    if (state.facecam.shape === 'circle') {
      ctx.beginPath(); ctx.arc(fx+sz2/2, fy+sz2/2, sz2/2 - state.facecam.borderWidth/2, 0, Math.PI*2); ctx.stroke();
    } else if (state.facecam.shape === 'roundrect') {
      const bw = state.facecam.borderWidth/2;
      rrPath(ctx, fx+bw, fy+bw, sz2-state.facecam.borderWidth, sz2-state.facecam.borderWidth, sz2*0.2); ctx.stroke();
    } else {
      ctx.strokeRect(fx+state.facecam.borderWidth/2, fy+state.facecam.borderWidth/2, sz2-state.facecam.borderWidth, sz2-state.facecam.borderWidth);
    }
    ctx.restore();
  }
}

function renderVideoOverlaysLayer(ctx, CW, CH) {
  if (state.videoOverlays.length > 0) drawVideoOverlays(ctx, CW, CH);
}

function renderUiOverlaysLayer(ctx, CW, CH) {
  if (state.waveform.enabled && hasVideo) drawWaveform(ctx, CW, CH);
  if (state.progressBar.enabled && hasVideo) drawProgressBar(ctx, CW, CH);
  if (state.glassmorphism.enabled) drawGlassmorphism(ctx, CW, CH);
}

function renderPostProcessing(ctx, CW, CH) {
  if (state.motionBlur.enabled) {
    ctx.save();
    ctx.globalAlpha = state.motionBlur.amount;
    ctx.globalCompositeOperation = 'source-atop';
    ctx.filter = 'blur(3px)';
    ctx.drawImage(canvas, 0, 0);
    ctx.restore();
  }
  drawGlitchEffect(ctx, CW, CH, hasVideo ? video.currentTime : performance.now() * 0.001);
  if (state.lut.enabled && state.lut.data) applyLUT(canvas, state.lut, state.lut.intensity);
}

// Groups that receive scene transforms (entrance, keyframe, animation)
const SCENE_GROUPS = new Set(['device', 'device2', 'content']);

// Render dispatch map
const RENDER_MAP = {
  bgVideo: renderBgVideoLayer,
  particles: renderParticlesLayer,
  device: renderDeviceLayer,
  device2: renderDevice2Layer,
  content: renderContentLayer,
  facecam: renderFacecamLayer,
  videoOverlays: renderVideoOverlaysLayer,
  uiOverlays: renderUiOverlaysLayer,
};

// ============================================================
// MAIN RENDER (stack-based)
// ============================================================
function render() {
  const sz = getCanvasSize();
  const CW = sz.w, CH = sz.h;
  ctx.clearRect(0, 0, CW, CH);

  // Background (always first, not in stack)
  renderBackground(ctx, CW, CH);

  // Calculate device positioning
  const dc = calcDevicePosition(CW, CH);

  // Calculate scene transforms
  const sceneT = calcSceneTransform();

  // Iterate render stack in order (skip hidden groups)
  for (const group of state.renderStack) {
    if (group.hidden) continue;
    const fn = RENDER_MAP[group.id];
    if (!fn) continue;

    if (SCENE_GROUPS.has(group.id)) {
      // Scene groups get entrance/keyframe/animation transforms
      ctx.save();
      applySceneTransform(ctx, CW, CH, sceneT);
      fn(ctx, CW, CH, dc);
      ctx.restore();
    } else {
      fn(ctx, CW, CH, dc);
    }
  }

  // Post-processing (always last, not in stack)
  renderPostProcessing(ctx, CW, CH);

  requestAnimationFrame(render);
}

// ============================================================
// CANVAS DISPLAY SIZE
// ============================================================
function updateDisplaySize() {
  const sz = getCanvasSize();
  const pct = parseInt(scaleSlider.value) / 100;
  const stage = document.getElementById('stage');
  const maxH = stage.clientHeight - 20;
  const maxW = stage.clientWidth - 20;
  let h = maxH * pct;
  let w = h * (sz.w / sz.h);
  if (w > maxW * pct) { w = maxW * pct; h = w * (sz.h / sz.w); }
  canvas.style.width = w + 'px';
  canvas.style.height = h + 'px';
  scaleVal.textContent = scaleSlider.value + '%';
}

// ============================================================
// 3D PERSPECTIVE
// ============================================================
function updatePerspective() {
  const rx = parseInt(tiltXSlider.value);
  const ry = parseInt(tiltYSlider.value);
  const orbitY = getOrbitAngle();
  const totalRx = rx;
  const totalRy = ry + orbitY;
  if (totalRx === 0 && totalRy === 0 && !state.orbit.enabled) {
    canvasWrap.style.transform = '';
  } else {
    canvasWrap.style.transform = `perspective(1200px) rotateX(${totalRx}deg) rotateY(${totalRy}deg)`;
  }
  state.perspective.x = rx;
  state.perspective.y = ry;
}
// Orbit animation loop
function orbitLoop() {
  if (state.orbit.enabled) updatePerspective();
  requestAnimationFrame(orbitLoop);
}
orbitLoop();

// ============================================================
// INIT
// ============================================================
resizeCanvas();
requestAnimationFrame(render);

window.addEventListener('resize', () => { updateDisplaySize(); });
scaleSlider.addEventListener('input', () => { state.device.scale = parseInt(scaleSlider.value) / 100; updateDisplaySize(); frameCache = {}; });
document.getElementById('videoFitMode').addEventListener('change', e => { state.videoFit = e.target.value; scheduleSave(); });
bgColorInput.addEventListener('input', e => { state.background.color = e.target.value; });
shadowSlider.addEventListener('input', e => { state.shadow = parseInt(e.target.value) / 100; });
tiltXSlider.addEventListener('input', updatePerspective);
tiltYSlider.addEventListener('input', updatePerspective);

// ============================================================
// DEVICE SELECTION
// ============================================================
function updateColorSwatches() {
  const dev = DEVICES[state.device.type];
  const container = document.getElementById('colorSwatches');
  container.innerHTML = '';
  if (state.device.type === 'none') return; // No swatches for no-device mode
  for (const [key, pal] of Object.entries(dev.colors)) {
    const s = document.createElement('div');
    s.className = 'color-swatch' + (key === state.device.color ? ' active' : '');
    s.style.background = pal.body;
    s.title = pal.label;
    s.dataset.color = key;
    s.addEventListener('click', () => {
      pushUndoState();
      state.device.color = key;
      frameCache = {};
      document.querySelectorAll('.color-swatch').forEach(x => x.classList.remove('active'));
      s.classList.add('active');
    });
    container.appendChild(s);
  }
}

deviceGrid.addEventListener('click', e => {
  const btn = e.target.closest('.dev-btn');
  if (!btn) return;
  pushUndoState();
  const devId = btn.dataset.device;
  state.device.type = devId;
  state.device.color = DEVICES[devId].defaultColor;
  frameCache = {};
  deviceGrid.querySelectorAll('.dev-btn').forEach(x => x.classList.remove('active'));
  btn.classList.add('active');
  updateColorSwatches();
  // Hide/show device-specific toggles
  const toggles = document.getElementById('deviceToggles');
  if (toggles) toggles.style.display = devId === 'none' ? 'none' : 'flex';
  // Clear full preset active state (user is customizing)
  document.querySelectorAll('#fullPresetGrid .preset-card').forEach(b => b.classList.remove('active'));
  resizeCanvas();
});

updateColorSwatches();

// ============================================================
// FULL PRESET TEMPLATE CONTROLS
// ============================================================
document.getElementById('fullPresetGrid').addEventListener('click', e => {
  const card = e.target.closest('.preset-card');
  if (!card) return;
  pushUndoState();
  const key = card.dataset.fp;
  applyFullPreset(key);
  const name = card.querySelector('.pc-name');
  showToast('Preset: ' + (name ? name.textContent : key) + ' applied', 'info');
});

document.getElementById('resetFullPresetBtn').addEventListener('click', () => {
  document.querySelectorAll('#fullPresetGrid .preset-card').forEach(b => b.classList.remove('active'));
});

// Device section collapse toggle
document.getElementById('deviceCollapseBtn').addEventListener('click', () => {
  const section = document.getElementById('deviceSection');
  const btn = document.getElementById('deviceCollapseBtn');
  const content = document.getElementById('deviceContent');
  const isCollapsed = content.style.display === 'none';
  content.style.display = isCollapsed ? '' : 'none';
  btn.textContent = isCollapsed ? '‚ñº' : '‚ñ∂';
});

// Landscape toggle
document.getElementById('landscapeBtn').addEventListener('click', function() {
  state.device.landscape = !state.device.landscape;
  this.classList.toggle('active', state.device.landscape);
  resizeCanvas();
});

// ============================================================
// PRESET SELECTION
// ============================================================
presetSelect.addEventListener('change', e => {
  // No device + device-only doesn't make sense ‚Äî force to reels
  if (e.target.value === 'device' && state.device.type === 'none') {
    e.target.value = 'reels';
  }
  state.preset = e.target.value;
  customSizeWrap.style.display = e.target.value === 'custom' ? 'inline' : 'none';
  if (e.target.value === 'custom') {
    PRESETS.custom = { w: parseInt(customW.value), h: parseInt(customH.value) };
  }
  resizeCanvas();
});
customW.addEventListener('change', () => { PRESETS.custom.w = parseInt(customW.value); resizeCanvas(); });
customH.addEventListener('change', () => { PRESETS.custom.h = parseInt(customH.value); resizeCanvas(); });

// ============================================================
// VIDEO LOADING
// ============================================================
function loadVideo(file) {
  const url = URL.createObjectURL(file);
  video.src = url;
  video.loop = isLooping;
  video.muted = false;
  video.load();
  video.play().catch(() => { video.muted = true; video.play(); });
  hasVideo = true;
  promptEl.classList.remove('visible');
  playbackBar.classList.add('visible');
  timelineBar.classList.add('visible');
  playbackStartTime = performance.now();
  const fnEl = document.getElementById('videoFileName');
  fnEl.textContent = file.name.length > 30 ? file.name.slice(0, 27) + '...' : file.name;
  fnEl.title = file.name;
  state.timeline.trimIn = 0;
  state.timeline.trimOut = 1;
  // Add clip to timeline
  state.timeline.clips = [{ video: video, name: file.name, start: 0, duration: 0 }];
  video.addEventListener('loadedmetadata', () => {
    state.timeline.clips[0].duration = video.duration;
    rebuildTimeline();
  }, { once: true });
  showToast('Video loaded: ' + file.name, 'success');
}

loadBtn.addEventListener('click', () => fileInput.click());
canvasWrap.addEventListener('click', () => { if (!hasVideo) fileInput.click(); });
fileInput.addEventListener('change', e => { if (e.target.files[0]) loadVideo(e.target.files[0]); });

// Drag & drop
let dragN = 0;
document.addEventListener('dragenter', e => { e.preventDefault(); dragN++; dropOverlay.classList.add('active'); });
document.addEventListener('dragleave', e => { e.preventDefault(); dragN--; if (dragN <= 0) { dragN = 0; dropOverlay.classList.remove('active'); } });
document.addEventListener('dragover', e => e.preventDefault());
document.addEventListener('drop', e => {
  e.preventDefault(); dragN = 0; dropOverlay.classList.remove('active');
  const f = e.dataTransfer.files[0];
  if (f && f.type.startsWith('video/')) loadVideo(f);
});

// ============================================================
// PLAYBACK
// ============================================================
playBtn.addEventListener('click', () => { video.paused ? video.play() : video.pause(); });
video.addEventListener('play', () => {
  iconPlay.style.display = 'none'; iconPause.style.display = 'block';
  state.videoOverlays.forEach(ov => { if (ov.video) ov.video.play(); });
  if (state.bgVideo.enabled) document.getElementById('bgVideo').play();
});
video.addEventListener('pause', () => {
  iconPlay.style.display = 'block'; iconPause.style.display = 'none';
  state.videoOverlays.forEach(ov => { if (ov.video) ov.video.pause(); });
  if (state.bgVideo.enabled) document.getElementById('bgVideo').pause();
});

video.addEventListener('timeupdate', () => {
  if (!video.duration) return;
  const trimIn = state.timeline.trimIn * video.duration;
  const trimOut = state.timeline.trimOut * video.duration;
  // Enforce trim bounds
  if (video.currentTime < trimIn) video.currentTime = trimIn;
  if (video.currentTime > trimOut) {
    if (isLooping) video.currentTime = trimIn;
    else video.pause();
  }
  progressFill.style.width = (video.currentTime / video.duration * 100) + '%';
  timeLabel.textContent = fmt(video.currentTime) + ' / ' + fmt(video.duration);
  updateTimelineScrubber();
});

function fmt(s) { return Math.floor(s/60) + ':' + String(Math.floor(s%60)).padStart(2, '0'); }

// Progress bar scrubbing
const progressTooltip = document.getElementById('progressTooltip');
let isScrubbing = false;
let wasPlayingBeforeScrub = false;

function scrubToX(clientX) {
  const r = progressTrack.getBoundingClientRect();
  const pct = Math.max(0, Math.min(1, (clientX - r.left) / r.width));
  const t = pct * (video.duration || 0);
  video.currentTime = t;
  progressTooltip.textContent = fmt(t);
  // Position tooltip above handle via the fill width
  progressFill.style.width = (pct * 100) + '%';
}

progressTrack.addEventListener('mousedown', e => {
  if (!video.duration) return;
  isScrubbing = true;
  wasPlayingBeforeScrub = !video.paused;
  video.pause();
  progressTrack.classList.add('scrubbing');
  scrubToX(e.clientX);
});

document.addEventListener('mousemove', e => {
  if (!isScrubbing) return;
  scrubToX(e.clientX);
});

document.addEventListener('mouseup', () => {
  if (!isScrubbing) return;
  isScrubbing = false;
  progressTrack.classList.remove('scrubbing');
  if (wasPlayingBeforeScrub) video.play();
});

loopBtn.addEventListener('click', function() {
  isLooping = !isLooping;
  video.loop = isLooping;
  this.classList.toggle('active', isLooping);
  this.textContent = isLooping ? 'Loop' : 'No Loop';
  showToast('Loop: ' + (isLooping ? 'ON' : 'OFF'), 'info');
});
loopBtn.classList.add('active');

// Speed control
speedSelect.addEventListener('change', e => {
  state.timeline.speed = parseFloat(e.target.value);
  video.playbackRate = state.timeline.speed;
});

// Keyboard shortcuts
const kbOverlay = document.getElementById('kbOverlay');
function toggleKbHelp() { kbOverlay.classList.toggle('open'); }

document.getElementById('kbHelpBtn').addEventListener('click', toggleKbHelp);
document.getElementById('kbClose').addEventListener('click', () => kbOverlay.classList.remove('open'));
kbOverlay.addEventListener('click', e => { if (e.target === kbOverlay) kbOverlay.classList.remove('open'); });

document.addEventListener('keydown', e => {
  // Undo/redo works everywhere (including inputs)
  if ((e.metaKey || e.ctrlKey) && e.key === 'z' && !e.shiftKey) { e.preventDefault(); undo(); return; }
  if ((e.metaKey || e.ctrlKey) && e.key === 'z' && e.shiftKey) { e.preventDefault(); redo(); return; }
  if ((e.metaKey || e.ctrlKey) && e.key === 'Z') { e.preventDefault(); redo(); return; }
  if (e.target.tagName === 'INPUT' || e.target.tagName === 'SELECT' || e.target.tagName === 'TEXTAREA') return;
  if (e.key === 'Escape' && kbOverlay.classList.contains('open')) { kbOverlay.classList.remove('open'); return; }
  if (e.key === 'Escape' && document.getElementById('exportDialog').classList.contains('open')) { document.getElementById('exportDialog').classList.remove('open'); return; }
  if (e.key === '?') { toggleKbHelp(); return; }
  if (e.code === 'Space') { e.preventDefault(); video.paused ? video.play() : video.pause(); }
  if (e.key === '[') { togglePanel('left'); return; }
  if (e.key === ']') { togglePanel('right'); return; }
  if (e.code === 'ArrowLeft') video.currentTime = Math.max(0, video.currentTime - 5);
  if (e.code === 'ArrowRight') video.currentTime = Math.min(video.duration || 0, video.currentTime + 5);
});
document.getElementById('undoBtn').addEventListener('click', undo);
document.getElementById('redoBtn').addEventListener('click', redo);

// Capture undo state when slider drag or color picker begins (before value changes)
document.addEventListener('mousedown', e => {
  if (e.target.type === 'range' || e.target.type === 'color') pushUndoState();
}, true);

// ============================================================
// COLLAPSIBLE SIDEBAR PANELS
// ============================================================
const leftPanel = document.getElementById('leftPanel');
const rightPanel = document.getElementById('rightPanel');
const leftPanelToggle = document.getElementById('leftPanelToggle');
const rightPanelToggle = document.getElementById('rightPanelToggle');

function togglePanel(side) {
  const panel = side === 'left' ? leftPanel : rightPanel;
  const btn = side === 'left' ? leftPanelToggle : rightPanelToggle;
  const collapsed = panel.classList.toggle('collapsed');
  if (side === 'left') {
    btn.textContent = collapsed ? '¬ª' : '¬´';
  } else {
    btn.textContent = collapsed ? '¬´' : '¬ª';
  }
  savePanelState();
}

function savePanelState() {
  localStorage.setItem('mockupStudioPanels', JSON.stringify({
    left: leftPanel.classList.contains('collapsed'),
    right: rightPanel.classList.contains('collapsed'),
  }));
}

function loadPanelState() {
  // Auto-collapse on narrow screens
  if (window.innerWidth < 1280) {
    leftPanel.classList.add('collapsed');
    rightPanel.classList.add('collapsed');
    leftPanelToggle.textContent = '¬ª';
    rightPanelToggle.textContent = '¬´';
  }
  // Override with saved state if it exists
  try {
    const raw = localStorage.getItem('mockupStudioPanels');
    if (raw) {
      const s = JSON.parse(raw);
      leftPanel.classList.toggle('collapsed', s.left);
      rightPanel.classList.toggle('collapsed', s.right);
      leftPanelToggle.textContent = s.left ? '¬ª' : '¬´';
      rightPanelToggle.textContent = s.right ? '¬´' : '¬ª';
    }
  } catch (e) { /* ignore */ }
}

leftPanelToggle.addEventListener('click', () => togglePanel('left'));
rightPanelToggle.addEventListener('click', () => togglePanel('right'));
loadPanelState();

// ============================================================
// ENTRANCE ANIMATION
// ============================================================
entranceSelect.addEventListener('change', e => { state.entrance.type = e.target.value; });
entranceDur.addEventListener('input', e => {
  state.entrance.duration = parseInt(e.target.value);
  entranceDurVal.textContent = (parseInt(e.target.value) / 1000).toFixed(1) + 's';
});

// ============================================================
// TIMELINE
// ============================================================
function rebuildTimeline() {
  const track = timelineTrack;
  // Remove old clip blocks
  track.querySelectorAll('.clip-block, .trim-handle, .keyframe-diamond').forEach(el => el.remove());

  const totalDuration = state.timeline.clips.reduce((s, c) => s + c.duration, 0) || 1;

  let offset = 0;
  state.timeline.clips.forEach((clip, i) => {
    const block = document.createElement('div');
    block.className = 'clip-block';
    block.style.left = (offset / totalDuration * 100) + '%';
    block.style.width = (clip.duration / totalDuration * 100) + '%';
    block.textContent = clip.name || 'Clip ' + (i+1);
    block.style.background = `rgba(${96 + i*50},${165 - i*30},${250 - i*40},0.2)`;
    block.style.borderColor = `rgba(${96 + i*50},${165 - i*30},${250 - i*40},0.4)`;

    // Trim handles for first clip
    if (i === 0) {
      const leftH = document.createElement('div');
      leftH.className = 'trim-handle left';
      leftH.style.left = (state.timeline.trimIn * 100) + '%';
      block.appendChild(leftH);
      makeTrimDraggable(leftH, 'left');

      const rightH = document.createElement('div');
      rightH.className = 'trim-handle right';
      rightH.style.right = ((1 - state.timeline.trimOut) * 100) + '%';
      block.appendChild(rightH);
      makeTrimDraggable(rightH, 'right');
    }

    track.appendChild(block);
    offset += clip.duration;
  });

  // Keyframe diamonds
  state.timeline.keyframes.forEach((kf, i) => {
    const diamond = document.createElement('div');
    diamond.className = 'keyframe-diamond';
    diamond.style.left = (kf.time / totalDuration * 100) + '%';
    diamond.style.bottom = '2px';
    diamond.title = `KF ${i+1}: ${kf.time.toFixed(1)}s`;
    diamond.addEventListener('dblclick', () => {
      state.timeline.keyframes.splice(i, 1);
      rebuildTimeline();
    });
    track.appendChild(diamond);
  });
}

function makeTrimDraggable(handle, side) {
  let dragging = false;
  handle.addEventListener('mousedown', e => { e.stopPropagation(); dragging = true; });
  document.addEventListener('mousemove', e => {
    if (!dragging) return;
    const rect = timelineTrack.getBoundingClientRect();
    let pct = (e.clientX - rect.left) / rect.width;
    pct = Math.max(0, Math.min(1, pct));
    if (side === 'left') {
      state.timeline.trimIn = Math.min(pct, state.timeline.trimOut - 0.01);
      handle.style.left = (state.timeline.trimIn * 100) + '%';
    } else {
      state.timeline.trimOut = Math.max(pct, state.timeline.trimIn + 0.01);
      handle.parentElement.querySelector('.trim-handle.right').style.right = ((1 - state.timeline.trimOut) * 100) + '%';
    }
  });
  document.addEventListener('mouseup', () => { dragging = false; });
}

function updateTimelineScrubber() {
  if (!video.duration) return;
  const totalDuration = state.timeline.clips.reduce((s, c) => s + c.duration, 0) || video.duration;
  const pct = video.currentTime / totalDuration * 100;
  timelineScrubber.style.left = pct + '%';
}

// Timeline click to seek
timelineTrack.addEventListener('click', e => {
  if (!video.duration) return;
  const rect = timelineTrack.getBoundingClientRect();
  const pct = (e.clientX - rect.left) / rect.width;
  const totalDuration = state.timeline.clips.reduce((s, c) => s + c.duration, 0) || video.duration;
  video.currentTime = pct * totalDuration;
});

// Add clip
document.getElementById('addClipBtn').addEventListener('click', () => clipInput.click());
clipInput.addEventListener('change', e => {
  const file = e.target.files[0];
  if (!file) return;
  const v = document.createElement('video');
  v.src = URL.createObjectURL(file);
  v.preload = 'metadata';
  v.addEventListener('loadedmetadata', () => {
    state.timeline.clips.push({ video: v, name: file.name, start: 0, duration: v.duration });
    rebuildTimeline();
  });
});

// ============================================================
// LAYERS: TEXT
// ============================================================
document.getElementById('addTextBtn').addEventListener('click', () => {
  pushUndoState();
  const sz = getCanvasSize();
  const layer = {
    id: state.nextLayerId++,
    type: 'text',
    content: 'Title',
    x: sz.w / 2 - 50,
    y: 60,
    fontSize: 36,
    fontFamily: 'SF Pro Display, -apple-system, sans-serif',
    color: '#ffffff',
    weight: '700',
    align: 'left',
    shadow: 0,
    outline: 0,
  };
  state.layers.push(layer);
  state.selectedLayer = state.layers.length - 1;
  rebuildLayerList();
  showTextProps();
});

function showTextProps() {
  document.getElementById('textProps').style.display = 'block';
  document.getElementById('logoProps').style.display = 'none';
  const layer = state.layers[state.selectedLayer];
  if (!layer || layer.type !== 'text') return;
  document.getElementById('textContent').value = layer.content;
  document.getElementById('textSize').value = layer.fontSize;
  document.getElementById('textColor').value = layer.color;
  document.getElementById('textWeight').value = layer.weight;
  document.getElementById('textShadow').value = layer.shadow;
  document.getElementById('textOutline').value = layer.outline;
}

// Text property bindings
['textContent','textFont','textSize','textColor','textWeight','textShadow','textOutline'].forEach(id => {
  document.getElementById(id).addEventListener('input', e => {
    const layer = state.layers[state.selectedLayer];
    if (!layer || layer.type !== 'text') return;
    switch (id) {
      case 'textContent': layer.content = e.target.value; break;
      case 'textFont': layer.fontFamily = e.target.value; break;
      case 'textSize': layer.fontSize = parseInt(e.target.value); break;
      case 'textColor': layer.color = e.target.value; break;
      case 'textWeight': layer.weight = e.target.value; break;
      case 'textShadow': layer.shadow = parseInt(e.target.value); break;
      case 'textOutline': layer.outline = parseInt(e.target.value); break;
    }
  });
});

// ============================================================
// LAYERS: LOGO
// ============================================================
document.getElementById('addLogoBtn').addEventListener('click', () => logoInput.click());
logoInput.addEventListener('change', e => {
  const file = e.target.files[0];
  if (!file) return;
  pushUndoState();
  const img = new Image();
  img.onload = () => {
    const sz = getCanvasSize();
    const layer = {
      id: state.nextLayerId++,
      type: 'logo',
      img: img,
      fileName: file.name.replace(/\.[^.]+$/, ''),
      x: sz.w - 120,
      y: sz.h - 80,
      width: 100,
      opacity: 1,
    };
    state.layers.push(layer);
    state.selectedLayer = state.layers.length - 1;
    rebuildLayerList();
    showLogoProps();
  };
  img.src = URL.createObjectURL(file);
});

function showLogoProps() {
  document.getElementById('textProps').style.display = 'none';
  document.getElementById('logoProps').style.display = 'block';
  const layer = state.layers[state.selectedLayer];
  if (!layer || layer.type !== 'logo') return;
  document.getElementById('logoOpacity').value = layer.opacity * 100;
  document.getElementById('logoWidth').value = layer.width;
}

document.getElementById('logoOpacity').addEventListener('input', e => {
  const layer = state.layers[state.selectedLayer];
  if (layer && layer.type === 'logo') layer.opacity = parseInt(e.target.value) / 100;
});
document.getElementById('logoWidth').addEventListener('input', e => {
  const layer = state.layers[state.selectedLayer];
  if (layer && layer.type === 'logo') layer.width = parseInt(e.target.value);
});

// ============================================================
// UNIFIED LAYER PANEL
// ============================================================
const unifiedLayersEl = document.getElementById('unifiedLayers');
const layerDetailEl = document.getElementById('layerDetail');
const advStackEl = document.getElementById('advStack');

function isGroupActive(id) {
  switch (id) {
    case 'bgVideo': return state.bgVideo.enabled;
    case 'particles': return state.particles.enabled;
    case 'device': return true;
    case 'device2': return state.comparison.enabled && !!state.comparison.device2;
    case 'content': return state.layers.length > 0;
    case 'facecam': return state.facecam.enabled;
    case 'videoOverlays': return state.videoOverlays.length > 0;
    case 'uiOverlays': return state.waveform.enabled || state.progressBar.enabled || state.glassmorphism.enabled;
    default: return false;
  }
}

function getSystemLayerName(group) {
  if (group.id === 'device') {
    if (state.device.type === 'none') return 'Video (No Device)';
    const dev = DEVICES[state.device.type];
    return dev ? dev.name : 'Device';
  }
  if (group.id === 'device2' && state.comparison.device2) {
    const dev2 = DEVICES[state.comparison.device2.type];
    return dev2 ? dev2.name + ' (2)' : 'Device 2';
  }
  if (group.id === 'bgVideo') return 'Background Video';
  if (group.id === 'uiOverlays') {
    const parts = [];
    if (state.waveform.enabled) parts.push('Waveform');
    if (state.progressBar.enabled) parts.push('Progress');
    if (state.glassmorphism.enabled) parts.push('CTA');
    return parts.join(' + ') || 'UI Effects';
  }
  return group.name;
}

function getContentLayerName(layer) {
  if (layer.type === 'text') {
    const t = (layer.content || '').substring(0, 24);
    return t || 'Empty Text';
  }
  if (layer.type === 'logo') return layer.fileName || 'Logo';
  if (layer.type === 'annotation') {
    const typeNames = { arrow: 'Arrow', circle: 'Circle', rect: 'Rectangle', freehand: 'Freehand', callout: 'Callout' };
    return typeNames[layer.annoType] || 'Annotation';
  }
  return 'Layer';
}

function getContentLayerIcon(layer) {
  if (layer.type === 'text') return 'T';
  if (layer.type === 'logo') return 'üñº';
  if (layer.type === 'annotation') {
    const icons = { arrow: '‚û§', circle: '‚óØ', rect: '‚ñ≠', freehand: '‚úé', callout: 'üí¨' };
    return icons[layer.annoType] || '‚úé';
  }
  return '‚Ä¢';
}

// Build flat display list from render stack
function buildDisplayList() {
  const list = [];
  for (let i = state.renderStack.length - 1; i >= 0; i--) {
    const group = state.renderStack[i];
    if (!isGroupActive(group.id)) continue;

    if (group.id === 'content') {
      // Expand individual content layers
      for (let j = state.layers.length - 1; j >= 0; j--) {
        list.push({
          kind: 'content', groupIdx: i, layerIdx: j,
          name: getContentLayerName(state.layers[j]),
          icon: getContentLayerIcon(state.layers[j]),
          hidden: group.hidden || state.layers[j].visible === false,
        });
      }
    } else if (group.id === 'videoOverlays') {
      // Expand individual overlays
      for (let j = state.videoOverlays.length - 1; j >= 0; j--) {
        const ov = state.videoOverlays[j];
        list.push({
          kind: 'overlay', groupIdx: i, overlayIdx: j,
          name: ov.name || ov.builtin || 'Overlay',
          icon: 'üéû',
          hidden: group.hidden || ov.hidden === true,
        });
      }
    } else {
      list.push({
        kind: 'system', groupIdx: i, groupId: group.id,
        name: getSystemLayerName(group),
        icon: group.icon,
        isMain: group.id === 'device',
        hidden: group.hidden,
      });
    }
  }
  return list;
}

function rebuildUnifiedLayers() {
  const list = buildDisplayList();
  unifiedLayersEl.innerHTML = '';

  if (list.length <= 1 && !hasVideo && state.layers.length === 0) {
    unifiedLayersEl.innerHTML = '<div class="ul-empty">Drop a video to get started</div>';
    layerDetailEl.style.display = 'none';
    return;
  }

  list.forEach((item, di) => {
    const div = document.createElement('div');
    let cls = 'ul-item';
    if (item.isMain) cls += ' main-layer';
    if (item.hidden) cls += ' hidden-layer';
    if (item.kind === 'content' && item.layerIdx === state.selectedLayer) cls += ' selected';
    div.className = cls;

    // Eye toggle
    const eye = document.createElement('button');
    eye.className = 'ul-eye' + (item.hidden ? ' off' : '');
    eye.textContent = item.hidden ? '‚óã' : '‚óè';
    eye.title = item.hidden ? 'Show' : 'Hide';
    eye.addEventListener('click', e => {
      e.stopPropagation();
      if (item.kind === 'content') {
        const layer = state.layers[item.layerIdx];
        layer.visible = layer.visible === false ? true : false;
      } else if (item.kind === 'overlay') {
        const ov = state.videoOverlays[item.overlayIdx];
        if (ov) ov.hidden = !ov.hidden;
      } else {
        const g = state.renderStack[item.groupIdx];
        g.hidden = !g.hidden;
      }
      rebuildUnifiedLayers();
    });
    div.appendChild(eye);

    // Icon
    const icon = document.createElement('span');
    icon.className = 'ul-icon';
    icon.textContent = item.icon;
    div.appendChild(icon);

    // Name
    const name = document.createElement('span');
    name.className = 'ul-name';
    name.textContent = item.name;
    div.appendChild(name);

    // Main tag
    if (item.isMain) {
      const tag = document.createElement('span');
      tag.className = 'ul-tag';
      tag.textContent = 'main';
      div.appendChild(tag);
    }

    // Hover controls
    const controls = document.createElement('span');
    controls.className = 'ul-controls';

    // Find position in display list for system layer reordering
    function moveGroupInStack(groupIdx, direction) {
      // direction: +1 = up in visual (later in array), -1 = down in visual (earlier in array)
      const newIdx = groupIdx + direction;
      if (newIdx < 0 || newIdx >= state.renderStack.length) return;
      const [moved] = state.renderStack.splice(groupIdx, 1);
      state.renderStack.splice(newIdx, 0, moved);
      rebuildUnifiedLayers();
    }

    const upBtn = document.createElement('button');
    upBtn.className = 'ul-btn';
    upBtn.textContent = '‚ñ≤';
    upBtn.title = 'Move forward';
    upBtn.addEventListener('click', e => {
      e.stopPropagation();
      if (item.kind === 'content') {
        if (item.layerIdx < state.layers.length - 1) {
          const arr = state.layers;
          [arr[item.layerIdx], arr[item.layerIdx + 1]] = [arr[item.layerIdx + 1], arr[item.layerIdx]];
          if (state.selectedLayer === item.layerIdx) state.selectedLayer = item.layerIdx + 1;
          else if (state.selectedLayer === item.layerIdx + 1) state.selectedLayer = item.layerIdx;
          rebuildUnifiedLayers();
        }
      } else if (item.kind === 'overlay') {
        if (item.overlayIdx < state.videoOverlays.length - 1) {
          const arr = state.videoOverlays;
          [arr[item.overlayIdx], arr[item.overlayIdx + 1]] = [arr[item.overlayIdx + 1], arr[item.overlayIdx]];
          rebuildUnifiedLayers();
        }
      } else if (item.kind === 'system') {
        // Moving "up" in visual = moving later in renderStack (higher index)
        moveGroupInStack(item.groupIdx, 1);
      }
    });

    const downBtn = document.createElement('button');
    downBtn.className = 'ul-btn';
    downBtn.textContent = '‚ñº';
    downBtn.title = 'Move backward';
    downBtn.addEventListener('click', e => {
      e.stopPropagation();
      if (item.kind === 'content') {
        if (item.layerIdx > 0) {
          const arr = state.layers;
          [arr[item.layerIdx], arr[item.layerIdx - 1]] = [arr[item.layerIdx - 1], arr[item.layerIdx]];
          if (state.selectedLayer === item.layerIdx) state.selectedLayer = item.layerIdx - 1;
          else if (state.selectedLayer === item.layerIdx - 1) state.selectedLayer = item.layerIdx;
          rebuildUnifiedLayers();
        }
      } else if (item.kind === 'overlay') {
        if (item.overlayIdx > 0) {
          const arr = state.videoOverlays;
          [arr[item.overlayIdx], arr[item.overlayIdx - 1]] = [arr[item.overlayIdx - 1], arr[item.overlayIdx]];
          rebuildUnifiedLayers();
        }
      } else if (item.kind === 'system') {
        // Moving "down" in visual = moving earlier in renderStack (lower index)
        moveGroupInStack(item.groupIdx, -1);
      }
    });

    controls.appendChild(upBtn);
    controls.appendChild(downBtn);

    // Delete button only for content and overlay items (not system layers)
    if (item.kind === 'content' || item.kind === 'overlay') {
      const delBtn = document.createElement('button');
      delBtn.className = 'ul-btn del';
      delBtn.textContent = '‚úï';
      delBtn.title = 'Remove';
      delBtn.addEventListener('click', e => {
        e.stopPropagation();
        pushUndoState();
        if (item.kind === 'content') {
          state.layers.splice(item.layerIdx, 1);
          state.selectedLayer = Math.min(state.selectedLayer, state.layers.length - 1);
        } else if (item.kind === 'overlay') {
          state.videoOverlays.splice(item.overlayIdx, 1);
        }
        rebuildUnifiedLayers();
      });
      controls.appendChild(delBtn);
    }

    div.appendChild(controls);

    // Click to select (content layers)
    div.addEventListener('click', () => {
      if (item.kind === 'content') {
        state.selectedLayer = item.layerIdx;
        rebuildUnifiedLayers();
        const layer = state.layers[item.layerIdx];
        if (layer.type === 'text') showTextProps();
        else if (layer.type === 'logo') showLogoProps();
        else {
          document.getElementById('textProps').style.display = 'none';
          document.getElementById('logoProps').style.display = 'none';
        }
        showLayerDetail(item.layerIdx);
      } else {
        state.selectedLayer = -1;
        layerDetailEl.style.display = 'none';
        document.getElementById('textProps').style.display = 'none';
        document.getElementById('logoProps').style.display = 'none';
        rebuildUnifiedLayers();
      }
    });

    unifiedLayersEl.appendChild(div);
  });
}

function showLayerDetail(idx) {
  const layer = state.layers[idx];
  if (!layer) { layerDetailEl.style.display = 'none'; return; }
  layerDetailEl.style.display = 'block';

  const opVal = Math.round((layer.opacity !== undefined ? layer.opacity : 1) * 100);
  let html = `<div class="detail-row"><label>Opacity</label><input type="range" id="detailOpacity" min="0" max="100" value="${opVal}"><span id="detailOpacityVal">${opVal}%</span></div>`;
  if (layer.type === 'text') {
    html += `<div class="detail-row"><label>Size</label><input type="range" id="detailFontSize" min="10" max="200" value="${layer.fontSize}"><span id="detailFontSizeVal">${layer.fontSize}px</span></div>`;
  }
  layerDetailEl.innerHTML = html;

  // Opacity control
  const opSlider = document.getElementById('detailOpacity');
  if (opSlider) {
    opSlider.addEventListener('input', e => {
      const v = parseInt(e.target.value);
      document.getElementById('detailOpacityVal').textContent = v + '%';
      if (layer.type === 'logo') layer.opacity = v / 100;
      else if (layer.type === 'text') layer.opacity = v / 100;
    });
  }
  // Font size control
  const fsSlider = document.getElementById('detailFontSize');
  if (fsSlider) {
    fsSlider.addEventListener('input', e => {
      const v = parseInt(e.target.value);
      document.getElementById('detailFontSizeVal').textContent = v + 'px';
      layer.fontSize = v;
    });
  }
}

// ---- Advanced Render Order panel ----
function rebuildAdvStack() {
  advStackEl.innerHTML = '';
  const stackReversed = [...state.renderStack].reverse();
  stackReversed.forEach((group, ri) => {
    const actualIdx = state.renderStack.length - 1 - ri;
    const active = isGroupActive(group.id);
    const div = document.createElement('div');
    div.className = 'adv-item' + (active ? ' active' : '');
    div.dataset.idx = actualIdx;
    div.draggable = true;
    div.innerHTML = `<span class="adv-drag">‚†ø</span><span class="adv-icon">${group.icon}</span><span class="adv-name">${group.name}</span>`;
    div.addEventListener('dragstart', e => {
      e.dataTransfer.effectAllowed = 'move';
      e.dataTransfer.setData('text/plain', actualIdx);
      div.classList.add('dragging');
    });
    div.addEventListener('dragend', () => {
      div.classList.remove('dragging');
      advStackEl.querySelectorAll('.adv-item').forEach(el => el.classList.remove('drag-over'));
    });
    div.addEventListener('dragover', e => { e.preventDefault(); div.classList.add('drag-over'); });
    div.addEventListener('dragleave', () => div.classList.remove('drag-over'));
    div.addEventListener('drop', e => {
      e.preventDefault();
      div.classList.remove('drag-over');
      const fromIdx = parseInt(e.dataTransfer.getData('text/plain'));
      if (fromIdx === actualIdx) return;
      const [moved] = state.renderStack.splice(fromIdx, 1);
      state.renderStack.splice(actualIdx, 0, moved);
      rebuildAdvStack();
      rebuildUnifiedLayers();
    });
    advStackEl.appendChild(div);
  });
}

// Advanced panel toggle
document.getElementById('advLayerToggle').addEventListener('click', () => {
  const panel = document.getElementById('advLayerPanel');
  const visible = panel.style.display !== 'none';
  panel.style.display = visible ? 'none' : 'block';
  document.getElementById('advLayerToggle').textContent = visible ? 'Advanced Render Order' : 'Hide Advanced';
  if (!visible) rebuildAdvStack();
});

// Quick-add buttons
document.getElementById('quickAddText').addEventListener('click', () => {
  document.getElementById('addTextBtn').click();
});
document.getElementById('quickAddLogo').addEventListener('click', () => {
  document.getElementById('addLogoBtn').click();
});

// Periodic refresh
rebuildUnifiedLayers();
let _lastLayerHash = '';
setInterval(() => {
  const hash = state.renderStack.map(g => g.id + (g.hidden?'h':'')).join(',') + '|' +
    state.layers.map(l => (l.visible===false?'h':'') + l.type + (l.content||'').substring(0,10)).join(',') + '|' +
    state.videoOverlays.map(o => (o.hidden?'h':'') + (o.name||o.builtin||'')).join(',') + '|' + state.selectedLayer + '|' +
    (state.device.type) + '|' + state.comparison.enabled + '|' +
    state.bgVideo.enabled + '|' + state.particles.enabled + '|' +
    state.facecam.enabled + '|' + state.waveform.enabled + '|' +
    state.progressBar.enabled + '|' + state.glassmorphism.enabled;
  if (hash !== _lastLayerHash) {
    _lastLayerHash = hash;
    rebuildUnifiedLayers();
  }
}, 500);

// ============================================================
// LAYER LIST (backwards compat ‚Äî hidden, still used internally)
// ============================================================
function rebuildLayerList() {
  // The visible unified panel handles display now
  rebuildUnifiedLayers();
}

// ============================================================
// DRAGGING LAYERS ON CANVAS
// ============================================================
let dragLayer = null;
let dragOffset = { x: 0, y: 0 };

canvas.addEventListener('mousedown', e => {
  if (state.annotation.tool) return; // annotation mode
  const rect = canvas.getBoundingClientRect();
  const scaleX = canvas.width / rect.width;
  const scaleY = canvas.height / rect.height;
  const mx = (e.clientX - rect.left) * scaleX;
  const my = (e.clientY - rect.top) * scaleY;

  // Hit test layers (reverse order)
  for (let i = state.layers.length - 1; i >= 0; i--) {
    const layer = state.layers[i];
    let hit = false;
    if (layer.type === 'text') {
      const w = ctx.measureText(layer.content).width || (layer.fontSize * layer.content.length * 0.6);
      hit = mx >= layer.x - 5 && mx <= layer.x + w + 5 && my >= layer.y - 5 && my <= layer.y + layer.fontSize + 5;
    } else if (layer.type === 'logo' && layer.img) {
      const aspect = layer.img.naturalWidth / layer.img.naturalHeight;
      const lh = layer.width / aspect;
      hit = mx >= layer.x && mx <= layer.x + layer.width && my >= layer.y && my <= layer.y + lh;
    }
    if (hit) {
      dragLayer = layer;
      dragOffset.x = mx - layer.x;
      dragOffset.y = my - layer.y;
      state.selectedLayer = i;
      rebuildLayerList();
      if (layer.type === 'text') showTextProps();
      else if (layer.type === 'logo') showLogoProps();
      e.preventDefault();
      return;
    }
  }
  // If no layer hit and has video, toggle playback
  if (hasVideo && !state.annotation.tool) {
    video.paused ? video.play() : video.pause();
  }
});

canvas.addEventListener('mousemove', e => {
  if (!dragLayer) return;
  const rect = canvas.getBoundingClientRect();
  const scaleX = canvas.width / rect.width;
  const scaleY = canvas.height / rect.height;
  dragLayer.x = (e.clientX - rect.left) * scaleX - dragOffset.x;
  dragLayer.y = (e.clientY - rect.top) * scaleY - dragOffset.y;
});

document.addEventListener('mouseup', () => { dragLayer = null; });

// Double-click to edit text inline
canvas.addEventListener('dblclick', e => {
  const layer = state.layers[state.selectedLayer];
  if (!layer || layer.type !== 'text') return;
  const newText = prompt('Edit text:', layer.content);
  if (newText !== null) {
    layer.content = newText;
    document.getElementById('textContent').value = newText;
    rebuildLayerList();
  }
});

// ============================================================
// ANNOTATIONS
// ============================================================
let annoDrawing = false;
let annoPoints = [];

document.getElementById('annoToolbar').addEventListener('click', e => {
  const btn = e.target.closest('.anno-btn');
  if (!btn) return;
  const tool = btn.dataset.tool;
  if (state.annotation.tool === tool) {
    state.annotation.tool = null;
    btn.classList.remove('active');
    canvas.style.cursor = 'pointer';
  } else {
    state.annotation.tool = tool;
    document.querySelectorAll('.anno-btn').forEach(b => b.classList.remove('active'));
    btn.classList.add('active');
    canvas.style.cursor = 'crosshair';
  }
});

document.getElementById('annoColor').addEventListener('input', e => { state.annotation.color = e.target.value; });
document.getElementById('annoWidth').addEventListener('input', e => { state.annotation.width = parseInt(e.target.value); });

canvas.addEventListener('mousedown', e => {
  if (!state.annotation.tool) return;
  const rect = canvas.getBoundingClientRect();
  const sx = canvas.width / rect.width;
  const sy = canvas.height / rect.height;
  const mx = (e.clientX - rect.left) * sx;
  const my = (e.clientY - rect.top) * sy;
  annoDrawing = true;
  annoPoints = [{ x: mx, y: my }];
  e.preventDefault();
  e.stopPropagation();
}, true);

canvas.addEventListener('mousemove', e => {
  if (!annoDrawing || !state.annotation.tool) return;
  const rect = canvas.getBoundingClientRect();
  const sx = canvas.width / rect.width;
  const sy = canvas.height / rect.height;
  const mx = (e.clientX - rect.left) * sx;
  const my = (e.clientY - rect.top) * sy;

  if (state.annotation.tool === 'freehand') {
    annoPoints.push({ x: mx, y: my });
  } else {
    if (annoPoints.length > 1) annoPoints.pop();
    annoPoints.push({ x: mx, y: my });
  }

  // Live preview: draw temp annotation
  // (will be rendered next frame since we store temp in a special way)
}, true);

canvas.addEventListener('mouseup', e => {
  if (!annoDrawing || !state.annotation.tool) return;
  annoDrawing = false;
  pushUndoState();

  const currentTime = hasVideo ? video.currentTime : 0;
  const layer = {
    id: state.nextLayerId++,
    type: 'annotation',
    annoType: state.annotation.tool,
    points: [...annoPoints],
    color: state.annotation.color,
    lineWidth: state.annotation.width,
    content: state.annotation.tool === 'callout' ? 'Note' : '',
    startTime: currentTime,
    endTime: currentTime + 5,
  };
  state.layers.push(layer);
  rebuildLayerList();
  annoPoints = [];
}, true);

// ============================================================
// FACECAM
// ============================================================
function ensureFacecamVideo() {
  let fcv = document.getElementById('facecamVideo');
  if (!fcv) {
    fcv = document.createElement('video');
    fcv.id = 'facecamVideo';
    fcv.style.display = 'none';
    fcv.autoplay = true;
    fcv.muted = true;
    fcv.loop = true;
    fcv.playsInline = true;
    document.body.appendChild(fcv);
  }
  return fcv;
}

function enableFacecam() {
  state.facecam.enabled = true;
  state.facecam.x = -1; state.facecam.y = -1; // reset to corner default
  document.getElementById('facecamProps').style.display = 'block';
}

function disableFacecam() {
  state.facecam.enabled = false;
  if (state.facecam.stream && state.facecam.source === 'camera') {
    state.facecam.stream.getTracks().forEach(t => t.stop());
  }
  state.facecam.stream = null;
  document.getElementById('facecamProps').style.display = 'none';
  const fcv = document.getElementById('facecamVideo');
  if (fcv) { fcv.pause(); fcv.srcObject = null; fcv.src = ''; fcv.remove(); }
}

// Webcam button
document.getElementById('facecamBtn').addEventListener('click', async function() {
  if (state.facecam.enabled) { disableFacecam(); return; }
  try {
    const stream = await navigator.mediaDevices.getUserMedia({ video: true });
    state.facecam.source = 'camera';
    state.facecam.stream = stream;
    const fcv = ensureFacecamVideo();
    fcv.srcObject = stream;
    fcv.loop = false;
    enableFacecam();
  } catch (err) {
    alert('Could not access camera: ' + err.message);
  }
});

// Video file button
document.getElementById('facecamFileBtn').addEventListener('click', () => {
  document.getElementById('facecamFileInput').click();
});
document.getElementById('facecamFileInput').addEventListener('change', e => {
  const file = e.target.files[0];
  if (!file) return;
  if (state.facecam.enabled) disableFacecam();
  state.facecam.source = 'file';
  state.facecam.stream = { getTracks: () => [] }; // placeholder so render check passes
  const fcv = ensureFacecamVideo();
  fcv.srcObject = null;
  fcv.src = URL.createObjectURL(file);
  fcv.loop = true;
  fcv.load();
  fcv.play().catch(() => { fcv.muted = true; fcv.play(); });
  enableFacecam();
});

// Disable button
document.getElementById('facecamDisableBtn').addEventListener('click', () => { disableFacecam(); });

// Controls
document.getElementById('facecamSize').addEventListener('input', e => {
  state.facecam.size = parseInt(e.target.value) / 100;
  state.facecam.x = -1; state.facecam.y = -1; // recalculate position
  document.getElementById('facecamSizeVal').textContent = e.target.value + '%';
});
document.getElementById('facecamCorner').addEventListener('change', e => {
  state.facecam.corner = e.target.value;
  state.facecam.x = -1; state.facecam.y = -1; // recalculate position
});
document.getElementById('facecamShape').addEventListener('change', e => { state.facecam.shape = e.target.value; });
document.getElementById('facecamBorderColor').addEventListener('input', e => { state.facecam.borderColor = e.target.value; });
document.getElementById('facecamBorderWidth').addEventListener('input', e => { state.facecam.borderWidth = parseInt(e.target.value); });
document.getElementById('facecamShadow').addEventListener('change', e => { state.facecam.shadow = e.target.value === 'true'; });

// Dragging facecam on canvas
let draggingFacecam = false;
let fcDragOffset = { x: 0, y: 0 };

canvas.addEventListener('mousedown', e => {
  if (!state.facecam.enabled || !state.facecam.stream) return;
  const rect = canvas.getBoundingClientRect();
  const sx = canvas.width / rect.width;
  const sy = canvas.height / rect.height;
  const mx = (e.clientX - rect.left) * sx;
  const my = (e.clientY - rect.top) * sy;
  const sz2 = Math.round(Math.min(canvas.width, canvas.height) * state.facecam.size);
  const fx = state.facecam.x, fy = state.facecam.y;
  if (fx < 0 || fy < 0) return;
  // Hit test
  const cx = fx + sz2/2, cy = fy + sz2/2;
  const dist = Math.sqrt((mx-cx)**2 + (my-cy)**2);
  if (dist <= sz2/2 + 10) {
    draggingFacecam = true;
    fcDragOffset.x = mx - fx;
    fcDragOffset.y = my - fy;
    e.preventDefault();
    e.stopPropagation();
  }
}, true);

canvas.addEventListener('mousemove', e => {
  if (!draggingFacecam) return;
  const rect = canvas.getBoundingClientRect();
  const sx = canvas.width / rect.width;
  const sy = canvas.height / rect.height;
  state.facecam.x = (e.clientX - rect.left) * sx - fcDragOffset.x;
  state.facecam.y = (e.clientY - rect.top) * sy - fcDragOffset.y;
  // Switch to custom corner mode
  document.getElementById('facecamCorner').value = 'custom';
  state.facecam.corner = 'custom';
}, true);

document.addEventListener('mouseup', () => { draggingFacecam = false; }, true);

// ============================================================
// HAND OVERLAY
// ============================================================
document.getElementById('handBtn').addEventListener('click', function() {
  pushUndoState();
  state.hand.enabled = !state.hand.enabled;
  this.classList.toggle('active', state.hand.enabled);
  this.textContent = state.hand.enabled ? 'Disable Hand' : 'Enable Hand';
  document.getElementById('resetHandBtn').style.display = state.hand.enabled ? 'inline-block' : 'none';
});
document.getElementById('handStyle').addEventListener('change', e => { state.hand.style = e.target.value; });

// ============================================================
// DEVICE COMPARISON
// ============================================================
function enableComparison() {
  state.comparison.enabled = true;
  document.getElementById('comparisonBtn').classList.add('active');
  document.getElementById('comparisonControls').classList.add('visible');
  // Default second device: different from current
  const types = Object.keys(DEVICES);
  const other = types.find(t => t !== state.device.type) || types[0];
  state.comparison.device2 = { type: other, color: DEVICES[other].defaultColor };
  updateDevice2Swatches();
}

function disableComparison() {
  state.comparison.enabled = false;
  document.getElementById('comparisonBtn').classList.remove('active');
  document.getElementById('comparisonControls').classList.remove('visible');
  const vid2 = document.getElementById('srcVideo2');
  if (vid2) { vid2.pause(); vid2.src = ''; }
  document.getElementById('video2Status').textContent = 'No video loaded for Device 2';
}

document.getElementById('comparisonBtn').addEventListener('click', function() {
  if (state.comparison.enabled) { disableComparison(); return; }
  enableComparison();
});

document.getElementById('disableCompareBtn').addEventListener('click', () => disableComparison());

// Device 2 type selection
document.getElementById('device2Grid').addEventListener('click', e => {
  const btn = e.target.closest('.dev-btn');
  if (!btn || !state.comparison.device2) return;
  const devId = btn.dataset.device;
  state.comparison.device2.type = devId;
  state.comparison.device2.color = DEVICES[devId].defaultColor;
  frameCache = {};
  document.querySelectorAll('#device2Grid .dev-btn').forEach(x => x.classList.remove('active'));
  btn.classList.add('active');
  updateDevice2Swatches();
});

function updateDevice2Swatches() {
  if (!state.comparison.device2) return;
  const dev = DEVICES[state.comparison.device2.type];
  const container = document.getElementById('colorSwatches2');
  container.innerHTML = '';
  for (const [key, pal] of Object.entries(dev.colors)) {
    const s = document.createElement('div');
    s.className = 'color-swatch' + (key === state.comparison.device2.color ? ' active' : '');
    s.style.background = pal.body;
    s.title = pal.label;
    s.addEventListener('click', () => {
      state.comparison.device2.color = key;
      frameCache = {};
      container.querySelectorAll('.color-swatch').forEach(x => x.classList.remove('active'));
      s.classList.add('active');
    });
    container.appendChild(s);
  }
}

// Load video for device 2
document.getElementById('loadVideo2Btn').addEventListener('click', () => {
  document.getElementById('video2Input').click();
});

document.getElementById('video2Input').addEventListener('change', e => {
  const file = e.target.files[0];
  if (!file) return;
  const vid2 = document.getElementById('srcVideo2');
  vid2.src = URL.createObjectURL(file);
  vid2.loop = true;
  vid2.muted = true;
  vid2.load();
  vid2.play().catch(() => {});
  document.getElementById('video2Status').textContent = 'Playing: ' + file.name;
});

// ============================================================
// ZOOM KEYFRAMES
// ============================================================
document.getElementById('addKeyframeBtn').addEventListener('click', () => {
  if (!hasVideo) return;
  const kf = {
    time: video.currentTime,
    zoom: parseInt(document.getElementById('kfZoom').value) / 100,
    panX: parseInt(document.getElementById('kfPanX').value),
    panY: parseInt(document.getElementById('kfPanY').value),
  };
  state.timeline.keyframes.push(kf);
  state.timeline.keyframes.sort((a, b) => a.time - b.time);
  rebuildTimeline();
});

// ============================================================
// SCREENSHOT
// ============================================================
ssBtn.addEventListener('click', () => {
  const a = document.createElement('a');
  a.download = 'mockup-' + Date.now() + '.png';
  a.href = canvas.toDataURL('image/png');
  a.click();
  showToast('Screenshot saved', 'success');
});

// ============================================================
// THUMBNAIL
// ============================================================
thumbBtn.addEventListener('click', () => {
  if (!hasVideo) return;
  video.pause();
  // Render at preset size
  const sz = getCanvasSize();
  const thumbCanvas = document.createElement('canvas');
  thumbCanvas.width = sz.w;
  thumbCanvas.height = sz.h;
  const tCtx = thumbCanvas.getContext('2d');
  tCtx.drawImage(canvas, 0, 0, sz.w, sz.h);
  const a = document.createElement('a');
  a.download = 'thumbnail-' + Date.now() + '.png';
  a.href = thumbCanvas.toDataURL('image/png');
  a.click();
  showToast('Thumbnail saved', 'success');
});

// ============================================================
// VIDEO EXPORT
// ============================================================
let recorder = null;
let audioCtx = null;
let sourceNode = null;
let destNode = null;

const exportDialog = document.getElementById('exportDialog');
const edResolution = document.getElementById('edResolution');
const edQuality = document.getElementById('edQuality');
const edFramerate = document.getElementById('edFramerate');
const edAudio = document.getElementById('edAudio');
const edEstimate = document.getElementById('edEstimate');

function updateExportEstimate() {
  const sz = getCanvasSize();
  let w = sz.w, h = sz.h;
  const res = edResolution.value;
  if (res === '1080') { const s = 1080 / Math.max(w, h); w = Math.round(w * s); h = Math.round(h * s); }
  else if (res === '720') { const s = 720 / Math.max(w, h); w = Math.round(w * s); h = Math.round(h * s); }
  // Ensure even dimensions
  w = w % 2 === 0 ? w : w + 1;
  h = h % 2 === 0 ? h : h + 1;
  const dur = video.duration ? ((state.timeline.trimOut - state.timeline.trimIn) * video.duration / state.timeline.speed).toFixed(1) : '?';
  edEstimate.textContent = '~' + dur + 's of video at ' + w + '\u00d7' + h + ' ¬∑ ' + edFramerate.value + ' fps';
}

function openExportDialog() {
  updateExportEstimate();
  exportDialog.classList.add('open');
}

function closeExportDialog() {
  exportDialog.classList.remove('open');
}

edResolution.addEventListener('change', updateExportEstimate);
edFramerate.addEventListener('change', updateExportEstimate);
edQuality.addEventListener('change', updateExportEstimate);
document.getElementById('edCancel').addEventListener('click', closeExportDialog);
exportDialog.addEventListener('click', e => { if (e.target === exportDialog) closeExportDialog(); });

exportBtn.addEventListener('click', () => {
  if (!hasVideo) return;
  if (isExporting) { stopExport(); return; }
  openExportDialog();
});

document.getElementById('edStart').addEventListener('click', () => {
  closeExportDialog();
  startExport();
});

function startExport() {
  isExporting = true;
  exportBtn.textContent = 'Stop';
  exportBtn.classList.add('recording');
  exportStatus.classList.add('visible');
  exportText.textContent = 'Preparing...';
  exportBarFill.style.width = '0%';

  // Read settings from dialog
  const bitrate = parseInt(edQuality.value);
  const fps = parseInt(edFramerate.value);
  const includeAudio = edAudio.checked;

  const origSz = getCanvasSize();
  let expW = origSz.w, expH = origSz.h;
  const res = edResolution.value;
  if (res === '1080') { const s = 1080 / Math.max(expW, expH); expW = Math.round(expW * s); expH = Math.round(expH * s); }
  else if (res === '720') { const s = 720 / Math.max(expW, expH); expW = Math.round(expW * s); expH = Math.round(expH * s); }
  // Ensure even dimensions for codec compatibility
  expW = expW % 2 === 0 ? expW : expW + 1;
  expH = expH % 2 === 0 ? expH : expH + 1;

  // Create export canvas at target resolution
  const exportCanvas = document.createElement('canvas');
  exportCanvas.width = expW;
  exportCanvas.height = expH;
  const eCtx = exportCanvas.getContext('2d');

  let exportRAF;
  function exportLoop() {
    eCtx.clearRect(0, 0, expW, expH);
    eCtx.drawImage(canvas, 0, 0, expW, expH);
    if (isExporting) exportRAF = requestAnimationFrame(exportLoop);
  }
  exportLoop();

  // Capture stream at target framerate
  const expStream = exportCanvas.captureStream(fps);

  // Audio
  if (includeAudio) {
    try {
      if (!audioCtx) {
        audioCtx = new AudioContext();
        sourceNode = audioCtx.createMediaElementSource(video);
      }
      destNode = audioCtx.createMediaStreamDestination();
      sourceNode.disconnect();
      sourceNode.connect(destNode);
      sourceNode.connect(audioCtx.destination);
      for (const t of destNode.stream.getAudioTracks()) expStream.addTrack(t);
    } catch (err) { console.log('Audio capture skipped:', err.message); }
  }

  let mime = 'video/webm;codecs=vp9,opus';
  if (!MediaRecorder.isTypeSupported(mime)) mime = 'video/webm;codecs=vp8,opus';
  if (!MediaRecorder.isTypeSupported(mime)) mime = 'video/webm';

  const chunks = [];
  recorder = new MediaRecorder(expStream, { mimeType: mime, videoBitsPerSecond: bitrate });
  recorder.ondataavailable = e => { if (e.data.size) chunks.push(e.data); };

  recorder.onstop = () => {
    const blob = new Blob(chunks, { type: 'video/webm' });
    const a = document.createElement('a');
    a.download = 'mockup-' + Date.now() + '.webm';
    a.href = URL.createObjectURL(blob);
    a.click();
    isExporting = false;
    exportBtn.textContent = 'Export';
    exportBtn.classList.remove('recording');
    exportStatus.classList.remove('visible');
    if (exportRAF) cancelAnimationFrame(exportRAF);
    showToast('Export complete ‚Äî WebM downloaded', 'success');
  };

  // Play from trim start
  video.loop = false;
  video.currentTime = state.timeline.trimIn * video.duration;
  video.playbackRate = state.timeline.speed;
  video.play();
  recorder.start(100);
  exportText.textContent = 'Recording...';
  showToast('Recording started...', 'info');

  const poll = setInterval(() => {
    if (!isExporting) { clearInterval(poll); return; }
    if (video.duration) {
      const trimDur = (state.timeline.trimOut - state.timeline.trimIn) * video.duration;
      const elapsed = video.currentTime - state.timeline.trimIn * video.duration;
      const p = Math.min(100, elapsed / trimDur * 100);
      exportBarFill.style.width = p + '%';
      exportText.textContent = 'Exporting... ' + Math.round(p) + '%';
    }
  }, 250);

  video.addEventListener('timeupdate', function checkEnd() {
    if (video.currentTime >= state.timeline.trimOut * video.duration) {
      video.removeEventListener('timeupdate', checkEnd);
      setTimeout(() => stopExport(), 400);
    }
  });

  video.addEventListener('ended', function onEnd() {
    video.removeEventListener('ended', onEnd);
    setTimeout(() => stopExport(), 400);
  });
}

function stopExport() {
  if (recorder && recorder.state !== 'inactive') recorder.stop();
  video.loop = isLooping;
  video.playbackRate = state.timeline.speed;
  isExporting = false;
}

// ============================================================
// BACKGROUND TYPE + GRADIENT CONTROLS
// ============================================================
document.getElementById('bgType').addEventListener('change', e => {
  pushUndoState();
  const val = e.target.value;
  state.bgType = val;
  if (val === 'gradient') {
    state.gradient.enabled = true;
    document.getElementById('bgSolidControls').style.display = 'none';
    document.getElementById('bgGradientControls').style.display = 'block';
    canvasWrap.classList.remove('checker-bg');
  } else if (val === 'transparent') {
    state.gradient.enabled = false;
    document.getElementById('bgSolidControls').style.display = 'none';
    document.getElementById('bgGradientControls').style.display = 'none';
    canvasWrap.classList.add('checker-bg');
  } else {
    state.gradient.enabled = false;
    document.getElementById('bgSolidControls').style.display = 'block';
    document.getElementById('bgGradientControls').style.display = 'none';
    canvasWrap.classList.remove('checker-bg');
  }
});
document.getElementById('gradColor1').addEventListener('input', e => { state.gradient.color1 = e.target.value; });
document.getElementById('gradColor2').addEventListener('input', e => { state.gradient.color2 = e.target.value; });
document.getElementById('gradColor3').addEventListener('input', e => { state.gradient.color3 = e.target.value; });
document.getElementById('gradAngle').addEventListener('input', e => { state.gradient.angle = parseInt(e.target.value); });
document.getElementById('gradAnimated').addEventListener('change', e => { state.gradient.animated = e.target.value === 'true'; });

// ============================================================
// PARTICLE CONTROLS
// ============================================================
document.getElementById('particleType').addEventListener('change', e => {
  pushUndoState();
  if (e.target.value === 'off') { state.particles.enabled = false; }
  else { state.particles.enabled = true; state.particles.type = e.target.value; state._particles = []; }
});
document.getElementById('particleCount').addEventListener('input', e => { state.particles.count = parseInt(e.target.value); state._particles = []; });
document.getElementById('particleColor').addEventListener('input', e => { state.particles.color = e.target.value; });

// ============================================================
// ORBIT + MOTION BLUR CONTROLS
// ============================================================
document.getElementById('orbitToggle').addEventListener('change', e => {
  pushUndoState();
  state.orbit.enabled = e.target.value === 'true';
  if (!state.orbit.enabled) updatePerspective();
});
document.getElementById('orbitSpeed').addEventListener('input', e => { state.orbit.speed = parseInt(e.target.value) / 100; });
document.getElementById('motionBlurToggle').addEventListener('change', e => { pushUndoState(); state.motionBlur.enabled = e.target.value === 'true'; });

// ============================================================
// OVERLAY CONTROLS (Progress, Waveform, Glass)
// ============================================================
document.getElementById('progressToggle').addEventListener('change', e => { pushUndoState(); state.progressBar.enabled = e.target.value === 'true'; });
document.getElementById('progressColor').addEventListener('input', e => { state.progressBar.color = e.target.value; });
document.getElementById('waveformToggle').addEventListener('change', e => {
  pushUndoState();
  state.waveform.enabled = e.target.value === 'true';
  if (state.waveform.enabled) setupAudioAnalyser();
});
document.getElementById('waveformColor').addEventListener('input', e => { state.waveform.color = e.target.value; });
document.getElementById('glassToggle').addEventListener('change', e => {
  pushUndoState();
  state.glassmorphism.enabled = e.target.value === 'true';
  document.getElementById('glassControls').style.display = state.glassmorphism.enabled ? 'block' : 'none';
  state.glassmorphism.x = -1; state.glassmorphism.y = -1;
});
document.getElementById('glassText').addEventListener('input', e => { state.glassmorphism.text = e.target.value; });
document.getElementById('glassBlur').addEventListener('input', e => { state.glassmorphism.blur = parseInt(e.target.value); });
document.getElementById('glassOpacity').addEventListener('input', e => { state.glassmorphism.opacity = parseInt(e.target.value); });

// Drag glassmorphism overlay
let draggingGlass = false, glassDragOffset = { x:0, y:0 };
canvas.addEventListener('mousedown', e => {
  if (!state.glassmorphism.enabled) return;
  const rect = canvas.getBoundingClientRect();
  const sx = canvas.width / rect.width, sy = canvas.height / rect.height;
  const mx = (e.clientX - rect.left)*sx, my = (e.clientY - rect.top)*sy;
  const g = state.glassmorphism;
  if (mx >= g.x && mx <= g.x+g.width && my >= g.y && my <= g.y+g.height) {
    draggingGlass = true; glassDragOffset.x = mx - g.x; glassDragOffset.y = my - g.y;
    e.preventDefault(); e.stopPropagation();
  }
}, true);
canvas.addEventListener('mousemove', e => {
  if (!draggingGlass) return;
  const rect = canvas.getBoundingClientRect();
  const sx = canvas.width / rect.width, sy = canvas.height / rect.height;
  state.glassmorphism.x = (e.clientX - rect.left)*sx - glassDragOffset.x;
  state.glassmorphism.y = (e.clientY - rect.top)*sy - glassDragOffset.y;
}, true);
document.addEventListener('mouseup', () => { draggingGlass = false; }, true);

// ============================================================
// SCENE TEMPLATE GRID
// ============================================================
document.getElementById('sceneGrid').addEventListener('click', e => {
  const btn = e.target.closest('.dev-btn');
  if (!btn) return;
  pushUndoState();
  const scene = btn.dataset.scene;
  document.querySelectorAll('#sceneGrid .dev-btn').forEach(b => b.classList.remove('active'));
  btn.classList.add('active');
  applyScene(scene);
  showToast('Scene: ' + btn.textContent.trim() + ' applied', 'info');
});

// ============================================================
// CHROMA KEY CONTROLS
// ============================================================
document.getElementById('chromaToggle').addEventListener('change', e => {
  pushUndoState();
  state.chromaKey.enabled = e.target.value === 'true';
  document.getElementById('chromaControls').style.display = state.chromaKey.enabled ? 'block' : 'none';
});
document.getElementById('chromaColor').addEventListener('input', e => { state.chromaKey.color = e.target.value; });
document.getElementById('chromaTolerance').addEventListener('input', e => { state.chromaKey.tolerance = parseInt(e.target.value); });
document.getElementById('chromaSoftness').addEventListener('input', e => { state.chromaKey.softness = parseInt(e.target.value); });

// ============================================================
// CLEAR / RESET BUTTONS
// ============================================================
document.getElementById('clearLayersBtn').addEventListener('click', () => {
  state.layers = [];
  state.selectedLayer = -1;
  rebuildLayerList();
  document.getElementById('textProps').style.display = 'none';
  document.getElementById('logoProps').style.display = 'none';
});

document.getElementById('clearKeyframesBtn').addEventListener('click', () => {
  state.timeline.keyframes = [];
  rebuildTimeline();
});

document.getElementById('resetEffectsBtn').addEventListener('click', () => {
  // Reset particles
  state.particles.enabled = false;
  state._particles = [];
  document.getElementById('particleType').value = 'off';
  // Reset orbit
  state.orbit.enabled = false;
  document.getElementById('orbitToggle').value = 'false';
  updatePerspective();
  // Reset motion blur
  state.motionBlur.enabled = false;
  document.getElementById('motionBlurToggle').value = 'false';
});

// Reset Scene Templates
document.getElementById('resetSceneBtn').addEventListener('click', () => {
  state.scene = 'custom';
  state.gradient.enabled = false;
  state.particles.enabled = false;
  state._particles = [];
  state.orbit.enabled = false;
  document.getElementById('particleType').value = 'off';
  document.getElementById('orbitToggle').value = 'false';
  document.getElementById('bgType').value = 'solid';
  state.bgType = 'solid';
  document.getElementById('bgSolidControls').style.display = 'block';
  document.getElementById('bgGradientControls').style.display = 'none';
  document.querySelectorAll('#sceneGrid .dev-btn').forEach(b => b.classList.remove('active'));
  document.querySelector('#sceneGrid .dev-btn[data-scene="custom"]').classList.add('active');
  updatePerspective();
});

// Reset Hand Overlay
document.getElementById('resetHandBtn').addEventListener('click', () => {
  state.hand.enabled = false;
  document.getElementById('handBtn').classList.remove('active');
  document.getElementById('handBtn').textContent = 'Enable Hand';
  document.getElementById('resetHandBtn').style.display = 'none';
});

// Reset Background
document.getElementById('resetBgBtn').addEventListener('click', () => {
  state.bgType = 'solid';
  state.background = { color: '#0a0a0a' };
  state.gradient.enabled = false;
  state.shadow = 0.6;
  document.getElementById('bgType').value = 'solid';
  document.getElementById('bgColor').value = '#0a0a0a';
  document.getElementById('bgSolidControls').style.display = 'block';
  document.getElementById('bgGradientControls').style.display = 'none';
  document.getElementById('shadowSlider').value = 60;
  document.getElementById('gradColor1').value = '#0f0c29';
  document.getElementById('gradColor2').value = '#302b63';
  document.getElementById('gradColor3').value = '#24243e';
  document.getElementById('gradAngle').value = 135;
  document.getElementById('gradAnimated').value = 'false';
  const cw = document.getElementById('canvasWrap');
  cw.classList.remove('checker-bg');
  // Also remove bg video
  state.bgVideo.enabled = false;
  const bgVidEl = document.getElementById('bgVideo');
  if (bgVidEl.src) { bgVidEl.pause(); URL.revokeObjectURL(bgVidEl.src); bgVidEl.removeAttribute('src'); }
  document.getElementById('removeBgVideoBtn').style.display = 'none';
  document.getElementById('bgVideoControls').style.display = 'none';
  document.getElementById('bgVideoStatus').textContent = '';
  document.getElementById('loadBgVideoBtn').style.display = 'block';
});

// ============================================================
// BACKGROUND VIDEO
// ============================================================
document.getElementById('loadBgVideoBtn').addEventListener('click', () => document.getElementById('bgVideoInput').click());

document.getElementById('bgVideoInput').addEventListener('change', e => {
  const file = e.target.files[0];
  if (!file) return;
  const bgVid = document.getElementById('bgVideo');
  if (bgVid.src) URL.revokeObjectURL(bgVid.src);
  bgVid.src = URL.createObjectURL(file);
  bgVid.load();
  bgVid.addEventListener('loadedmetadata', function onMeta() {
    bgVid.removeEventListener('loadedmetadata', onMeta);
    state.bgVideo.enabled = true;
    document.getElementById('bgVideoStatus').textContent = file.name + ' (' + bgVid.videoWidth + 'x' + bgVid.videoHeight + ')';
    document.getElementById('bgVideoControls').style.display = 'block';
    document.getElementById('removeBgVideoBtn').style.display = '';
    document.getElementById('loadBgVideoBtn').style.display = 'none';
    // Auto-play synced with main video
    if (hasVideo && !video.paused) bgVid.play();
    else bgVid.play(); // play anyway for preview
  });
  e.target.value = '';
});

document.getElementById('removeBgVideoBtn').addEventListener('click', () => {
  state.bgVideo.enabled = false;
  const bgVid = document.getElementById('bgVideo');
  bgVid.pause();
  if (bgVid.src) URL.revokeObjectURL(bgVid.src);
  bgVid.removeAttribute('src');
  document.getElementById('bgVideoStatus').textContent = '';
  document.getElementById('bgVideoControls').style.display = 'none';
  document.getElementById('removeBgVideoBtn').style.display = 'none';
  document.getElementById('loadBgVideoBtn').style.display = 'block';
});

document.getElementById('bgVideoOpacity').addEventListener('input', e => {
  state.bgVideo.opacity = parseInt(e.target.value) / 100;
  document.getElementById('bgVideoOpacityVal').textContent = e.target.value + '%';
});

document.getElementById('bgVideoFit').addEventListener('change', e => {
  state.bgVideo.fit = e.target.value;
});

// Reset Chroma Key
document.getElementById('resetChromaBtn').addEventListener('click', () => {
  state.chromaKey.enabled = false;
  state.chromaKey.color = '#00ff00';
  state.chromaKey.tolerance = 80;
  state.chromaKey.softness = 10;
  document.getElementById('chromaToggle').value = 'false';
  document.getElementById('chromaControls').style.display = 'none';
  document.getElementById('chromaColor').value = '#00ff00';
  document.getElementById('chromaTolerance').value = 80;
  document.getElementById('chromaSoftness').value = 10;
});

// Clear Annotations
document.getElementById('clearAnnotationsBtn').addEventListener('click', () => {
  state.layers = state.layers.filter(l => l.type !== 'annotation');
});

// Reset Device Transform
document.getElementById('resetTransformBtn').addEventListener('click', () => {
  state.device.scale = 0.45;
  state.device.tiltX = 0;
  state.device.tiltY = 0;
  document.getElementById('scaleSlider').value = 45;
  document.getElementById('scaleVal').textContent = '45%';
  document.getElementById('tiltX').value = 0;
  document.getElementById('tiltY').value = 0;
  updatePerspective();
  updateDisplaySize();
});

// ============================================================
// VIDEO OVERLAY CONTROLS
// ============================================================
document.getElementById('builtinOverlayGrid').addEventListener('click', e => {
  const btn = e.target.closest('.dev-btn');
  if (!btn) return;
  pushUndoState();
  const type = btn.dataset.builtin;
  // Toggle ‚Äî if already active, remove it
  const existing = state.videoOverlays.findIndex(ov => ov.builtin === type);
  if (existing >= 0) {
    state.videoOverlays.splice(existing, 1);
    btn.classList.remove('active');
    rebuildOverlayList();
    return;
  }
  const ov = { id: Date.now(), builtin: type, name: btn.textContent, opacity: 0.5, blendMode: 'screen' };
  state.videoOverlays.push(ov);
  btn.classList.add('active');
  rebuildOverlayList();
});

document.getElementById('addVideoOverlayBtn').addEventListener('click', () => document.getElementById('videoOverlayInput').click());
document.getElementById('videoOverlayInput').addEventListener('change', e => {
  for (const file of e.target.files) {
    if (!file.type.startsWith('video/')) continue;
    const vid = document.createElement('video');
    vid.src = URL.createObjectURL(file);
    vid.loop = true;
    vid.muted = true;
    vid.playsInline = true;
    vid.play();
    const ov = { id: Date.now() + Math.random(), video: vid, name: file.name, opacity: 0.5, blendMode: 'screen' };
    state.videoOverlays.push(ov);
    rebuildOverlayList();
  }
  e.target.value = '';
});
document.getElementById('clearVideoOverlaysBtn').addEventListener('click', () => {
  for (const ov of state.videoOverlays) {
    if (ov.video) { ov.video.pause(); URL.revokeObjectURL(ov.video.src); }
  }
  state.videoOverlays = [];
  document.querySelectorAll('#builtinOverlayGrid .dev-btn').forEach(b => b.classList.remove('active'));
  rebuildOverlayList();
});

function rebuildOverlayList() {
  const list = document.getElementById('videoOverlayList');
  list.innerHTML = '';
  state.videoOverlays.forEach((ov, i) => {
    const row = document.createElement('div');
    row.style.cssText = 'margin-bottom:8px;padding:6px;background:rgba(255,255,255,0.03);border-radius:6px;border:1px solid rgba(255,255,255,0.06)';
    row.innerHTML = `
      <div style="display:flex;align-items:center;justify-content:space-between;margin-bottom:4px">
        <span style="font-size:9px;color:#aaa;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;max-width:120px">${ov.name}</span>
        <button class="btn btn-danger" data-ov-remove="${i}" style="padding:2px 6px;font-size:8px">X</button>
      </div>
      <div class="prop-row" style="margin-bottom:2px"><label style="font-size:9px">Blend</label>
        <select data-ov-blend="${i}" style="font-size:9px;background:rgba(255,255,255,0.07);border:1px solid rgba(255,255,255,0.1);border-radius:4px;color:#ccc;padding:2px 4px">
          <option value="screen"${ov.blendMode==='screen'?' selected':''}>Screen</option>
          <option value="lighter"${ov.blendMode==='lighter'?' selected':''}>Add</option>
          <option value="overlay"${ov.blendMode==='overlay'?' selected':''}>Overlay</option>
          <option value="multiply"${ov.blendMode==='multiply'?' selected':''}>Multiply</option>
          <option value="soft-light"${ov.blendMode==='soft-light'?' selected':''}>Soft Light</option>
          <option value="color-dodge"${ov.blendMode==='color-dodge'?' selected':''}>Dodge</option>
          <option value="source-over"${ov.blendMode==='source-over'?' selected':''}>Normal</option>
        </select>
      </div>
      <div class="prop-row"><label style="font-size:9px">Opacity</label>
        <input type="range" data-ov-opacity="${i}" min="0" max="100" value="${Math.round(ov.opacity*100)}" style="flex:1">
        <span style="font-size:8px;color:#666;min-width:24px">${Math.round(ov.opacity*100)}%</span>
      </div>
    `;
    list.appendChild(row);
  });
  // Bind events
  list.querySelectorAll('[data-ov-remove]').forEach(btn => {
    btn.addEventListener('click', e => {
      const idx = parseInt(e.target.dataset.ovRemove);
      const ov = state.videoOverlays[idx];
      ov.video.pause(); URL.revokeObjectURL(ov.video.src);
      state.videoOverlays.splice(idx, 1);
      rebuildOverlayList();
    });
  });
  list.querySelectorAll('[data-ov-blend]').forEach(sel => {
    sel.addEventListener('change', e => {
      state.videoOverlays[parseInt(e.target.dataset.ovBlend)].blendMode = e.target.value;
    });
  });
  list.querySelectorAll('[data-ov-opacity]').forEach(slider => {
    slider.addEventListener('input', e => {
      const idx = parseInt(e.target.dataset.ovOpacity);
      state.videoOverlays[idx].opacity = parseInt(e.target.value) / 100;
      e.target.nextElementSibling.textContent = e.target.value + '%';
    });
  });
}

// Sync overlay playback with main video
function syncOverlays() {
  if (!hasVideo) return;
  for (const ov of state.videoOverlays) {
    if (video.paused && !ov.video.paused) ov.video.pause();
    else if (!video.paused && ov.video.paused) ov.video.play();
  }
}

// ============================================================
// LUT PRESET GENERATOR
// ============================================================
function generateLUTPreset(type) {
  const size = 8;
  const data = new Float32Array(size * size * size * 3);
  for (let b = 0; b < size; b++) {
    for (let g = 0; g < size; g++) {
      for (let r = 0; r < size; r++) {
        const idx = (b * size * size + g * size + r) * 3;
        let rf = r / (size - 1), gf = g / (size - 1), bf = b / (size - 1);
        if (type === 'cinematic') {
          // Lift shadows (blue), crush blacks slightly, warm highlights
          rf = Math.pow(rf, 0.95) * 1.05;
          gf = Math.pow(gf, 1.0) * 0.95;
          bf = Math.pow(bf, 0.85) * 0.9 + 0.05;
          // Desaturate shadows
          const lum = 0.299*rf + 0.587*gf + 0.114*bf;
          const shadowMix = Math.max(0, 1 - lum * 2.5);
          rf = rf + (lum - rf) * shadowMix * 0.3;
          gf = gf + (lum - gf) * shadowMix * 0.3;
        } else if (type === 'warmVintage') {
          rf = Math.pow(rf, 0.85) * 1.1;
          gf = Math.pow(gf, 0.95) * 0.95;
          bf = Math.pow(bf, 1.15) * 0.8;
          // Fade blacks
          rf = rf * 0.9 + 0.06; gf = gf * 0.88 + 0.04; bf = bf * 0.85 + 0.03;
        } else if (type === 'coolTeal') {
          rf = Math.pow(rf, 1.1) * 0.85;
          gf = Math.pow(gf, 0.95) * 1.0;
          bf = Math.pow(bf, 0.9) * 1.1;
          // Add teal to midtones
          const mid = Math.sin(gf * Math.PI);
          gf += mid * 0.06; bf += mid * 0.08;
        } else if (type === 'bleachBypass') {
          const lum = 0.299*rf + 0.587*gf + 0.114*bf;
          rf = rf + (lum - rf) * 0.5;
          gf = gf + (lum - gf) * 0.5;
          bf = bf + (lum - bf) * 0.5;
          // High contrast
          rf = Math.pow(rf, 1.3); gf = Math.pow(gf, 1.3); bf = Math.pow(bf, 1.3);
        } else if (type === 'moody') {
          rf = Math.pow(rf, 1.2) * 0.9;
          gf = Math.pow(gf, 1.15) * 0.85;
          bf = Math.pow(bf, 0.95) * 0.95;
          // Crush blacks, tint shadows blue
          const dark = Math.max(0, 1 - (rf + gf + bf));
          bf += dark * 0.08;
          rf = rf * 0.92 + 0.02; gf = gf * 0.9 + 0.015; bf = bf * 0.93 + 0.03;
        } else if (type === 'orangeTeal') {
          // Push shadows teal, highlights orange
          const lum = 0.299*rf + 0.587*gf + 0.114*bf;
          if (lum < 0.5) {
            rf -= (0.5 - lum) * 0.15;
            gf += (0.5 - lum) * 0.05;
            bf += (0.5 - lum) * 0.15;
          } else {
            rf += (lum - 0.5) * 0.2;
            gf += (lum - 0.5) * 0.05;
            bf -= (lum - 0.5) * 0.15;
          }
          rf = Math.pow(Math.max(0, rf), 0.95);
          gf = Math.pow(Math.max(0, gf), 1.0);
          bf = Math.pow(Math.max(0, bf), 1.05);
        } else if (type === 'bw') {
          const lum = 0.299*rf + 0.587*gf + 0.114*bf;
          // Film-like B&W with slight warm tone
          rf = Math.pow(lum, 0.9) * 1.02;
          gf = Math.pow(lum, 0.95) * 0.98;
          bf = Math.pow(lum, 1.05) * 0.95;
        }
        data[idx] = Math.min(1, Math.max(0, rf));
        data[idx+1] = Math.min(1, Math.max(0, gf));
        data[idx+2] = Math.min(1, Math.max(0, bf));
      }
    }
  }
  return { size, data, title: type };
}

// ============================================================
// LUT CONTROLS
// ============================================================
document.getElementById('lutPresetGrid').addEventListener('click', e => {
  const btn = e.target.closest('.dev-btn');
  if (!btn) return;
  pushUndoState();
  const preset = btn.dataset.lutPreset;
  document.querySelectorAll('#lutPresetGrid .dev-btn').forEach(b => b.classList.remove('active'));
  if (preset === 'none') {
    state.lut = { enabled: false, data: null, size: 0, intensity: 1.0, name: '', _presetKey: '' };
    document.getElementById('lutInfo').textContent = '';
    document.getElementById('lutControls').style.display = 'none';
    return;
  }
  btn.classList.add('active');
  const lut = generateLUTPreset(preset);
  state.lut.data = lut;
  state.lut.size = lut.size;
  state.lut.enabled = true;
  state.lut.name = btn.textContent;
  state.lut._presetKey = preset;
  document.getElementById('lutInfo').innerHTML = '<span style="color:#4ade80">Active:</span> ' + btn.textContent;
  document.getElementById('lutControls').style.display = 'block';
  showToast('Color grade: ' + btn.textContent + ' applied', 'info');
});

document.getElementById('loadLutBtn').addEventListener('click', () => document.getElementById('lutFileInput').click());
document.getElementById('lutFileInput').addEventListener('change', e => {
  const file = e.target.files[0];
  if (!file) return;
  pushUndoState();
  const reader = new FileReader();
  reader.onload = () => {
    const lut = parseCubeLUT(reader.result);
    if (!lut) { document.getElementById('lutInfo').textContent = 'Invalid .CUBE file'; return; }
    state.lut.data = lut;
    state.lut.size = lut.size;
    state.lut.enabled = true;
    state.lut.name = lut.title || file.name;
    state.lut._presetKey = '';
    document.getElementById('lutInfo').innerHTML = '<span style="color:#4ade80">Loaded:</span> ' + state.lut.name + ' (' + lut.size + 'x' + lut.size + 'x' + lut.size + ')';
    document.getElementById('lutControls').style.display = 'block';
    showToast('Color grade: ' + state.lut.name + ' applied', 'info');
  };
  reader.readAsText(file);
  e.target.value = '';
});
document.getElementById('clearLutBtn').addEventListener('click', () => {
  pushUndoState();
  state.lut = { enabled: false, data: null, size: 0, intensity: 1.0, name: '' };
  document.getElementById('lutInfo').textContent = '';
  document.getElementById('lutControls').style.display = 'none';
  document.querySelectorAll('#lutPresetGrid .dev-btn').forEach(b => b.classList.remove('active'));
});
document.getElementById('lutIntensity').addEventListener('input', e => {
  state.lut.intensity = parseInt(e.target.value) / 100;
  document.getElementById('lutIntensityVal').textContent = e.target.value + '%';
});

// ============================================================
// ANIMATION PRESET CONTROLS
// ============================================================
document.getElementById('animPresetGrid').addEventListener('click', e => {
  const btn = e.target.closest('.dev-btn');
  if (!btn) return;
  pushUndoState();
  const anim = btn.dataset.anim;
  state.animPreset.type = anim;
  document.querySelectorAll('#animPresetGrid .dev-btn').forEach(b => b.classList.remove('active'));
  btn.classList.add('active');
});

document.getElementById('clearAnimPresetBtn').addEventListener('click', () => {
  state.animPreset.type = 'none';
  document.querySelectorAll('#animPresetGrid .dev-btn').forEach(b => b.classList.remove('active'));
  document.querySelector('#animPresetGrid .dev-btn[data-anim="none"]').classList.add('active');
});

document.getElementById('animIntensity').addEventListener('input', e => {
  state.animPreset.intensity = parseInt(e.target.value) / 100;
});

document.getElementById('animBPM').addEventListener('input', e => {
  state.animPreset.bpm = parseInt(e.target.value);
  document.getElementById('animBPMVal').textContent = e.target.value;
});

// CapCut Draft Import
document.getElementById('importCapcutBtn').addEventListener('click', () => {
  document.getElementById('capcutFileInput').click();
});

document.getElementById('capcutFileInput').addEventListener('change', e => {
  const file = e.target.files[0];
  if (!file) return;
  const reader = new FileReader();
  reader.onload = ev => {
    try {
      const json = JSON.parse(ev.target.result);
      importedKeyframes = parseCapcutDraft(json);
      if (importedKeyframes.length > 0) {
        state.animPreset.type = 'capcut_imported';
        document.querySelectorAll('#animPresetGrid .dev-btn').forEach(b => b.classList.remove('active'));
        // Show feedback
        const statusEl = document.getElementById('importCapcutBtn');
        statusEl.textContent = `Imported ${importedKeyframes.length} keyframes`;
        statusEl.style.borderColor = 'rgba(96,165,250,0.4)';
        setTimeout(() => {
          statusEl.textContent = 'Import CapCut Draft';
          statusEl.style.borderColor = '';
        }, 3000);
      } else {
        alert('No animation keyframes found in this file. Make sure it is a draft_content.json from a CapCut Desktop project.');
      }
    } catch (err) {
      alert('Could not parse file: ' + err.message);
    }
  };
  reader.readAsText(file);
});

document.getElementById('resetOverlaysBtn').addEventListener('click', () => {
  // Reset progress bar
  state.progressBar.enabled = false;
  document.getElementById('progressToggle').value = 'false';
  // Reset waveform
  state.waveform.enabled = false;
  document.getElementById('waveformToggle').value = 'false';
  // Reset glassmorphism
  state.glassmorphism.enabled = false;
  state.glassmorphism.x = -1;
  state.glassmorphism.y = -1;
  document.getElementById('glassToggle').value = 'false';
  document.getElementById('glassControls').style.display = 'none';
});

// ============================================================
// ASSET BROWSER
// ============================================================
const assetBrowser = document.getElementById('assetBrowser');
const abSidebar = document.getElementById('abSidebar');
const abContent = document.getElementById('abContent');
const abEmpty = document.getElementById('abEmpty');
const abSearch = document.getElementById('abSearch');

let abDirHandle = null;
let abIndex = []; // { path, name, type, ext, handle, parentPath }
let abFolders = []; // { path, name, count, icon }
let abCurrentFolder = '';
let abSearchTerm = '';

document.getElementById('assetBrowserBtn').addEventListener('click', () => {
  assetBrowser.classList.add('open');
  if (abDirHandle) renderAssetBrowser();
});
document.getElementById('abClose').addEventListener('click', () => assetBrowser.classList.remove('open'));
document.addEventListener('keydown', e => { if (e.key === 'Escape' && assetBrowser.classList.contains('open')) assetBrowser.classList.remove('open'); });

document.getElementById('abPickFolder').addEventListener('click', pickAssetFolder);

async function pickAssetFolder() {
  try {
    abDirHandle = await window.showDirectoryPicker({ mode: 'read' });
    abIndex = [];
    abFolders = [];
    abContent.innerHTML = '<div class="ab-loading">Scanning folder...</div>';
    abSidebar.innerHTML = '';
    await scanDirectory(abDirHandle, '');
    buildFolderTree();
    renderAssetBrowser();
  } catch (e) {
    if (e.name !== 'AbortError') console.error('Folder pick error:', e);
  }
}

async function scanDirectory(dirHandle, path) {
  const entries = [];
  for await (const entry of dirHandle.values()) entries.push(entry);
  // Sort: folders first, then files
  entries.sort((a, b) => {
    if (a.kind !== b.kind) return a.kind === 'directory' ? -1 : 1;
    return a.name.localeCompare(b.name);
  });
  for (const entry of entries) {
    if (entry.name.startsWith('.')) continue;
    const fullPath = path ? path + '/' + entry.name : entry.name;
    if (entry.kind === 'directory') {
      await scanDirectory(entry, fullPath);
    } else {
      const ext = entry.name.split('.').pop().toLowerCase();
      let type = 'other';
      if (ext === 'cube') type = 'lut';
      else if (['mp4','mov','webm','m4v'].includes(ext)) type = 'video';
      else if (['png','jpg','jpeg','webp','gif'].includes(ext)) type = 'image';
      else if (['mp3','wav','aac','ogg','m4a'].includes(ext)) type = 'audio';
      else if (['prproj','aep','mogrt','prfpset','ffx'].includes(ext)) type = 'preset';
      else if (['ttf','otf','woff','woff2'].includes(ext)) type = 'font';
      if (type !== 'other') {
        abIndex.push({ path: fullPath, name: entry.name, type, ext, handle: entry, parentPath: path });
      }
    }
  }
}

function buildFolderTree() {
  const folderMap = {};
  // Root
  folderMap[''] = { path: '', name: 'All Assets', count: abIndex.length, icon: 'üìÇ' };
  // Type filters
  const types = { lut: 'üé®', video: 'üé¨', image: 'üñº', audio: 'üîä', preset: '‚öôÔ∏è', font: 'üî§' };
  const typeNames = { lut: 'LUTs (.cube)', video: 'Videos', image: 'Images', audio: 'Audio/SFX', preset: 'Presets', font: 'Fonts' };
  for (const [t, icon] of Object.entries(types)) {
    const count = abIndex.filter(f => f.type === t).length;
    if (count > 0) folderMap['__type__' + t] = { path: '__type__' + t, name: typeNames[t], count, icon };
  }
  // Actual folders (first level only for cleanliness)
  const topFolders = new Set();
  for (const f of abIndex) {
    const parts = f.parentPath.split('/');
    if (parts[0]) topFolders.add(parts[0]);
  }
  for (const folder of [...topFolders].sort()) {
    const count = abIndex.filter(f => f.parentPath === folder || f.parentPath.startsWith(folder + '/')).length;
    if (count > 0) {
      let icon = 'üìÅ';
      const fl = folder.toLowerCase();
      if (fl.includes('lut')) icon = 'üé®';
      else if (fl.includes('light') || fl.includes('leak') || fl.includes('glow') || fl.includes('flare')) icon = '‚ú®';
      else if (fl.includes('film') || fl.includes('burn') || fl.includes('vhs')) icon = 'üéû';
      else if (fl.includes('smoke') || fl.includes('fog') || fl.includes('cloud')) icon = 'üå´';
      else if (fl.includes('sfx') || fl.includes('sound')) icon = 'üîä';
      else if (fl.includes('font')) icon = 'üî§';
      else if (fl.includes('transition')) icon = 'üîÄ';
      else if (fl.includes('particle') || fl.includes('spark')) icon = '‚≠ê';
      else if (fl.includes('overlay')) icon = 'üî≤';
      else if (fl.includes('background') || fl.includes('motion')) icon = 'üé≠';
      else if (fl.includes('text') || fl.includes('title')) icon = 'üìù';
      else if (fl.includes('emoji') || fl.includes('sticker')) icon = 'üòÄ';
      else if (fl.includes('glitch')) icon = '‚ö°';
      else if (fl.includes('icon')) icon = 'üíé';
      folderMap['__folder__' + folder] = { path: '__folder__' + folder, name: folder, count, icon };
    }
  }
  abFolders = Object.values(folderMap);
}

function renderAssetBrowser() {
  // Sidebar
  abSidebar.innerHTML = abFolders.map(f =>
    `<div class="ab-folder${abCurrentFolder === f.path ? ' active' : ''}" data-ab-folder="${f.path}">
      <span class="ab-icon">${f.icon}</span>
      <span>${f.name}</span>
      <span class="ab-count">${f.count}</span>
    </div>`
  ).join('');

  abSidebar.querySelectorAll('.ab-folder').forEach(el => {
    el.addEventListener('click', () => {
      abCurrentFolder = el.dataset.abFolder;
      renderAssetBrowser();
    });
  });

  // Filter items
  let items = abIndex;
  if (abCurrentFolder.startsWith('__type__')) {
    const t = abCurrentFolder.replace('__type__', '');
    items = items.filter(f => f.type === t);
  } else if (abCurrentFolder.startsWith('__folder__')) {
    const folder = abCurrentFolder.replace('__folder__', '');
    items = items.filter(f => f.parentPath === folder || f.parentPath.startsWith(folder + '/'));
  }
  if (abSearchTerm) {
    const q = abSearchTerm.toLowerCase();
    items = items.filter(f => f.name.toLowerCase().includes(q) || f.path.toLowerCase().includes(q));
  }

  // Breadcrumb + content
  const badgeClass = { lut: 'ab-badge-lut', video: 'ab-badge-video', image: 'ab-badge-image', audio: 'ab-badge-audio' };
  const badgeLabel = { lut: 'LUT', video: 'VID', image: 'IMG', audio: 'SFX', preset: 'PRE', font: 'FONT' };
  const typeIcon = { lut: 'üé®', video: 'üé¨', image: 'üñº', audio: 'üîä', preset: '‚öôÔ∏è', font: 'üî§' };

  if (items.length === 0 && !abDirHandle) return;

  abContent.innerHTML = `
    <div class="ab-breadcrumb">
      <span data-ab-nav="">All Assets</span>
      ${abCurrentFolder ? `<span class="ab-sep">/</span><span>${abFolders.find(f => f.path === abCurrentFolder)?.name || abCurrentFolder}</span>` : ''}
      <span style="margin-left:auto;color:#555;font-size:9px">${items.length} items</span>
    </div>
    <div class="ab-grid">
      ${items.map((f, i) => `
        <div class="ab-item" data-ab-idx="${abIndex.indexOf(f)}">
          <div class="ab-item-preview">
            ${typeIcon[f.type] || 'üìÑ'}
            <span class="ab-badge ${badgeClass[f.type] || ''}">${badgeLabel[f.type] || f.ext}</span>
          </div>
          <div class="ab-item-info">
            <div class="ab-item-name" title="${f.name}">${f.name}</div>
            <div class="ab-item-type">${f.parentPath || 'Root'}</div>
          </div>
        </div>
      `).join('')}
    </div>
  `;

  // Breadcrumb nav
  abContent.querySelectorAll('[data-ab-nav]').forEach(el => {
    el.addEventListener('click', () => { abCurrentFolder = el.dataset.abNav || ''; renderAssetBrowser(); });
  });

  // Item clicks
  abContent.querySelectorAll('.ab-item').forEach(el => {
    el.addEventListener('click', async () => {
      const idx = parseInt(el.dataset.abIdx);
      const item = abIndex[idx];
      if (!item) return;
      await loadAssetItem(item);
    });
  });

  // Load thumbnail previews for images (lazy, first 50 only)
  const imageItems = items.filter(f => f.type === 'image');
  imageItems.slice(0, 50).forEach(async (f) => {
    try {
      const file = await f.handle.getFile();
      const url = URL.createObjectURL(file);
      const idx = abIndex.indexOf(f);
      const previewEl = abContent.querySelector(`[data-ab-idx="${idx}"] .ab-item-preview`);
      if (previewEl) previewEl.innerHTML = `<img src="${url}"><span class="ab-badge ${badgeClass[f.type] || ''}">${badgeLabel[f.type]}</span>`;
    } catch(e) {}
  });
}

async function loadAssetItem(item) {
  try {
    const file = await item.handle.getFile();

    if (item.type === 'lut') {
      // Load as LUT
      const text = await file.text();
      const lut = parseCubeLUT(text);
      if (!lut) { alert('Invalid .CUBE LUT file'); return; }
      state.lut.data = lut;
      state.lut.size = lut.size;
      state.lut.enabled = true;
      state.lut.name = lut.title || item.name;
      document.getElementById('lutInfo').innerHTML = '<span style="color:#4ade80">Loaded:</span> ' + state.lut.name + ' (' + lut.size + '¬≥)';
      document.getElementById('lutControls').style.display = 'block';
      document.querySelectorAll('#lutPresetGrid .dev-btn').forEach(b => b.classList.remove('active'));
      showAssetToast('LUT loaded: ' + item.name);

    } else if (item.type === 'video') {
      // Load as video overlay
      const url = URL.createObjectURL(file);
      const vid = document.createElement('video');
      vid.src = url;
      vid.loop = true;
      vid.muted = true;
      vid.playsInline = true;
      vid.play();
      // Sync with main video if playing
      if (hasVideo && video.paused) vid.pause();
      const ov = { id: Date.now() + Math.random(), video: vid, name: item.name, opacity: 0.5, blendMode: 'screen' };
      state.videoOverlays.push(ov);
      rebuildOverlayList();
      showAssetToast('Overlay loaded: ' + item.name);

    } else if (item.type === 'image') {
      // Load as image overlay (static)
      const url = URL.createObjectURL(file);
      const img = new Image();
      img.src = url;
      img.onload = () => {
        // Add as a logo layer
        const layer = {
          id: state.nextLayerId++,
          type: 'logo', img: img, name: item.name,
          x: 100, y: 100, width: 200, opacity: 0.8
        };
        state.layers.push(layer);
        state.selectedLayer = state.layers.length - 1;
        showAssetToast('Image overlay loaded: ' + item.name);
      };

    } else if (item.type === 'audio') {
      // Load as background audio
      const url = URL.createObjectURL(file);
      const audio = new Audio(url);
      audio.loop = true;
      audio.volume = 0.5;
      audio.play();
      showAssetToast('Audio playing: ' + item.name);
    }

    // Close browser after loading
    assetBrowser.classList.remove('open');
  } catch (e) {
    console.error('Error loading asset:', e);
    alert('Could not load: ' + item.name);
  }
}

function showAssetToast(msg) { showToast(msg, 'success'); }

// Search
abSearch.addEventListener('input', e => {
  abSearchTerm = e.target.value.trim();
  if (abDirHandle) renderAssetBrowser();
});

// ============================================================
// SESSION PERSISTENCE (localStorage)
// ============================================================
const STORAGE_KEY = 'mockupStudioState';

function getSerializableState() {
  return {
    device: { type: state.device.type, color: state.device.color, landscape: state.device.landscape, scale: state.device.scale },
    videoFit: state.videoFit,
    perspective: { x: state.perspective.x, y: state.perspective.y },
    background: { color: state.background.color },
    shadow: state.shadow,
    preset: state.preset,
    bgType: state.bgType,
    gradient: { ...state.gradient },
    particles: { enabled: state.particles.enabled, type: state.particles.type, count: state.particles.count, color: state.particles.color, speed: state.particles.speed },
    orbit: { enabled: state.orbit.enabled, speed: state.orbit.speed, axis: state.orbit.axis, range: state.orbit.range },
    motionBlur: { enabled: state.motionBlur.enabled, amount: state.motionBlur.amount },
    entrance: { type: state.entrance.type, duration: state.entrance.duration },
    animPreset: { type: state.animPreset.type, intensity: state.animPreset.intensity, bpm: state.animPreset.bpm },
    scene: state.scene,
    chromaKey: { enabled: state.chromaKey.enabled, color: state.chromaKey.color, tolerance: state.chromaKey.tolerance, softness: state.chromaKey.softness },
    lut: { enabled: state.lut.enabled, intensity: state.lut.intensity, name: state.lut.name, presetKey: state.lut._presetKey || '' },
    waveform: { enabled: state.waveform.enabled, color: state.waveform.color, height: state.waveform.height, position: state.waveform.position, style: state.waveform.style },
    progressBar: { enabled: state.progressBar.enabled, color: state.progressBar.color, height: state.progressBar.height, position: state.progressBar.position },
    glassmorphism: { enabled: state.glassmorphism.enabled, text: state.glassmorphism.text, blur: state.glassmorphism.blur, opacity: state.glassmorphism.opacity },
    hand: { enabled: state.hand.enabled, style: state.hand.style },
    builtinOverlays: state.videoOverlays.filter(ov => ov.builtin).map(ov => ov.builtin),
    isLooping: isLooping,
    speed: state.timeline.speed,
  };
}

function saveState() {
  try {
    localStorage.setItem(STORAGE_KEY, JSON.stringify(getSerializableState()));
  } catch (e) { /* quota exceeded or private mode ‚Äî ignore */ }
}

let _saveTimer = null;
function scheduleSave() {
  clearTimeout(_saveTimer);
  _saveTimer = setTimeout(saveState, 500);
}

function applyStateToUI(s) {
  // Device
  state.device.type = s.device.type;
  state.device.color = s.device.color;
  state.device.landscape = s.device.landscape || false;
  state.device.scale = s.device.scale;
  deviceGrid.querySelectorAll('.dev-btn').forEach(b => {
    b.classList.toggle('active', b.dataset.device === s.device.type);
  });
  if (s.device.landscape) document.getElementById('landscapeBtn').classList.add('active');
  updateColorSwatches();
  frameCache = {};

  // Video fit
  state.videoFit = s.videoFit || 'cover';
  document.getElementById('videoFitMode').value = state.videoFit;

  // Perspective
  state.perspective.x = s.perspective.x;
  state.perspective.y = s.perspective.y;
  document.getElementById('tiltX').value = s.perspective.x;
  document.getElementById('tiltY').value = s.perspective.y;

  // Background
  state.background.color = s.background.color;
  state.bgType = s.bgType;
  document.getElementById('bgColor').value = s.background.color;
  document.getElementById('bgType').value = s.bgType;
  document.getElementById('bgSolidControls').style.display = s.bgType === 'solid' ? 'block' : 'none';
  document.getElementById('bgGradientControls').style.display = s.bgType === 'gradient' ? 'block' : 'none';

  // Gradient
  Object.assign(state.gradient, s.gradient);
  document.getElementById('gradColor1').value = s.gradient.color1;
  document.getElementById('gradColor2').value = s.gradient.color2;
  document.getElementById('gradColor3').value = s.gradient.color3;
  document.getElementById('gradAngle').value = s.gradient.angle;
  document.getElementById('gradAnimated').value = String(s.gradient.animated);

  // Shadow & Scale
  state.shadow = s.shadow;
  state.device.scale = s.device.scale;
  document.getElementById('shadowSlider').value = Math.round(s.shadow * 100);
  document.getElementById('scaleSlider').value = Math.round(s.device.scale * 100);

  // Preset (canvas size)
  state.preset = s.preset;
  document.getElementById('presetSelect').value = s.preset;

  // Particles
  Object.assign(state.particles, s.particles);
  document.getElementById('particleType').value = s.particles.enabled ? s.particles.type : 'off';
  document.getElementById('particleCount').value = s.particles.count;
  document.getElementById('particleColor').value = s.particles.color;

  // Orbit
  Object.assign(state.orbit, s.orbit);
  document.getElementById('orbitToggle').value = String(s.orbit.enabled);
  document.getElementById('orbitSpeed').value = Math.round(s.orbit.speed * 100);

  // Motion blur
  state.motionBlur.enabled = s.motionBlur.enabled;
  state.motionBlur.amount = s.motionBlur.amount;
  document.getElementById('motionBlurToggle').value = String(s.motionBlur.enabled);

  // Entrance
  state.entrance.type = s.entrance.type;
  state.entrance.duration = s.entrance.duration;
  document.getElementById('entranceSelect').value = s.entrance.type;
  document.getElementById('entranceDur').value = s.entrance.duration;
  document.getElementById('entranceDurVal').textContent = (s.entrance.duration / 1000).toFixed(1) + 's';

  // Animation preset
  Object.assign(state.animPreset, s.animPreset);
  document.querySelectorAll('#animPresetGrid .dev-btn').forEach(b => {
    b.classList.toggle('active', b.dataset.anim === s.animPreset.type);
  });
  document.getElementById('animIntensity').value = Math.round(s.animPreset.intensity * 100);
  document.getElementById('animBPM').value = s.animPreset.bpm;
  document.getElementById('animBPMVal').textContent = s.animPreset.bpm;

  // Scene
  state.scene = s.scene;
  document.querySelectorAll('#sceneGrid .dev-btn').forEach(b => {
    b.classList.toggle('active', b.dataset.scene === s.scene);
  });

  // Chroma key
  Object.assign(state.chromaKey, s.chromaKey);
  document.getElementById('chromaToggle').value = String(s.chromaKey.enabled);
  document.getElementById('chromaColor').value = s.chromaKey.color;
  document.getElementById('chromaTolerance').value = s.chromaKey.tolerance;
  document.getElementById('chromaSoftness').value = s.chromaKey.softness;
  document.getElementById('chromaControls').style.display = s.chromaKey.enabled ? 'block' : 'none';

  // LUT ‚Äî restore preset if it was a built-in
  state.lut.intensity = s.lut.intensity;
  document.getElementById('lutIntensity').value = Math.round(s.lut.intensity * 100);
  document.getElementById('lutIntensityVal').textContent = Math.round(s.lut.intensity * 100) + '%';
  if (s.lut.presetKey && s.lut.presetKey !== 'none' && s.lut.presetKey !== '') {
    const lutBtn = document.querySelector('#lutPresetGrid .dev-btn[data-lut-preset="' + s.lut.presetKey + '"]');
    if (lutBtn) {
      lutBtn.click(); // triggers the existing handler which sets state.lut properly
    }
  }

  // Overlays (progress bar, waveform, glass CTA)
  if (s.progressBar) {
    Object.assign(state.progressBar, s.progressBar);
    document.getElementById('progressToggle').value = String(s.progressBar.enabled);
    document.getElementById('progressColor').value = s.progressBar.color;
  }
  if (s.waveform) {
    Object.assign(state.waveform, s.waveform);
    document.getElementById('waveformToggle').value = String(s.waveform.enabled);
    document.getElementById('waveformColor').value = s.waveform.color;
  }
  if (s.glassmorphism) {
    Object.assign(state.glassmorphism, s.glassmorphism);
    document.getElementById('glassToggle').value = String(s.glassmorphism.enabled);
    document.getElementById('glassControls').style.display = s.glassmorphism.enabled ? 'block' : 'none';
    document.getElementById('glassText').value = s.glassmorphism.text;
    document.getElementById('glassBlur').value = s.glassmorphism.blur;
    document.getElementById('glassOpacity').value = Math.round(s.glassmorphism.opacity * 100);
  }

  // Hand
  if (s.hand) {
    state.hand.enabled = s.hand.enabled;
    state.hand.style = s.hand.style;
    document.getElementById('handStyle').value = s.hand.style;
  }

  // Builtin overlays
  if (s.builtinOverlays && s.builtinOverlays.length) {
    state.videoOverlays = [];
    document.querySelectorAll('#builtinOverlayGrid .dev-btn').forEach(b => b.classList.remove('active'));
    for (const type of s.builtinOverlays) {
      const btn = document.querySelector('#builtinOverlayGrid .dev-btn[data-builtin="' + type + '"]');
      if (btn) {
        state.videoOverlays.push({ id: Date.now() + Math.random(), builtin: type, name: btn.textContent, opacity: 0.5, blendMode: 'screen' });
        btn.classList.add('active');
      }
    }
  }

  // Loop & speed
  if (typeof s.isLooping !== 'undefined') {
    isLooping = s.isLooping;
    video.loop = isLooping;
    loopBtn.classList.toggle('active', isLooping);
    loopBtn.textContent = isLooping ? 'Loop' : 'No Loop';
  }
  if (s.speed) {
    state.timeline.speed = s.speed;
    video.playbackRate = s.speed;
    document.getElementById('speedSelect').value = s.speed;
  }

  resizeCanvas();
}

function loadState() {
  try {
    const raw = localStorage.getItem(STORAGE_KEY);
    if (!raw) return;
    const s = JSON.parse(raw);
    if (!s || !s.device) return;
    applyStateToUI(s);
  } catch (e) { /* corrupt data ‚Äî ignore */ }
}

// Load saved state on startup
loadState();

// Auto-save: listen for input/change on all panels
document.querySelectorAll('.panel, .top-bar, .playback-bar').forEach(panel => {
  panel.addEventListener('input', scheduleSave);
  panel.addEventListener('change', scheduleSave);
  panel.addEventListener('click', scheduleSave);
});

// ============================================================
// PROJECT SAVE / LOAD / RESET
// ============================================================
document.getElementById('saveProjectBtn').addEventListener('click', () => {
  const data = JSON.stringify(getSerializableState(), null, 2);
  const blob = new Blob([data], { type: 'application/json' });
  const a = document.createElement('a');
  a.download = 'mockup-project-' + Date.now() + '.json';
  a.href = URL.createObjectURL(blob);
  a.click();
  showToast('Project saved', 'success');
});

document.getElementById('loadProjectBtn').addEventListener('click', () => {
  document.getElementById('projectFileInput').click();
});

document.getElementById('projectFileInput').addEventListener('change', e => {
  const file = e.target.files[0];
  if (!file) return;
  const reader = new FileReader();
  reader.onload = () => {
    try {
      const s = JSON.parse(reader.result);
      if (!s || !s.device) { showToast('Invalid project file', 'error'); return; }
      applyStateToUI(s);
      saveState();
      showToast('Project loaded: ' + file.name, 'success');
    } catch (err) {
      showToast('Failed to parse project file', 'error');
    }
  };
  reader.readAsText(file);
  e.target.value = '';
});

document.getElementById('resetAllBtn').addEventListener('click', () => {
  if (!confirm('Reset all settings to defaults? This cannot be undone.')) return;
  localStorage.removeItem(STORAGE_KEY);
  location.reload();
});

</script>
</body>
</html>
