<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Mockup Studio</title>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
<style>
/* Dark Theme (Default) */
:root {
  /* Backgrounds */
  --bg-app: #0a0a0a;
  --bg-panel: rgba(18, 18, 18, 0.7);
  --bg-elevated: #1a1a1a;
  --bg-hover: rgba(255, 255, 255, 0.08);
  --bg-active: rgba(255, 255, 255, 0.12);

  /* Accents */
  --accent-primary: #60a5fa;
  --accent-secondary: #a78bfa;
  --accent-success: #4ade80;
  --accent-warning: #fbbf24;
  --accent-error: #ef4444;

  /* Text */
  --text-primary: #e0e0e0;
  --text-secondary: #a0a0a0;
  --text-tertiary: #666666;

  /* Glass & Borders */
  --glass-bg: rgba(18, 18, 18, 0.7);
  --glass-border: rgba(255, 255, 255, 0.08);
  --border-strong: rgba(255, 255, 255, 0.12);
  --divider: rgba(255, 255, 255, 0.04);

  /* Shadows */
  --shadow-sm: 0 2px 8px rgba(0, 0, 0, 0.2);
  --shadow-md: 0 4px 16px rgba(0, 0, 0, 0.3);
  --shadow-lg: 0 8px 32px rgba(0, 0, 0, 0.5);

  /* Component-specific */
  --input-bg: rgba(255, 255, 255, 0.07);
  --input-border: rgba(255, 255, 255, 0.1);
  --button-bg: rgba(255, 255, 255, 0.07);
  --button-border: rgba(255, 255, 255, 0.1);
  --card-bg: rgba(255, 255, 255, 0.03);
  --card-border: rgba(255, 255, 255, 0.06);
}

/* Light Theme */
:root[data-theme="light"] {
  /* Backgrounds */
  --bg-app: #f5f5f7;
  --bg-panel: rgba(255, 255, 255, 0.85);
  --bg-elevated: #ffffff;
  --bg-hover: rgba(0, 0, 0, 0.05);
  --bg-active: rgba(0, 0, 0, 0.08);

  /* Accents */
  --accent-primary: #0071e3;
  --accent-secondary: #8e5cdb;
  --accent-success: #28a745;
  --accent-warning: #f59e0b;
  --accent-error: #dc2626;

  /* Text */
  --text-primary: #1d1d1f;
  --text-secondary: #6e6e73;
  --text-tertiary: #86868b;

  /* Glass & Borders */
  --glass-bg: rgba(255, 255, 255, 0.85);
  --glass-border: rgba(0, 0, 0, 0.1);
  --border-strong: rgba(0, 0, 0, 0.15);
  --divider: rgba(0, 0, 0, 0.06);

  /* Shadows */
  --shadow-sm: 0 2px 8px rgba(0, 0, 0, 0.1);
  --shadow-md: 0 4px 16px rgba(0, 0, 0, 0.15);
  --shadow-lg: 0 8px 32px rgba(0, 0, 0, 0.2);

  /* Component-specific */
  --input-bg: rgba(0, 0, 0, 0.04);
  --input-border: rgba(0, 0, 0, 0.15);
  --button-bg: rgba(0, 0, 0, 0.04);
  --button-border: rgba(0, 0, 0, 0.12);
  --card-bg: rgba(0, 0, 0, 0.02);
  --card-border: rgba(0, 0, 0, 0.1);
}

* { margin: 0; padding: 0; box-sizing: border-box; }

body {
  font-family: 'Inter', -apple-system, BlinkMacSystemFont, "SF Pro Display", "Segoe UI", sans-serif;
  background: var(--bg-app);
  color: var(--text-primary);
  height: 100vh;
  display: flex;
  flex-direction: column;
  user-select: none;
  overflow: hidden;
}


/* ---- Top Bar ---- */
.top-bar {
  height: 44px;
  background: rgba(18, 18, 18, 0.8);
  backdrop-filter: blur(24px);
  border-bottom: 1px solid rgba(255,255,255,0.06);
  box-shadow: 0 2px 16px rgba(0, 0, 0, 0.3);
  padding: 0 16px;
  display: flex;
  align-items: center;
  gap: 10px;
  z-index: 100;
  flex-shrink: 0;
  flex-wrap: wrap;
  min-height: 44px;
}

.top-bar .logo {
  font-size: 13px;
  font-weight: 700;
  letter-spacing: -0.4px;
  margin-right: 12px;
  white-space: nowrap;
  background: linear-gradient(135deg, var(--accent-primary), var(--accent-secondary));
  -webkit-background-clip: text;
  -webkit-text-fill-color: transparent;
}

.top-bar .sep { width: 1px; height: 20px; background: var(--glass-border); }

.top-bar label {
  font-size: 10px;
  color: var(--text-tertiary);
  display: flex;
  align-items: center;
  gap: 4px;
  white-space: nowrap;
}

.top-bar select, .top-bar input[type="number"] {
  background: rgba(255,255,255,0.07);
  border: 1px solid rgba(255,255,255,0.1);
  border-radius: 5px;
  color: #ccc;
  padding: 3px 6px;
  font-size: 10px;
  font-family: inherit;
}
.top-bar input[type="number"] { width: 52px; }

.btn {
  background: rgba(255,255,255,0.07);
  border: 1px solid rgba(255,255,255,0.1);
  border-radius: 6px;
  color: var(--text-secondary);
  padding: 8px 14px;
  min-height: 36px;
  font-size: 12px;
  font-weight: 500;
  cursor: pointer;
  transition: all 0.15s cubic-bezier(0.4, 0, 0.2, 1);
  white-space: nowrap;
  font-family: inherit;
  display: inline-flex;
  align-items: center;
  justify-content: center;
  gap: 6px;
  flex-shrink: 0;
}
.btn:hover {
  background: rgba(255,255,255,0.13);
  color: var(--text-primary);
  transform: translateY(-1px);
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
}
.btn:active {
  transform: translateY(0);
}

/* Accessibility: Focus states */
.btn:focus-visible {
  outline: 2px solid var(--accent-primary);
  outline-offset: 2px;
}

.btn-primary {
  background: linear-gradient(135deg, #2563eb, #7c3aed);
  border-color: rgba(99,102,241,0.4);
  color: #fff;
}
.btn-primary:hover { opacity: 0.9; }
.btn-primary.recording {
  background: linear-gradient(135deg, #dc2626, #e11d48);
  border-color: rgba(220,38,38,0.5);
  animation: pulse 1.2s ease infinite;
}
@keyframes pulse { 0%,100%{opacity:1} 50%{opacity:0.7} }

.undo-btn {
  background: none; border: none; color: var(--text-tertiary); font-size: 14px;
  cursor: pointer; padding: 2px 5px; border-radius: 4px;
  transition: color 0.15s, background 0.15s;
}
.undo-btn:hover:not(:disabled) { color: var(--text-secondary); background: rgba(255,255,255,0.06); }
.undo-btn:disabled { color: #333; cursor: default; }

.top-bar .spacer { flex: 1; }

/* Mobile Menu Toggle Buttons */
.mobile-menu-toggle {
  display: none; /* Hidden by default, shown via media queries */
  align-items: center;
  justify-content: center;
  width: 40px;
  height: 40px;
  padding: 0;
  background: rgba(255, 255, 255, 0.08);
  border: 1px solid rgba(255, 255, 255, 0.12);
  border-radius: 8px;
  cursor: pointer;
  transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
  flex-shrink: 0;
}

.mobile-menu-toggle:hover {
  background: rgba(255, 255, 255, 0.14);
  transform: translateY(-1px);
}

.mobile-menu-toggle:active {
  transform: scale(0.95);
}

.mobile-menu-toggle:focus-visible {
  outline: 2px solid var(--accent-primary);
  outline-offset: 2px;
}

/* ============================================================ */
/* LIGHT THEME OVERRIDES */
/* ============================================================ */
:root[data-theme="light"] .top-bar {
  background: rgba(255, 255, 255, 0.8);
  border-bottom: 1px solid rgba(0, 0, 0, 0.1);
  box-shadow: 0 1px 8px rgba(0, 0, 0, 0.05);
}

:root[data-theme="light"] .top-bar .logo {
  background: linear-gradient(135deg, #0071e3, #8e5cdb);
  -webkit-background-clip: text;
  -webkit-text-fill-color: transparent;
}

:root[data-theme="light"] .top-bar .sep {
  background: rgba(0, 0, 0, 0.1);
}

:root[data-theme="light"] .top-bar select,
:root[data-theme="light"] .top-bar input[type="number"] {
  background: rgba(0, 0, 0, 0.04);
  border: 1px solid rgba(0, 0, 0, 0.15);
  color: var(--text-primary);
}

:root[data-theme="light"] .btn {
  background: rgba(0, 0, 0, 0.04);
  border: 1px solid rgba(0, 0, 0, 0.12);
  color: var(--text-secondary);
}

:root[data-theme="light"] .btn:hover {
  background: rgba(0, 0, 0, 0.08);
  color: var(--text-primary);
  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
}

:root[data-theme="light"] .btn-primary {
  background: linear-gradient(135deg, #0071e3, #8e5cdb);
  border-color: rgba(0, 113, 227, 0.4);
  color: #fff;
}

:root[data-theme="light"] .btn-primary:hover {
  opacity: 0.9;
}

:root[data-theme="light"] .btn-primary.recording {
  background: linear-gradient(135deg, #dc2626, #e11d48);
  border-color: rgba(220, 38, 38, 0.5);
}

:root[data-theme="light"] .undo-btn {
  color: var(--text-tertiary);
}

:root[data-theme="light"] .undo-btn:hover:not(:disabled) {
  color: var(--text-secondary);
  background: rgba(0, 0, 0, 0.05);
}

:root[data-theme="light"] .undo-btn:disabled {
  color: var(--text-tertiary);
  opacity: 0.4;
}

:root[data-theme="light"] .mobile-menu-toggle {
  background: rgba(0, 0, 0, 0.06);
  border: 1px solid rgba(0, 0, 0, 0.12);
}

:root[data-theme="light"] .mobile-menu-toggle:hover {
  background: rgba(0, 0, 0, 0.1);
}


/* ---- Main Layout ---- */
.main-layout {
  flex: 1;
  display: flex;
  overflow: hidden;
  min-height: 0;
}

/* ---- Panels ---- */
.panel {
  width: 220px;
  min-width: 180px;
  max-width: 30vw;
  background: var(--glass-bg);
  backdrop-filter: blur(24px) saturate(180%);
  border-right: 1px solid var(--glass-border);
  box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
  flex-shrink: 0;
  font-size: 11px;
  position: relative;
  transition: width 0.2s ease, max-width 0.2s ease;
  display: grid;
  grid-template-rows: auto 1fr;
  overflow: hidden;
}
.panel.right-panel {
  border-right: none;
  border-left: 1px solid var(--glass-border);
}
/* Panel Header */
.panel-header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 12px 16px;
  border-bottom: 1px solid var(--divider);
  background: var(--bg-hover);
  flex-shrink: 0;
  min-height: 44px;
}

.panel-title {
  font-size: 11px;
  font-weight: 600;
  color: var(--text-secondary);
  text-transform: uppercase;
  letter-spacing: 0.05em;
  margin: 0;
}

.panel-toggle {
  width: 28px;
  height: 28px;
  border-radius: 6px;
  background: var(--button-bg);
  border: 1px solid var(--button-border);
  color: var(--text-tertiary);
  font-size: 12px;
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
  font-family: inherit;
  transition: all 0.15s;
  flex-shrink: 0;
}

.panel-toggle:hover {
  background: var(--bg-active);
  color: var(--text-secondary);
}

.panel-toggle:focus-visible {
  outline: 2px solid var(--accent-primary);
  outline-offset: 2px;
}

/* Panel Body - Scrollable Content */
.panel-body {
  overflow-y: auto;
  overflow-x: hidden;
  padding-bottom: 240px; /* Ensure content rises above timeline */
}

/* Collapsed State */
.panel.collapsed {
  width: 36px;
  max-width: 36px;
}

.panel.collapsed .panel-header {
  padding: 8px 4px;
  flex-direction: column;
  gap: 8px;
}

.panel.collapsed .panel-title {
  writing-mode: vertical-rl;
  text-orientation: mixed;
  font-size: 10px;
}

.panel.collapsed .panel-body {
  display: none;
}

.panel-section {
  padding: 16px;
  margin-bottom: 0;
  border-bottom: 1px solid var(--divider);
  position: relative;
}
.panel-section h3 {
  font-size: 11px;
  font-weight: 600;
  color: var(--text-secondary);
  text-transform: uppercase;
  letter-spacing: 0.05em;
  margin-bottom: 12px;
}

.panel-section:not(:last-child)::after {
  content: '';
  display: block;
  height: 1px;
  background: var(--glass-border);
  margin-top: 16px;
  position: absolute;
  bottom: 0;
  left: 0;
  right: 0;
}

.device-grid {
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: 8px;
}
.device-grid .dev-btn {
  background: rgba(255,255,255,0.05);
  border: 1px solid rgba(255,255,255,0.08);
  border-radius: 6px;
  padding: 8px 4px;
  text-align: center;
  cursor: pointer;
  font-size: 9px;
  color: #999;
  transition: all 0.15s cubic-bezier(0.4, 0, 0.2, 1);
}
.device-grid .dev-btn:hover {
  background: rgba(255,255,255,0.1);
  color: #fff;
  transform: translateY(-2px);
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
}
.device-grid .dev-btn:focus-visible {
  outline: 2px solid var(--accent-primary);
  outline-offset: 2px;
}
.device-grid .dev-btn.active {
  background: rgba(96, 165, 250, 0.12);
  border-color: rgba(96, 165, 250, 0.4);
  color: var(--accent-primary);
  box-shadow:
    0 0 0 1px rgba(96, 165, 250, 0.2),
    inset 0 1px 0 rgba(96, 165, 250, 0.1);
}
.device-grid .dev-btn .icon { font-size: 20px; display: block; margin-bottom: 3px; }

.color-swatches {
  display: flex;
  gap: 6px;
  flex-wrap: wrap;
  margin-top: 6px;
}
.color-swatch {
  width: 22px;
  height: 22px;
  border-radius: 50%;
  border: 2px solid transparent;
  cursor: pointer;
  transition: all 0.15s;
  position: relative;
}
.color-swatch:hover { transform: scale(1.15); }
.color-swatch.active { border-color: var(--accent-primary); }

.toggle-row {
  display: flex;
  align-items: center;
  gap: 8px;
  margin-top: 8px;
}
.toggle-btn {
  background: rgba(255,255,255,0.05);
  border: 1px solid rgba(255,255,255,0.08);
  border-radius: 4px;
  padding: 4px 8px;
  font-size: 10px;
  color: #999;
  cursor: pointer;
  font-family: inherit;
}
.toggle-btn:hover { background: rgba(255,255,255,0.1); color:#fff; }
.toggle-btn.active {
  background: rgba(96, 165, 250, 0.12);
  border-color: rgba(96, 165, 250, 0.4);
  color: var(--accent-primary);
  box-shadow:
    0 0 0 1px rgba(96, 165, 250, 0.2),
    inset 0 1px 0 rgba(96, 165, 250, 0.1);
}

/* Layer list */
/* Unified Layers Panel */
.unified-layers { display: flex; flex-direction: column; gap: 1px; }
.ul-item {
  display: flex; align-items: center; gap: 4px;
  padding: 4px 6px; border-radius: 4px;
  font-size: 10px; color: #888;
  cursor: pointer; position: relative;
  transition: background 0.15s;
}
.ul-item:hover { background: rgba(255,255,255,0.05); }
.ul-item.selected { background: rgba(96,165,250,0.1); color: var(--accent-primary); }
.ul-item.main-layer {
  border-left: 2px solid rgba(96,165,250,0.35);
  padding-left: 8px; color: #bbb;
}
.ul-item.hidden-layer { opacity: 0.35; }
.ul-eye {
  background: none; border: none; cursor: pointer;
  font-size: 10px; padding: 0; width: 14px; text-align: center;
  color: #4a90d9; opacity: 0.5; transition: opacity 0.15s;
  flex-shrink: 0;
}
.ul-eye:hover { opacity: 1; }
.ul-eye.off { opacity: 0.2; color: #555; }
.ul-icon { font-size: 11px; width: 16px; text-align: center; flex-shrink: 0; }
.ul-name { flex: 1; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
.ul-tag {
  font-size: 7px; text-transform: uppercase; letter-spacing: 0.5px;
  color: var(--accent-primary); background: rgba(96,165,250,0.1);
  padding: 1px 4px; border-radius: 3px; flex-shrink: 0;
}
.ul-controls { display: none; align-items: center; gap: 1px; flex-shrink: 0; }
.ul-item:hover .ul-controls, .ul-item.selected .ul-controls { display: flex; }
.ul-btn {
  background: none; border: none; cursor: pointer;
  color: #666; font-size: 9px; padding: 1px 3px; border-radius: 2px;
  transition: color 0.1s, background 0.1s;
}
.ul-btn:hover { color: #fff; background: rgba(255,255,255,0.1); }
.ul-btn.del { color: #a55; }
.ul-btn.del:hover { color: #f44; background: rgba(255,68,68,0.1); }
.ul-empty { font-size: 9px; color: #444; padding: 12px 6px; text-align: center; }
.layer-actions { display: flex; gap: 4px; margin-top: 6px; }
.layer-actions .btn { flex: 1; font-size: 9px; text-align: center; }
.layer-detail {
  margin-top: 8px; padding: 8px;
  background: rgba(255,255,255,0.02);
  border: 1px solid rgba(255,255,255,0.06);
  border-radius: 6px;
}
.layer-detail .detail-row {
  display: flex; align-items: center; gap: 6px;
  margin-bottom: 4px; font-size: 9px; color: #888;
}
.layer-detail .detail-row label { min-width: 46px; color: #666; }
.layer-detail .detail-row input[type="range"] { flex: 1; }
.layer-detail .detail-row span { min-width: 28px; text-align: right; font-size: 8px; color: #555; }
/* Advanced render order (hidden by default) */
.adv-stack { display: flex; flex-direction: column; gap: 1px; }
.adv-item {
  display: flex; align-items: center; gap: 6px;
  padding: 4px 6px; border-radius: 4px;
  cursor: grab; font-size: 9px; color: #555;
  background: rgba(255,255,255,0.02);
  border: 1px solid transparent;
  transition: background 0.15s;
}
.adv-item:hover { background: rgba(255,255,255,0.05); }
.adv-item.active { color: #999; border-color: rgba(255,255,255,0.06); }
.adv-item.dragging { opacity: 0.4; }
.adv-item.drag-over { border-color: rgba(96,165,250,0.4); background: rgba(96,165,250,0.06); }
.adv-item .adv-drag { cursor: grab; color: #444; font-size: 9px; }
.adv-item .adv-icon { font-size: 10px; width: 14px; text-align: center; }
.adv-item .adv-name { flex: 1; }
.adv-label { font-size: 7px; color: #444; text-transform: uppercase; letter-spacing: 0.5px; padding: 4px 6px 2px; }
/* Hidden layer list (backwards compat) */
.layer-list { list-style: none; display: none; }
.layer-item { display: none; }

/* Right panel controls */
.prop-row {
  display: flex;
  align-items: center;
  gap: 6px;
  margin-bottom: 6px;
}
.prop-row label { font-size: 10px; color: #777; min-width: 50px; }
.prop-row input[type="range"] { flex: 1; accent-color: var(--accent-primary); height: 14px; }
.prop-row input[type="color"] {
  width: 22px; height: 22px; border: 1px solid rgba(255,255,255,0.1);
  border-radius: 4px; cursor: pointer; background: none; padding: 0;
}
.prop-row input[type="number"] {
  width: 48px; background: rgba(255,255,255,0.07); border: 1px solid rgba(255,255,255,0.1);
  border-radius: 4px; color: #ccc; padding: 2px 4px; font-size: 10px; font-family: inherit;
}
.prop-row select {
  flex: 1; background: rgba(255,255,255,0.07); border: 1px solid rgba(255,255,255,0.1);
  border-radius: 4px; color: #ccc; padding: 3px 4px; font-size: 10px; font-family: inherit;
}
.prop-row input[type="text"] {
  flex: 1; background: rgba(255,255,255,0.07); border: 1px solid rgba(255,255,255,0.1);
  border-radius: 4px; color: #ccc; padding: 3px 6px; font-size: 10px; font-family: inherit;
}

/* Annotation toolbar */
.anno-toolbar {
  display: flex;
  gap: 4px;
  flex-wrap: wrap;
  margin-bottom: 8px;
}
.anno-btn {
  background: rgba(255,255,255,0.05);
  border: 1px solid rgba(255,255,255,0.08);
  border-radius: 4px;
  padding: 4px 7px;
  font-size: 10px;
  color: #aaa;
  cursor: pointer;
  font-family: inherit;
}
.anno-btn:hover { background: rgba(255,255,255,0.1); color: #fff; }
.anno-btn.active {
  background: rgba(96, 165, 250, 0.12);
  border-color: rgba(96, 165, 250, 0.4);
  color: var(--accent-primary);
  box-shadow:
    0 0 0 1px rgba(96, 165, 250, 0.2),
    inset 0 1px 0 rgba(96, 165, 250, 0.1);
}

.section-header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  margin-bottom: 8px;
}
.section-header h3 { margin-bottom: 0; }
.section-header .btn { padding: 1px 6px; font-size: 9px; }

.comparison-controls { display: none; }
.comparison-controls.visible { display: block; }

/* Full preset templates */
.preset-grid {
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: 8px;
}
.preset-card {
  background: rgba(255,255,255,0.03);
  border: 1px solid rgba(255,255,255,0.06);
  border-radius: 8px;
  padding: 8px 4px 6px;
  text-align: center;
  cursor: pointer;
  font-size: 9px;
  color: #888;
  transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
}
.preset-card:hover {
  background: rgba(255,255,255,0.07);
  color: #ccc;
  border-color: rgba(255,255,255,0.12);
  transform: translateY(-4px) scale(1.02);
  box-shadow: 0 8px 24px rgba(0, 0, 0, 0.3);
}
.preset-card.active {
  background: linear-gradient(135deg, rgba(96,165,250,0.1), rgba(167,139,250,0.1));
  border-color: rgba(96,165,250,0.4);
  color: var(--accent-primary);
  box-shadow:
    0 0 0 1px rgba(96, 165, 250, 0.2),
    inset 0 1px 0 rgba(96, 165, 250, 0.1);
}
.preset-card .pc-icon { font-size: 18px; display: block; margin-bottom: 3px; }
.preset-card .pc-name { font-weight: 600; letter-spacing: -0.2px; }
.preset-card .pc-desc { font-size: 7px; color: #555; margin-top: 2px; line-height: 1.3; }
.preset-card.active .pc-desc { color: rgba(96,165,250,0.6); }

.panel-section.collapsed .collapsible-content { display: none; }
.collapse-toggle {
  background: none; border: none; color: #666; font-size: 10px;
  cursor: pointer; padding: 0 4px; font-family: inherit;
}
.collapse-toggle:hover { color: #aaa; }

/* ============================================================ */
/* LIGHT THEME OVERRIDES */
/* ============================================================ */
:root[data-theme="light"] .panel {
  backdrop-filter: blur(20px) saturate(120%);
  box-shadow: 0 8px 32px rgba(0, 0, 0, 0.08);
}

:root[data-theme="light"] .panel-header {
  background: rgba(0, 0, 0, 0.03);
  border-bottom: 1px solid rgba(0, 0, 0, 0.08);
}

/* Device buttons */
:root[data-theme="light"] .device-grid .dev-btn {
  background: rgba(0, 0, 0, 0.03);
  border: 1px solid rgba(0, 0, 0, 0.08);
  color: var(--text-secondary);
}

:root[data-theme="light"] .device-grid .dev-btn:hover {
  background: rgba(0, 0, 0, 0.08);
  color: var(--text-primary);
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
}

:root[data-theme="light"] .device-grid .dev-btn.active {
  background: rgba(0, 113, 227, 0.08);
  border-color: rgba(0, 113, 227, 0.3);
  color: var(--accent-primary);
  box-shadow:
    0 0 0 1px rgba(0, 113, 227, 0.15),
    inset 0 1px 0 rgba(0, 113, 227, 0.1);
}

/* Toggle buttons */
:root[data-theme="light"] .toggle-btn {
  background: rgba(0, 0, 0, 0.03);
  border: 1px solid rgba(0, 0, 0, 0.08);
  color: var(--text-secondary);
}

:root[data-theme="light"] .toggle-btn:hover {
  background: rgba(0, 0, 0, 0.08);
  color: var(--text-primary);
}

:root[data-theme="light"] .toggle-btn.active {
  background: rgba(0, 113, 227, 0.08);
  border-color: rgba(0, 113, 227, 0.3);
  color: var(--accent-primary);
  box-shadow:
    0 0 0 1px rgba(0, 113, 227, 0.15),
    inset 0 1px 0 rgba(0, 113, 227, 0.1);
}

/* Annotation toolbar buttons */
:root[data-theme="light"] .anno-btn {
  background: rgba(0, 0, 0, 0.03);
  border: 1px solid rgba(0, 0, 0, 0.08);
  color: var(--text-secondary);
}

:root[data-theme="light"] .anno-btn:hover {
  background: rgba(0, 0, 0, 0.08);
  color: var(--text-primary);
}

:root[data-theme="light"] .anno-btn.active {
  background: rgba(0, 113, 227, 0.08);
  border-color: rgba(0, 113, 227, 0.3);
  color: var(--accent-primary);
  box-shadow:
    0 0 0 1px rgba(0, 113, 227, 0.15),
    inset 0 1px 0 rgba(0, 113, 227, 0.1);
}

/* Layer list */
:root[data-theme="light"] .ul-item {
  color: var(--text-secondary);
}

:root[data-theme="light"] .ul-item:hover {
  background: rgba(0, 0, 0, 0.05);
}

:root[data-theme="light"] .ul-item.selected {
  background: rgba(0, 113, 227, 0.08);
  color: var(--accent-primary);
}

:root[data-theme="light"] .ul-item.main-layer {
  border-left-color: rgba(0, 113, 227, 0.35);
  color: var(--text-primary);
}

:root[data-theme="light"] .ul-eye {
  color: var(--accent-primary);
}

:root[data-theme="light"] .ul-eye.off {
  color: var(--text-tertiary);
}

:root[data-theme="light"] .ul-tag {
  color: var(--accent-primary);
  background: rgba(0, 113, 227, 0.08);
}

:root[data-theme="light"] .ul-btn {
  color: var(--text-tertiary);
}

:root[data-theme="light"] .ul-btn:hover {
  color: var(--text-primary);
  background: rgba(0, 0, 0, 0.08);
}

:root[data-theme="light"] .ul-btn.del {
  color: #dc2626;
}

:root[data-theme="light"] .ul-btn.del:hover {
  color: #dc2626;
  background: rgba(220, 38, 38, 0.1);
}

:root[data-theme="light"] .ul-empty {
  color: var(--text-tertiary);
}

/* Layer detail panel */
:root[data-theme="light"] .layer-detail {
  background: rgba(0, 0, 0, 0.02);
  border: 1px solid rgba(0, 0, 0, 0.08);
}

:root[data-theme="light"] .layer-detail .detail-row {
  color: var(--text-secondary);
}

:root[data-theme="light"] .layer-detail .detail-row label {
  color: var(--text-tertiary);
}

:root[data-theme="light"] .layer-detail .detail-row span {
  color: var(--text-tertiary);
}

/* Advanced render order */
:root[data-theme="light"] .adv-item {
  color: var(--text-tertiary);
  background: rgba(0, 0, 0, 0.02);
}

:root[data-theme="light"] .adv-item:hover {
  background: rgba(0, 0, 0, 0.05);
}

:root[data-theme="light"] .adv-item.active {
  color: var(--text-secondary);
  border-color: rgba(0, 0, 0, 0.08);
}

:root[data-theme="light"] .adv-item.drag-over {
  border-color: rgba(0, 113, 227, 0.3);
  background: rgba(0, 113, 227, 0.06);
}

:root[data-theme="light"] .adv-drag {
  color: var(--text-tertiary);
}

:root[data-theme="light"] .adv-label {
  color: var(--text-tertiary);
}

/* Property controls */
:root[data-theme="light"] .prop-row label {
  color: var(--text-secondary);
}

:root[data-theme="light"] .prop-row input[type="color"] {
  border: 1px solid rgba(0, 0, 0, 0.15);
}

:root[data-theme="light"] .prop-row input[type="number"],
:root[data-theme="light"] .prop-row select,
:root[data-theme="light"] .prop-row input[type="text"] {
  background: rgba(0, 0, 0, 0.04);
  border: 1px solid rgba(0, 0, 0, 0.15);
  color: var(--text-primary);
}

/* Preset cards */
:root[data-theme="light"] .preset-card {
  background: rgba(0, 0, 0, 0.02);
  border: 1px solid rgba(0, 0, 0, 0.08);
  color: var(--text-secondary);
}

:root[data-theme="light"] .preset-card:hover {
  background: rgba(0, 0, 0, 0.05);
  color: var(--text-primary);
  border-color: rgba(0, 0, 0, 0.12);
  box-shadow: 0 8px 24px rgba(0, 0, 0, 0.1);
}

:root[data-theme="light"] .preset-card.active {
  background: linear-gradient(135deg, rgba(0, 113, 227, 0.08), rgba(142, 92, 219, 0.08));
  border-color: rgba(0, 113, 227, 0.3);
  color: var(--accent-primary);
  box-shadow:
    0 0 0 1px rgba(0, 113, 227, 0.15),
    inset 0 1px 0 rgba(0, 113, 227, 0.1);
}

:root[data-theme="light"] .preset-card .pc-desc {
  color: var(--text-tertiary);
}

:root[data-theme="light"] .preset-card.active .pc-desc {
  color: rgba(0, 113, 227, 0.6);
}

/* Collapse toggle */
:root[data-theme="light"] .collapse-toggle {
  color: var(--text-tertiary);
}

:root[data-theme="light"] .collapse-toggle:hover {
  color: var(--text-secondary);
}


/* ---- Canvas Stage ---- */
.stage {
  flex: 1;
  display: flex;
  align-items: center;
  justify-content: center;
  background: #1e1e1e;
  position: relative;
  overflow-y: auto;
  overflow-x: hidden;
  min-width: 0;
  padding-bottom: 220px; /* Account for always-visible timeline (2 tracks always showing) */
}

/* Adjust padding when timeline has more tracks */
.stage.timeline-expanded {
  padding-bottom: 300px;
}

.canvas-wrap {
  position: relative;
  cursor: pointer;
  transition: transform 0.2s ease;
}

#renderCanvas {
  display: block;
  max-width: 100%;
  max-height: 100%;
  width: auto;
  height: auto;
}

/* ---- Drop overlay ---- */
.drop-overlay {
  position: fixed; inset: 0; z-index: 200;
  background: rgba(37,99,235,0.15);
  border: 3px dashed #3b82f6;
  display: none; align-items: center; justify-content: center;
  font-size: 22px; color: #93c5fd; font-weight: 600;
  backdrop-filter: blur(6px);
}
.drop-overlay.active { display: flex; }

/* Checkerboard for transparent background */
.canvas-wrap.checker-bg {
  background-image:
    linear-gradient(45deg, #2a2a2a 25%, transparent 25%),
    linear-gradient(-45deg, #2a2a2a 25%, transparent 25%),
    linear-gradient(45deg, transparent 75%, #2a2a2a 75%),
    linear-gradient(-45deg, transparent 75%, #2a2a2a 75%);
  background-size: 20px 20px;
  background-position: 0 0, 0 10px, 10px -10px, -10px 0px;
  background-color: #1a1a1a;
}

/* ============================================================ */
/* LIGHT THEME OVERRIDES */
/* ============================================================ */

/* Canvas Stage */
:root[data-theme="light"] .stage {
  background: #e8e8ea;
}

/* Drop Overlay */
:root[data-theme="light"] .drop-overlay {
  background: rgba(0, 113, 227, 0.15);
  border: 3px dashed #0071e3;
  color: #0071e3;
}

/* Checkerboard for transparent background */
:root[data-theme="light"] .canvas-wrap.checker-bg {
  background-image:
    linear-gradient(45deg, #d0d0d0 25%, transparent 25%),
    linear-gradient(-45deg, #d0d0d0 25%, transparent 25%),
    linear-gradient(45deg, transparent 75%, #d0d0d0 75%),
    linear-gradient(-45deg, transparent 75%, #d0d0d0 75%);
  background-size: 20px 20px;
  background-position: 0 0, 0 10px, 10px -10px, -10px 0px;
  background-color: #f0f0f0;
}


/* ---- Timeline ---- */
.timeline-bar {
  height: 80px;
  background: var(--bg-panel);
  border-top: 1px solid rgba(255,255,255,0.06);
  display: flex;
  flex-direction: column;
  padding: 6px 16px;
  flex-shrink: 0;
  display: none;
}
.timeline-bar.visible { display: flex; }

.timeline-track {
  flex: 1;
  background: rgba(255,255,255,0.04);
  border-radius: 4px;
  position: relative;
  margin-bottom: 4px;
  cursor: pointer;
  overflow: hidden;
}
.timeline-track .clip-block {
  position: absolute; top: 4px; bottom: 4px;
  background: rgba(96,165,250,0.2);
  border: 1px solid rgba(96,165,250,0.3);
  border-radius: 3px;
  display: flex; align-items: center; justify-content: center;
  font-size: 9px; color: var(--accent-primary);
  cursor: pointer; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;
  user-select: none; transition: opacity 0.15s;
}
.clip-block.active { border-color: #f59e0b; box-shadow: 0 0 6px rgba(245,158,11,0.3); }
.clip-block.dragging { opacity: 0.5; }
.clip-block .clip-trim-handle {
  position: absolute; top: 0; bottom: 0; width: 6px;
  background: rgba(255,255,255,0.15); cursor: ew-resize; z-index: 2;
}
.clip-block .clip-trim-handle.left { left: 0; border-radius: 3px 0 0 3px; }
.clip-block .clip-trim-handle.right { right: 0; border-radius: 0 3px 3px 0; }
.clip-block .clip-trim-handle:hover { background: rgba(255,255,255,0.3); }
.clip-trans-indicator {
  position: absolute; top: 4px; bottom: 4px; width: 4px;
  background: rgba(168,85,247,0.6); border-radius: 2px; z-index: 2;
  pointer-events: none;
}
.trim-handle {
  position: absolute; top: 0; bottom: 0; width: 8px;
  background: rgba(96,165,250,0.6);
  cursor: ew-resize; z-index: 2;
}
.trim-handle.left { left: 0; border-radius: 3px 0 0 3px; }
.trim-handle.right { right: 0; border-radius: 0 3px 3px 0; }
.timeline-scrubber {
  position: absolute; top: 0; bottom: 0; width: 2px;
  background: #f59e0b; z-index: 3; pointer-events: none;
}
.keyframe-diamond {
  position: absolute; top: -2px; width: 10px; height: 10px;
  background: #f59e0b; transform: rotate(45deg);
  cursor: pointer; z-index: 4;
}

/* ---- Playback Bar ---- */
.playback-bar {
  height: 40px;
  background: var(--bg-panel);
  border-top: 1px solid rgba(255,255,255,0.06);
  padding: 0 16px;
  display: flex;
  align-items: center;
  gap: 10px;
  flex-shrink: 0;
  transform: translateY(100%);
  transition: transform 0.3s ease;
}
.playback-bar.visible { transform: translateY(0); }

.play-btn {
  width: 28px; height: 28px; background: none; border: none;
  cursor: pointer; display: flex; align-items: center; justify-content: center;
}
.play-btn svg { width: 16px; height: 16px; fill: #e0e0e0; }

.progress-track {
  flex: 1; height: 4px; background: rgba(255,255,255,0.1);
  border-radius: 2px; cursor: pointer; position: relative;
  padding: 8px 0; background-clip: content-box;
  margin: -8px 0;
  transition: height 0.15s ease;
}
.progress-track:hover, .progress-track.scrubbing { height: 6px; }
.progress-fill {
  height: 100%; background: var(--accent-primary); border-radius: 2px; width: 0%;
  pointer-events: none; position: relative;
}
.progress-handle {
  position: absolute; right: -6px; top: 50%; transform: translateY(-50%);
  width: 12px; height: 12px; border-radius: 50%;
  background: #fff; box-shadow: 0 0 4px rgba(0,0,0,0.5);
  opacity: 0; transition: opacity 0.15s;
  pointer-events: none;
}
.progress-track:hover .progress-handle,
.progress-track.scrubbing .progress-handle { opacity: 1; }
.progress-tooltip {
  position: absolute; bottom: 18px; left: 50%; transform: translateX(-50%);
  background: rgba(18,18,18,0.92); border: 1px solid rgba(255,255,255,0.1);
  border-radius: 4px; padding: 2px 6px; font-size: 10px; color: #ccc;
  white-space: nowrap; pointer-events: none;
  display: none;
}
.progress-track.scrubbing .progress-tooltip { display: block; }

.time-label {
  font-size: 10px; color: #666; font-variant-numeric: tabular-nums;
  min-width: 80px; text-align: right;
}

.speed-select {
  background: rgba(255,255,255,0.07); border: 1px solid rgba(255,255,255,0.1);
  border-radius: 4px; color: #ccc; padding: 2px 4px; font-size: 10px; font-family: inherit;
}

/* ============================================================ */
/* LIGHT THEME OVERRIDES */
/* ============================================================ */

/* Timeline Bar */
:root[data-theme="light"] .timeline-bar {
  background: rgba(255, 255, 255, 0.9);
  border-top: 1px solid rgba(0, 0, 0, 0.1);
}

:root[data-theme="light"] .timeline-track {
  background: rgba(0, 0, 0, 0.06);
}

/* Clip Blocks */
:root[data-theme="light"] .timeline-track .clip-block {
  background: rgba(0, 113, 227, 0.12);
  border: 1px solid rgba(0, 113, 227, 0.3);
  color: var(--accent-primary);
}

:root[data-theme="light"] .clip-block.active {
  border-color: var(--accent-warning);
  box-shadow: 0 0 6px rgba(245, 158, 11, 0.4);
}

:root[data-theme="light"] .clip-block .clip-trim-handle {
  background: rgba(0, 0, 0, 0.15);
}

:root[data-theme="light"] .clip-block .clip-trim-handle:hover {
  background: rgba(0, 0, 0, 0.3);
}

:root[data-theme="light"] .clip-trans-indicator {
  background: rgba(142, 92, 219, 0.6);
}

/* Trim Handles */
:root[data-theme="light"] .trim-handle {
  background: rgba(0, 113, 227, 0.6);
}

/* Timeline Scrubber/Playhead */
:root[data-theme="light"] .timeline-scrubber {
  background: var(--accent-warning);
}

:root[data-theme="light"] .keyframe-diamond {
  background: var(--accent-warning);
}

/* Playback Bar */
:root[data-theme="light"] .playback-bar {
  background: rgba(255, 255, 255, 0.9);
  border-top: 1px solid rgba(0, 0, 0, 0.1);
}

:root[data-theme="light"] .play-btn svg {
  fill: var(--text-primary);
}

:root[data-theme="light"] .progress-track {
  background: rgba(0, 0, 0, 0.1);
}

:root[data-theme="light"] .progress-fill {
  background: var(--accent-primary);
}

:root[data-theme="light"] .progress-handle {
  background: #fff;
  box-shadow: 0 0 4px rgba(0, 0, 0, 0.3);
}

:root[data-theme="light"] .progress-tooltip {
  background: rgba(0, 0, 0, 0.9);
  border: 1px solid rgba(0, 0, 0, 0.1);
  color: #fff;
}

:root[data-theme="light"] .time-label {
  color: var(--text-secondary);
}

:root[data-theme="light"] .speed-select {
  background: rgba(0, 0, 0, 0.04);
  border: 1px solid rgba(0, 0, 0, 0.15);
  color: var(--text-primary);
}


/* ============================================================
   ENHANCED TIMELINE SYSTEM - Cinema Grade
   Professional multi-track timeline with background video controls
   ============================================================ */

/* Base Timeline Container - Stacked Multi-Track Layout */
.timeline-system {
  position: fixed;
  bottom: 0;
  left: 0;
  right: 0;
  background: linear-gradient(180deg, rgba(12,12,14,0.98) 0%, rgba(18,18,20,0.98) 100%);
  border-top: 1px solid rgba(255,255,255,0.08);
  backdrop-filter: blur(20px);
  z-index: 200;
  transform: translateY(0);  /* Always visible */
  transition: transform 0.4s cubic-bezier(0.22, 1, 0.36, 1);
}

.timeline-system.visible {
  transform: translateY(0);
}

/* Track Header - Labels for each timeline track */
.track-header {
  display: flex;
  align-items: center;
  gap: 8px;
  padding: 8px 16px 6px;
  border-bottom: 1px solid rgba(255,255,255,0.04);
  min-height: 36px;
  cursor: pointer;
  transition: background 0.2s;
}

.track-header:hover {
  background: rgba(255,255,255,0.02);
}

.track-collapse-btn {
  width: 20px;
  height: 20px;
  background: rgba(255,255,255,0.05);
  border: 1px solid rgba(255,255,255,0.1);
  border-radius: 4px;
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 10px;
  color: rgba(255,255,255,0.5);
  transition: all 0.2s;
  margin-left: auto;
}

.track-collapse-btn:hover {
  background: rgba(255,255,255,0.1);
  color: rgba(255,255,255,0.8);
  border-color: rgba(255,255,255,0.2);
}

.track-collapse-btn.collapsed {
  transform: rotate(-90deg);
}

.track-label {
  font-size: 10px;
  font-weight: 600;
  letter-spacing: 0.5px;
  text-transform: uppercase;
  color: rgba(255,255,255,0.4);
  display: flex;
  align-items: center;
  gap: 6px;
  min-width: 140px;
}

.track-label-icon {
  width: 16px;
  height: 16px;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 12px;
}

.track-indicator {
  width: 3px;
  height: 16px;
  border-radius: 2px;
  background: linear-gradient(135deg, #60a5fa, #3b82f6);
}

.track-indicator.bg-video {
  background: linear-gradient(135deg, #a78bfa, #8b5cf6);
}

/* Background Video Track */
.bg-video-track,
.bg-audio-track {
  background: rgba(255,255,255,0.02);
  border-bottom: 1px solid rgba(255,255,255,0.04);
  padding: 0;
  display: block;  /* Always visible */
  opacity: 1;
  transform: translateY(0);
  transition: all 0.3s cubic-bezier(0.22, 1, 0.36, 1);
  max-height: 200px;
  overflow: hidden;
}

/* Tracks always visible, dimmed when no media loaded */
.bg-video-track .bg-track-content,
.bg-audio-track .bg-track-content {
  display: block;
  opacity: 0.4;
  transition: opacity 0.3s ease;
}

.bg-video-track.loaded .bg-track-content,
.bg-audio-track.loaded .bg-track-content {
  opacity: 1;
}

/* Disable pointer events when not loaded to prevent confusion */
.bg-video-track:not(.loaded) .bg-track-content,
.bg-audio-track:not(.loaded) .bg-track-content {
  pointer-events: none;
}

.bg-video-track.loaded .bg-track-content,
.bg-audio-track.loaded .bg-track-content {
  pointer-events: auto;
}

.bg-video-track.collapsed .bg-track-content,
.bg-audio-track.collapsed .bg-track-content {
  display: none;
}

.bg-video-track.collapsed,
.bg-audio-track.collapsed {
  max-height: 36px;
}

.bg-track-content {
  display: grid;
  grid-template-columns: 140px 1fr auto;
  gap: 12px;
  align-items: center;
  padding: 10px 16px;
}

.bg-video-controls {
  display: flex;
  align-items: center;
  gap: 6px;
}

.track-play-btn {
  width: 24px;
  height: 24px;
  background: rgba(255,255,255,0.08);
  border: 1px solid rgba(255,255,255,0.12);
  border-radius: 50%;
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
  transition: all 0.2s cubic-bezier(0.22, 1, 0.36, 1);
}

.track-play-btn:hover {
  background: rgba(255,255,255,0.14);
  border-color: rgba(255,255,255,0.2);
  transform: scale(1.05);
}

.track-play-btn:active {
  transform: scale(0.95);
}

.track-play-btn svg {
  width: 10px;
  height: 10px;
  fill: rgba(255,255,255,0.9);
  margin-left: 1px;
}

.track-play-btn.playing svg {
  margin-left: 0;
}

.track-loop-btn {
  width: 24px;
  height: 24px;
  background: rgba(255,255,255,0.05);
  border: 1px solid rgba(255,255,255,0.1);
  border-radius: 4px;
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 10px;
  transition: all 0.2s;
}

.track-loop-btn:hover {
  background: rgba(255,255,255,0.1);
}

.track-loop-btn.active {
  background: rgba(167,139,250,0.2);
  border-color: rgba(167,139,250,0.4);
  color: #a78bfa;
}

/* Enhanced Progress Track for BG Video */
.bg-progress-track {
  flex: 1;
  height: 32px;
  background: rgba(0,0,0,0.3);
  border: 1px solid rgba(255,255,255,0.08);
  border-radius: 6px;
  position: relative;
  cursor: pointer;
  overflow: hidden;
  transition: all 0.2s;
}

.bg-progress-track:hover {
  border-color: rgba(167,139,250,0.3);
  box-shadow: 0 0 12px rgba(167,139,250,0.15);
}

.bg-progress-fill {
  height: 100%;
  background: linear-gradient(90deg,
    rgba(167,139,250,0.3) 0%,
    rgba(167,139,250,0.2) 100%
  );
  border-right: 2px solid rgba(167,139,250,0.8);
  width: 0%;
  position: relative;
  transition: width 0.1s linear;
}

.bg-progress-waveform {
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background: repeating-linear-gradient(
    90deg,
    rgba(167,139,250,0.05) 0px,
    rgba(167,139,250,0.05) 2px,
    transparent 2px,
    transparent 8px
  );
  pointer-events: none;
}

.bg-progress-handle {
  position: absolute;
  right: -8px;
  top: 50%;
  transform: translateY(-50%);
  width: 16px;
  height: 16px;
  border-radius: 50%;
  background: linear-gradient(135deg, #a78bfa, #8b5cf6);
  box-shadow:
    0 2px 8px rgba(139,92,246,0.4),
    0 0 0 3px rgba(167,139,250,0.2);
  opacity: 0;
  transition: opacity 0.2s;
  pointer-events: none;
}

.bg-progress-track:hover .bg-progress-handle,
.bg-progress-track.scrubbing .bg-progress-handle {
  opacity: 1;
}

.bg-time-display {
  font-size: 10px;
  font-variant-numeric: tabular-nums;
  color: rgba(255,255,255,0.5);
  letter-spacing: 0.5px;
  min-width: 90px;
  text-align: right;
}

.bg-video-options {
  display: flex;
  align-items: center;
  gap: 8px;
}

.track-speed-select {
  background: rgba(255,255,255,0.06);
  border: 1px solid rgba(255,255,255,0.1);
  border-radius: 4px;
  color: rgba(255,255,255,0.7);
  padding: 4px 8px;
  font-size: 10px;
  font-family: 'SF Mono', 'Monaco', 'Courier New', monospace;
  cursor: pointer;
  transition: all 0.2s;
  min-width: 60px;
}

.track-speed-select:hover {
  background: rgba(255,255,255,0.1);
  border-color: rgba(255,255,255,0.2);
}

.track-sync-btn {
  padding: 4px 10px;
  font-size: 9px;
  font-weight: 600;
  letter-spacing: 0.3px;
  text-transform: uppercase;
  background: rgba(96,165,250,0.15);
  border: 1px solid rgba(96,165,250,0.3);
  border-radius: 4px;
  color: #60a5fa;
  cursor: pointer;
  transition: all 0.2s;
}

.track-sync-btn:hover {
  background: rgba(96,165,250,0.25);
  transform: translateY(-1px);
}

.track-sync-btn.synced {
  background: rgba(34,197,94,0.15);
  border-color: rgba(34,197,94,0.3);
  color: #22c55e;
}

/* Main Device Video Track (Enhanced) */
.main-video-track {
  padding: 0;
  border-bottom: 1px solid rgba(255,255,255,0.04);
  max-height: 500px;
  overflow: hidden;
  transition: all 0.3s cubic-bezier(0.22, 1, 0.36, 1);
}

.main-video-track.collapsed {
  max-height: 36px;
}

.main-video-track.collapsed .main-track-content {
  display: none;
}

.main-track-content {
  display: grid;
  grid-template-columns: 140px 1fr auto;
  gap: 12px;
  align-items: center;
  padding: 10px 16px;
}

/* Unified Playback Controls */
.unified-controls {
  padding: 12px 16px;
  display: flex;
  align-items: center;
  gap: 12px;
  background: rgba(0,0,0,0.2);
}

.master-play-btn {
  width: 36px;
  height: 36px;
  background: linear-gradient(135deg, #60a5fa, #3b82f6);
  border: none;
  border-radius: 50%;
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
  transition: all 0.25s cubic-bezier(0.22, 1, 0.36, 1);
  box-shadow: 0 4px 12px rgba(96,165,250,0.3);
}

.master-play-btn:hover {
  transform: scale(1.08);
  box-shadow: 0 6px 20px rgba(96,165,250,0.45);
}

.master-play-btn:active {
  transform: scale(0.98);
}

.master-play-btn svg {
  width: 14px;
  height: 14px;
  fill: white;
  margin-left: 2px;
}

.master-play-btn.playing svg {
  margin-left: 0;
}

.master-time-display {
  font-size: 13px;
  font-weight: 600;
  font-variant-numeric: tabular-nums;
  color: rgba(255,255,255,0.9);
  letter-spacing: 0.3px;
  min-width: 100px;
  font-family: 'SF Mono', 'Monaco', monospace;
}

.timeline-zoom-control {
  display: flex;
  align-items: center;
  gap: 6px;
  margin-left: auto;
}

.zoom-btn {
  width: 26px;
  height: 26px;
  background: rgba(255,255,255,0.06);
  border: 1px solid rgba(255,255,255,0.1);
  border-radius: 4px;
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 12px;
  color: rgba(255,255,255,0.6);
  transition: all 0.2s;
}

.zoom-btn:hover {
  background: rgba(255,255,255,0.12);
  color: rgba(255,255,255,0.9);
}

/* Responsive Design */
@media (max-width: 1024px) {
  .bg-track-content,
  .main-track-content {
    grid-template-columns: 100px 1fr auto;
    gap: 8px;
  }

  .track-label {
    min-width: 100px;
    font-size: 9px;
  }

  .bg-video-options {
    flex-direction: column;
    gap: 4px;
  }
}

@media (max-width: 768px) {
  .timeline-system {
    font-size: 90%;
  }

  .bg-track-content,
  .main-track-content {
    grid-template-columns: 1fr;
    gap: 8px;
  }

  .track-label {
    display: none;
  }

  .bg-video-controls {
    justify-content: space-between;
    width: 100%;
  }

  .unified-controls {
    flex-wrap: wrap;
  }
}

/* Accessibility */
.track-play-btn:focus,
.track-loop-btn:focus,
.master-play-btn:focus,
.zoom-btn:focus {
  outline: 2px solid rgba(96,165,250,0.5);
  outline-offset: 2px;
}

/* Loading States */
.bg-progress-track.loading .bg-progress-fill {
  background: linear-gradient(90deg,
    rgba(255,255,255,0.1) 0%,
    rgba(255,255,255,0.2) 50%,
    rgba(255,255,255,0.1) 100%
  );
  background-size: 200% 100%;
  animation: loading-shimmer 1.5s infinite;
}

@keyframes loading-shimmer {
  0% { background-position: 200% 0; }
  100% { background-position: -200% 0; }
}

/* Premium Details */
.track-label::before {
  content: '';
  position: absolute;
  left: 0;
  top: 0;
  bottom: 0;
  width: 2px;
  background: linear-gradient(180deg,
    transparent 0%,
    rgba(96,165,250,0.5) 50%,
    transparent 100%
  );
  opacity: 0;
  transition: opacity 0.3s;
}

.bg-video-track:hover .track-label::before {
  opacity: 1;
}

/* Light Theme Overrides */
:root[data-theme="light"] .timeline-system {
  background: linear-gradient(180deg, rgba(250,250,252,0.98) 0%, rgba(245,245,247,0.98) 100%);
  border-top: 1px solid rgba(0,0,0,0.1);
}

:root[data-theme="light"] .track-header {
  border-bottom: 1px solid rgba(0,0,0,0.06);
}

:root[data-theme="light"] .track-header:hover {
  background: rgba(0,0,0,0.02);
}

:root[data-theme="light"] .track-collapse-btn {
  background: rgba(0,0,0,0.04);
  border: 1px solid rgba(0,0,0,0.12);
  color: rgba(0,0,0,0.5);
}

:root[data-theme="light"] .track-collapse-btn:hover {
  background: rgba(0,0,0,0.08);
  color: rgba(0,0,0,0.8);
  border-color: rgba(0,0,0,0.2);
}

:root[data-theme="light"] .bg-video-track,
:root[data-theme="light"] .bg-audio-track {
  background: rgba(0,0,0,0.01);
  border-bottom: 1px solid rgba(0,0,0,0.06);
}

:root[data-theme="light"] .track-label {
  color: rgba(0,0,0,0.5);
}

:root[data-theme="light"] .track-play-btn {
  background: rgba(0,0,0,0.06);
  border: 1px solid rgba(0,0,0,0.12);
}

:root[data-theme="light"] .track-play-btn:hover {
  background: rgba(0,0,0,0.1);
  border-color: rgba(0,0,0,0.18);
}

:root[data-theme="light"] .track-play-btn svg {
  fill: rgba(0,0,0,0.7);
}

:root[data-theme="light"] .unified-controls {
  background: rgba(0,0,0,0.04);
}

:root[data-theme="light"] .main-video-track {
  border-bottom: 1px solid rgba(0,0,0,0.06);
}

:root[data-theme="light"] .bg-progress-track {
  background: rgba(0,0,0,0.06);
  border: 1px solid rgba(0,0,0,0.1);
}

:root[data-theme="light"] .bg-progress-track:hover {
  border-color: rgba(142,92,219,0.3);
  box-shadow: 0 0 12px rgba(142,92,219,0.15);
}

:root[data-theme="light"] .bg-time-display,
:root[data-theme="light"] .master-time-display {
  color: rgba(0,0,0,0.6);
}

:root[data-theme="light"] .track-speed-select {
  background: rgba(0,0,0,0.04);
  border: 1px solid rgba(0,0,0,0.12);
  color: rgba(0,0,0,0.7);
}

:root[data-theme="light"] .track-speed-select:hover {
  background: rgba(0,0,0,0.08);
  border-color: rgba(0,0,0,0.18);
}

:root[data-theme="light"] .track-sync-btn {
  background: rgba(0,113,227,0.12);
  border: 1px solid rgba(0,113,227,0.25);
  color: #0071e3;
}

:root[data-theme="light"] .track-sync-btn:hover {
  background: rgba(0,113,227,0.2);
}

:root[data-theme="light"] .zoom-btn {
  background: rgba(0,0,0,0.04);
  border: 1px solid rgba(0,0,0,0.12);
  color: rgba(0,0,0,0.6);
}

:root[data-theme="light"] .zoom-btn:hover {
  background: rgba(0,0,0,0.08);
  color: rgba(0,0,0,0.9);
}

/* ============================================================
   TRACK ACTION BUTTONS AND DROPDOWNS
   ============================================================ */
.track-actions {
  display: flex;
  gap: 4px;
  margin-left: auto;
  position: relative;
  min-width: 50px;          /* Prevent collapse */
  flex-shrink: 0;           /* Don't shrink */
}

.track-action-btn {
  background: rgba(255,255,255,0.08);
  border: 1px solid rgba(255,255,255,0.15);
  color: #fff;
  padding: 4px 10px;
  border-radius: 4px;
  cursor: pointer;
  font-size: 14px;
  transition: all 0.2s;
}

.track-action-btn:hover {
  background: rgba(255,255,255,0.15);
  border-color: rgba(255,255,255,0.25);
}

/* Active state when dropdown is open */
.track-action-btn.is-open {
  background: rgba(96, 165, 250, 0.25);
  border-color: rgba(96, 165, 250, 0.5);
  color: #60a5fa;
  box-shadow: 0 0 0 2px rgba(96, 165, 250, 0.15);
}

.track-action-btn.is-open:hover {
  background: rgba(96, 165, 250, 0.35);
}

.track-actions-dropdown {
  position: absolute;
  top: 100%;
  right: 0;
  margin-top: 4px;
  background: rgba(26,26,26,0.98);
  border: 1px solid rgba(255,255,255,0.15);
  border-radius: 6px;
  padding: 4px;
  min-width: 200px;
  z-index: 1000;
  box-shadow: 0 4px 12px rgba(0,0,0,0.5);
  backdrop-filter: blur(20px);

  /* Hidden by default */
  opacity: 0;
  visibility: hidden;
  transform: translateY(-8px);
  transition: opacity 0.2s ease, transform 0.2s ease, visibility 0.2s;
  pointer-events: none;
}

/* Shown when open */
.track-actions-dropdown.is-open {
  opacity: 1;
  visibility: visible;
  transform: translateY(0);
  pointer-events: auto;
}

.track-actions-dropdown button {
  display: block;
  width: 100%;
  padding: 8px 12px;
  background: transparent;
  border: none;
  color: #fff;
  text-align: left;
  cursor: pointer;
  border-radius: 4px;
  font-size: 12px;
  transition: background 0.2s;
}

.track-actions-dropdown button:hover {
  background: rgba(255,255,255,0.1);
}

/* Light theme */
:root[data-theme="light"] .track-action-btn {
  background: rgba(0,0,0,0.04);
  border: 1px solid rgba(0,0,0,0.12);
  color: #1d1d1f;
}

:root[data-theme="light"] .track-action-btn:hover {
  background: rgba(0,0,0,0.08);
  border-color: rgba(0,0,0,0.18);
}

/* Light theme active state */
:root[data-theme="light"] .track-action-btn.is-open {
  background: rgba(0, 113, 227, 0.15);
  border-color: rgba(0, 113, 227, 0.4);
  color: #0071e3;
  box-shadow: 0 0 0 2px rgba(0, 113, 227, 0.1);
}

:root[data-theme="light"] .track-action-btn.is-open:hover {
  background: rgba(0, 113, 227, 0.25);
}

:root[data-theme="light"] .track-actions-dropdown {
  background: rgba(255,255,255,0.98);
  border-color: rgba(0,0,0,0.15);
}

:root[data-theme="light"] .track-actions-dropdown button {
  color: #1d1d1f;
}

:root[data-theme="light"] .track-actions-dropdown button:hover {
  background: rgba(0,0,0,0.05);
}

/* Mobile: Keep action buttons visible */
@media (max-width: 768px) {
  .track-action-btn {
    padding: 4px 8px;       /* Smaller padding on mobile */
    font-size: 12px;        /* Smaller text */
  }

  .track-actions-dropdown {
    min-width: 180px;       /* Narrower dropdown */
    right: auto;            /* Align left on small screens */
    left: 0;
  }
}

/* Loop Markers */
.loop-marker {
  position: absolute;
  top: 0;
  bottom: 0;
  background: rgba(96, 165, 250, 0.2);
  border-left: 2px solid #60a5fa;
  border-right: 2px solid #60a5fa;
  pointer-events: none;
  z-index: 5;
}

.track-loop-btn {
  background: rgba(255,255,255,0.08);
  border: 1px solid rgba(255,255,255,0.15);
  color: #fff;
  padding: 4px 8px;
  border-radius: 4px;
  cursor: pointer;
  font-size: 14px;
  transition: all 0.2s;
  margin-left: 4px;
}

.track-loop-btn:hover {
  background: rgba(255,255,255,0.15);
}

.track-loop-btn.active {
  background: rgba(96, 165, 250, 0.3);
  border-color: #60a5fa;
}

/* Loop button active state (when dropdown is open) */
.track-loop-btn.is-open {
  background: rgba(96, 165, 250, 0.25);
  border-color: rgba(96, 165, 250, 0.5);
  color: #60a5fa;
}

.track-loop-controls {
  position: absolute;
  top: 100%;
  right: 0;
  margin-top: 4px;
  background: rgba(26,26,26,0.98);
  border: 1px solid rgba(255,255,255,0.15);
  border-radius: 6px;
  padding: 8px;
  z-index: 1000;
  display: flex;
  gap: 6px;
  align-items: center;
  box-shadow: 0 4px 12px rgba(0,0,0,0.5);
  backdrop-filter: blur(20px);

  /* Hidden by default */
  opacity: 0;
  visibility: hidden;
  transform: translateY(-8px);
  transition: opacity 0.2s ease, transform 0.2s ease, visibility 0.2s;
  pointer-events: none;
}

/* Shown when open */
.track-loop-controls.is-open {
  opacity: 1;
  visibility: visible;
  transform: translateY(0);
  pointer-events: auto;
}

.track-loop-controls input {
  background: rgba(255,255,255,0.08);
  border: 1px solid rgba(255,255,255,0.15);
  color: #fff;
  padding: 4px;
  border-radius: 4px;
  font-size: 11px;
}

/* Light theme */
:root[data-theme="light"] .track-loop-btn {
  background: rgba(0,0,0,0.04);
  border: 1px solid rgba(0,0,0,0.12);
  color: #1d1d1f;
}

:root[data-theme="light"] .track-loop-btn:hover {
  background: rgba(0,0,0,0.08);
}

:root[data-theme="light"] .track-loop-btn.active {
  background: rgba(0, 113, 227, 0.2);
  border-color: #0071e3;
}

/* Light theme loop button active state (when dropdown is open) */
:root[data-theme="light"] .track-loop-btn.is-open {
  background: rgba(0, 113, 227, 0.15);
  border-color: rgba(0, 113, 227, 0.4);
  color: #0071e3;
}

:root[data-theme="light"] .track-loop-controls {
  background: rgba(255,255,255,0.98);
  border-color: rgba(0,0,0,0.15);
}

:root[data-theme="light"] .track-loop-controls input {
  background: rgba(0,0,0,0.04);
  border-color: rgba(0,0,0,0.12);
  color: #1d1d1f;
}

/* EFFECTS PANEL STYLING
   ============================================================ */

/* Track Effects Section */
.track-effects-section {
  margin-top: 8px;
  border-top: 1px solid rgba(255, 255, 255, 0.08);
  padding-top: 8px;
}

.effects-toggle-btn {
  width: 100%;
  padding: 8px 12px;
  background: rgba(255, 255, 255, 0.05);
  border: 1px solid rgba(255, 255, 255, 0.08);
  border-radius: 6px;
  color: #ccc;
  font-size: 12px;
  cursor: pointer;
  transition: all 0.2s ease;
  display: flex;
  align-items: center;
  gap: 8px;
}

.effects-toggle-btn:hover {
  background: rgba(255, 255, 255, 0.08);
  border-color: rgba(255, 255, 255, 0.12);
}

.track-effects-section.collapsed .effects-panel {
  display: none;
}

/* Effects Panel */
.effects-panel {
  margin-top: 8px;
  padding: 12px;
  background: rgba(0, 0, 0, 0.2);
  border-radius: 8px;
  border: 1px solid rgba(255, 255, 255, 0.06);
}

/* Effect Groups */
.effect-group {
  margin-bottom: 16px;
  padding-bottom: 12px;
  border-bottom: 1px solid rgba(255, 255, 255, 0.06);
}

.effect-group:last-child {
  margin-bottom: 0;
  padding-bottom: 0;
  border-bottom: none;
}

.effect-group h4 {
  font-size: 11px;
  font-weight: 600;
  text-transform: uppercase;
  letter-spacing: 0.5px;
  color: #60a5fa;
  margin: 0 0 10px 0;
}

/* Effect Control */
.effect-control {
  display: grid;
  grid-template-columns: 80px 1fr 50px;
  align-items: center;
  gap: 8px;
  margin-bottom: 8px;
}

.effect-control label {
  font-size: 11px;
  color: #999;
}

.effect-control input[type="range"] {
  width: 100%;
  height: 4px;
  background: rgba(255, 255, 255, 0.1);
  border-radius: 2px;
  outline: none;
  -webkit-appearance: none;
}

.effect-control input[type="range"]::-webkit-slider-thumb {
  -webkit-appearance: none;
  width: 12px;
  height: 12px;
  background: #60a5fa;
  border-radius: 50%;
  cursor: pointer;
  transition: all 0.2s ease;
}

.effect-control input[type="range"]::-webkit-slider-thumb:hover {
  background: #3b82f6;
  transform: scale(1.1);
}

.effect-control input[type="range"]::-moz-range-thumb {
  width: 12px;
  height: 12px;
  background: #60a5fa;
  border-radius: 50%;
  cursor: pointer;
  border: none;
  transition: all 0.2s ease;
}

.effect-control input[type="range"]::-moz-range-thumb:hover {
  background: #3b82f6;
  transform: scale(1.1);
}

.effect-control .value {
  font-size: 11px;
  color: #ccc;
  text-align: right;
  font-variant-numeric: tabular-nums;
}

/* Select Dropdowns */
.effect-control select,
.effect-group select {
  padding: 6px 8px;
  background: rgba(255, 255, 255, 0.08);
  border: 1px solid rgba(255, 255, 255, 0.1);
  border-radius: 4px;
  color: #ccc;
  font-size: 11px;
  cursor: pointer;
}

.effect-control select:hover,
.effect-group select:hover {
  background: rgba(255, 255, 255, 0.12);
  border-color: rgba(255, 255, 255, 0.15);
}

/* Checkboxes */
.effect-group label {
  display: flex;
  align-items: center;
  gap: 6px;
  font-size: 11px;
  color: #ccc;
  cursor: pointer;
  margin-bottom: 6px;
}

.effect-group input[type="checkbox"] {
  width: 14px;
  height: 14px;
  cursor: pointer;
}

/* Solo/Mute Buttons */
.solo-btn,
.mute-btn {
  padding: 4px 10px;
  font-size: 11px;
  background: rgba(255, 255, 255, 0.05);
  border: 1px solid rgba(255, 255, 255, 0.1);
  border-radius: 4px;
  color: #999;
  cursor: pointer;
  transition: all 0.2s ease;
  margin-right: 6px;
}

.solo-btn:hover,
.mute-btn:hover {
  background: rgba(255, 255, 255, 0.1);
  border-color: rgba(255, 255, 255, 0.15);
  color: #ccc;
}

.solo-btn.active {
  background: #f59e0b;
  border-color: #f59e0b;
  color: #000;
}

.mute-btn.active {
  background: #ef4444;
  border-color: #ef4444;
  color: #fff;
}

/* EQ Graph Canvas */
.eq-graph {
  width: 100%;
  height: 80px;
  background: rgba(0, 0, 0, 0.3);
  border-radius: 4px;
  margin-bottom: 10px;
  border: 1px solid rgba(255, 255, 255, 0.08);
}

/* Compressor Controls */
.compressor-controls {
  margin-top: 8px;
  padding-top: 8px;
  border-top: 1px solid rgba(255, 255, 255, 0.06);
}

/* Effect Stack */
.effect-stack {
  min-height: 40px;
  background: rgba(0, 0, 0, 0.2);
  border-radius: 4px;
  padding: 8px;
  margin-bottom: 8px;
}

.effect-stack-item {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 6px 8px;
  background: rgba(255, 255, 255, 0.05);
  border-radius: 4px;
  margin-bottom: 4px;
  font-size: 11px;
  color: #ccc;
}

.effect-stack-item:last-child {
  margin-bottom: 0;
}

.effect-stack-item .effect-name {
  flex: 1;
}

.effect-stack-item .effect-controls {
  display: flex;
  gap: 4px;
}

.effect-stack-item button {
  padding: 2px 6px;
  font-size: 10px;
  background: rgba(255, 255, 255, 0.08);
  border: 1px solid rgba(255, 255, 255, 0.1);
  border-radius: 3px;
  color: #999;
  cursor: pointer;
}

.effect-stack-item button:hover {
  background: rgba(255, 255, 255, 0.12);
  color: #ccc;
}

/* Preset Buttons */
.save-preset-btn {
  padding: 6px 12px;
  font-size: 11px;
  background: rgba(96, 165, 250, 0.1);
  border: 1px solid rgba(96, 165, 250, 0.3);
  border-radius: 4px;
  color: #60a5fa;
  cursor: pointer;
  transition: all 0.2s ease;
}

.save-preset-btn:hover {
  background: rgba(96, 165, 250, 0.15);
  border-color: rgba(96, 165, 250, 0.4);
}

/* Light Theme Overrides */
:root[data-theme="light"] .effects-toggle-btn {
  background: rgba(0, 0, 0, 0.04);
  border-color: rgba(0, 0, 0, 0.1);
  color: #555;
}

:root[data-theme="light"] .effects-toggle-btn:hover {
  background: rgba(0, 0, 0, 0.06);
  border-color: rgba(0, 0, 0, 0.15);
}

:root[data-theme="light"] .effects-panel {
  background: rgba(0, 0, 0, 0.03);
  border-color: rgba(0, 0, 0, 0.1);
}

:root[data-theme="light"] .effect-group {
  border-bottom-color: rgba(0, 0, 0, 0.08);
}

:root[data-theme="light"] .effect-group h4 {
  color: #0071e3;
}

:root[data-theme="light"] .effect-control label {
  color: #666;
}

:root[data-theme="light"] .effect-control input[type="range"] {
  background: rgba(0, 0, 0, 0.1);
}

:root[data-theme="light"] .effect-control input[type="range"]::-webkit-slider-thumb {
  background: #0071e3;
}

:root[data-theme="light"] .effect-control input[type="range"]::-moz-range-thumb {
  background: #0071e3;
}

:root[data-theme="light"] .effect-control .value {
  color: #444;
}

:root[data-theme="light"] .effect-control select,
:root[data-theme="light"] .effect-group select {
  background: rgba(0, 0, 0, 0.06);
  border-color: rgba(0, 0, 0, 0.12);
  color: #444;
}

:root[data-theme="light"] .effect-group label {
  color: #444;
}

:root[data-theme="light"] .solo-btn,
:root[data-theme="light"] .mute-btn {
  background: rgba(0, 0, 0, 0.04);
  border-color: rgba(0, 0, 0, 0.12);
  color: #666;
}

:root[data-theme="light"] .solo-btn:hover,
:root[data-theme="light"] .mute-btn:hover {
  background: rgba(0, 0, 0, 0.08);
  color: #444;
}

:root[data-theme="light"] .eq-graph {
  background: rgba(0, 0, 0, 0.05);
  border-color: rgba(0, 0, 0, 0.1);
}

:root[data-theme="light"] .effect-stack {
  background: rgba(0, 0, 0, 0.04);
}

:root[data-theme="light"] .effect-stack-item {
  background: rgba(0, 0, 0, 0.04);
  color: #444;
}

:root[data-theme="light"] .save-preset-btn {
  background: rgba(0, 113, 227, 0.08);
  border-color: rgba(0, 113, 227, 0.3);
  color: #0071e3;
}

:root[data-theme="light"] .save-preset-btn:hover {
  background: rgba(0, 113, 227, 0.12);
}

/* ---- Asset Browser Modal ---- */
.asset-browser {
  position: fixed; inset: 0; z-index: 300;
  background: rgba(0,0,0,0.8);
  backdrop-filter: blur(12px);
  display: none; flex-direction: column;
}
.asset-browser.open { display: flex; }
.asset-browser-header {
  height: 48px; padding: 0 16px;
  background: rgba(18,18,18,0.98);
  border-bottom: 1px solid rgba(255,255,255,0.08);
  display: flex; align-items: center; gap: 12px; flex-shrink: 0;
}
.asset-browser-header h2 {
  font-size: 14px; font-weight: 700;
  background: linear-gradient(135deg, var(--accent-primary), var(--accent-secondary));
  -webkit-background-clip: text; -webkit-text-fill-color: transparent;
}
.asset-browser-header .ab-search {
  flex: 1; max-width: 300px;
  background: rgba(255,255,255,0.07); border: 1px solid rgba(255,255,255,0.1);
  border-radius: 6px; color: var(--text-secondary); padding: 6px 10px; font-size: 12px;
  font-family: inherit; outline: none;
}
.asset-browser-header .ab-search:focus { border-color: rgba(99,102,241,0.5); }
.ab-close {
  width: 30px; height: 30px; border-radius: 6px; border: none;
  background: rgba(255,255,255,0.07); color: #aaa; font-size: 16px;
  cursor: pointer; display: flex; align-items: center; justify-content: center;
}
.ab-close:hover { background: rgba(255,100,100,0.2); color: #f66; }
.asset-browser-body { display: flex; flex: 1; overflow: hidden; }
.ab-sidebar {
  width: 200px; background: rgba(18,18,18,0.95);
  border-right: 1px solid rgba(255,255,255,0.06);
  overflow-y: auto; flex-shrink: 0; padding: 8px 0;
}
.ab-folder {
  padding: 7px 14px; font-size: 11px; color: #999; cursor: pointer;
  display: flex; align-items: center; gap: 6px;
  border-left: 2px solid transparent; transition: all 0.1s;
}
.ab-folder:hover { color: var(--text-secondary); background: rgba(255,255,255,0.03); }
.ab-folder.active { color: var(--accent-primary); border-left-color: var(--accent-primary); background: rgba(96,165,250,0.06); }
.ab-folder .ab-icon { font-size: 13px; }
.ab-folder .ab-count { margin-left: auto; font-size: 9px; color: #555; }
.ab-content {
  flex: 1; overflow-y: auto; padding: 16px;
}
.ab-grid {
  display: grid; grid-template-columns: repeat(auto-fill, minmax(140px, 1fr));
  gap: 10px;
}
.ab-item {
  background: rgba(255,255,255,0.03); border: 1px solid rgba(255,255,255,0.06);
  border-radius: 8px; overflow: hidden; cursor: pointer; transition: all 0.15s;
}
.ab-item:hover { border-color: rgba(99,102,241,0.4); background: rgba(99,102,241,0.06); transform: translateY(-1px); }
.ab-item-preview {
  height: 80px; background: #111; display: flex; align-items: center;
  justify-content: center; font-size: 28px; color: #444;
  position: relative; overflow: hidden;
}
.ab-item-preview img { width: 100%; height: 100%; object-fit: cover; }
.ab-item-info { padding: 6px 8px; }
.ab-item-name { font-size: 9px; color: #aaa; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
.ab-item-type { font-size: 8px; color: #555; margin-top: 2px; }
.ab-item .ab-badge {
  position: absolute; top: 4px; right: 4px; padding: 1px 5px;
  border-radius: 3px; font-size: 8px; font-weight: 600;
}
.ab-badge-lut { background: rgba(74,222,128,0.2); color: var(--accent-success); }
.ab-badge-video { background: rgba(96,165,250,0.2); color: var(--accent-primary); }
.ab-badge-image { background: rgba(251,191,36,0.2); color: var(--accent-warning); }
.ab-badge-audio { background: rgba(244,114,182,0.2); color: #f472b6; }
.ab-empty {
  display: flex; flex-direction: column; align-items: center; justify-content: center;
  height: 100%; color: #555; font-size: 13px; gap: 12px;
}
.ab-empty .btn { font-size: 12px; padding: 8px 20px; }
.ab-breadcrumb { font-size: 10px; color: #666; margin-bottom: 12px; display: flex; gap: 4px; flex-wrap: wrap; }
.ab-breadcrumb span { cursor: pointer; }
.ab-breadcrumb span:hover { color: var(--accent-primary); }
.ab-breadcrumb .ab-sep { color: #444; cursor: default; }
.ab-loading { color: #666; font-size: 12px; text-align: center; padding: 40px; }

.canvas-prompt {
  position: absolute; inset: 0;
  display: flex; flex-direction: column; align-items: center; justify-content: center;
  pointer-events: none; opacity: 0; transition: opacity 0.2s;
}
.canvas-prompt.visible { opacity: 1; pointer-events: auto; }
.canvas-prompt svg { width: 44px; height: 44px; fill: rgba(255,255,255,0.4); margin-bottom: 10px; }
.canvas-prompt p { font-size: 13px; color: rgba(255,255,255,0.5); text-align: center; line-height: 1.6; }
.canvas-prompt .sub { font-size: 10px; color: rgba(255,255,255,0.25); margin-top: 4px; }

/* ---- Export status ---- */
.export-status {
  position: fixed; top: 50px; right: 16px; z-index: 150;
  background: rgba(18,18,18,0.92); backdrop-filter: blur(20px);
  border: 1px solid rgba(255,255,255,0.08); border-radius: 10px;
  padding: 12px 16px; font-size: 11px; color: #aaa; display: none; min-width: 180px;
}
.export-status.visible { display: block; }
.export-status .bar { height: 3px; background: rgba(255,255,255,0.08); border-radius: 2px; margin-top: 6px; overflow: hidden; }
.export-status .bar-fill { height: 100%; background: linear-gradient(90deg, #2563eb, #7c3aed); width: 0%; transition: width 0.3s; }

input[type="file"] { display: none; }

/* Welcome Modal */
.welcome-overlay {
  position: fixed;
  inset: 0;
  background: rgba(0, 0, 0, 0.8);
  backdrop-filter: blur(12px);
  display: none;
  align-items: center;
  justify-content: center;
  z-index: 700;
}
.welcome-overlay.open {
  display: flex;
}
.welcome-card {
  background: var(--glass-bg);
  backdrop-filter: blur(24px);
  border: 1px solid var(--glass-border);
  border-radius: 12px;
  padding: 32px;
  max-width: min(500px, 90vw);
  max-height: 90vh;
  overflow-y: auto;
  text-align: center;
  box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);
}
.welcome-card h2 {
  font-size: 24px;
  font-weight: 700;
  margin-bottom: 8px;
  background: linear-gradient(135deg, var(--accent-primary), var(--accent-secondary));
  -webkit-background-clip: text;
  -webkit-text-fill-color: transparent;
}
.welcome-steps {
  display: flex;
  gap: 24px;
  margin: 24px 0;
  justify-content: center;
}
.step {
  flex: 1;
  display: flex;
  flex-direction: column;
  gap: 8px;
  align-items: center;
  font-size: 12px;
  color: var(--text-secondary);
}
.step-icon {
  width: 48px;
  height: 48px;
  border-radius: 50%;
  background: rgba(96, 165, 250, 0.1);
  border: 1px solid rgba(96, 165, 250, 0.3);
  display: flex;
  align-items: center;
  justify-content: center;
  color: var(--accent-primary);
}
.step-icon i[data-lucide] {
  width: 24px;
  height: 24px;
  stroke-width: 2px;
}

/* Keyboard Shortcuts Overlay */
.kb-overlay {
  position: fixed; inset: 0; z-index: 600;
  background: rgba(0,0,0,0.7);
  backdrop-filter: blur(12px);
  display: none; align-items: center; justify-content: center;
}
.kb-overlay.open { display: flex; }
.kb-panel {
  background: rgba(18,18,18,0.96);
  border: 1px solid rgba(255,255,255,0.08);
  border-radius: 14px;
  padding: 28px 32px 20px;
  min-width: 340px;
  max-width: min(400px, 90vw);
  max-height: 90vh;
  overflow-y: auto;
}
.kb-panel h2 {
  font-size: 14px; font-weight: 700; margin-bottom: 18px;
  background: linear-gradient(135deg, var(--accent-primary), var(--accent-secondary));
  -webkit-background-clip: text; -webkit-text-fill-color: transparent;
}
.kb-row {
  display: flex; justify-content: space-between; align-items: center;
  padding: 7px 0;
  border-bottom: 1px solid rgba(255,255,255,0.04);
  font-size: 12px;
}
.kb-row:last-child { border-bottom: none; }
.kb-key {
  display: inline-flex; gap: 4px;
}
.kb-key kbd {
  background: rgba(255,255,255,0.08);
  border: 1px solid rgba(255,255,255,0.12);
  border-radius: 5px;
  padding: 2px 8px;
  font-size: 11px; font-family: inherit;
  color: var(--text-secondary);
}
.kb-action { color: #888; font-size: 11px; }
.kb-tip {
  margin-top: 16px; padding-top: 12px;
  border-top: 1px solid rgba(255,255,255,0.04);
  font-size: 10px; color: #555; text-align: center;
}
.kb-close {
  position: absolute; top: 12px; right: 16px;
  width: 28px; height: 28px; border-radius: 6px; border: none;
  background: rgba(255,255,255,0.07); color: #aaa; font-size: 15px;
  cursor: pointer; display: flex; align-items: center; justify-content: center;
}
.kb-close:hover { background: rgba(255,255,255,0.13); color: #fff; }

/* Export Dialog */
.export-dialog {
  position: fixed; inset: 0; z-index: 600;
  background: rgba(0,0,0,0.7);
  backdrop-filter: blur(12px);
  display: none; align-items: center; justify-content: center;
}
.export-dialog.open { display: flex; }

/* Export Success Animation */
.export-success {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  padding: 24px;
}

.checkmark {
  width: 60px;
  height: 60px;
}

.checkmark-circle {
  stroke-dasharray: 166;
  stroke-dashoffset: 166;
  stroke: var(--accent-success);
  fill: none;
  stroke-width: 2;
  animation: stroke 0.6s cubic-bezier(0.65, 0, 0.45, 1) forwards;
}

.checkmark-check {
  stroke-dasharray: 48;
  stroke-dashoffset: 48;
  stroke: var(--accent-success);
  fill: none;
  stroke-width: 3;
  stroke-linecap: round;
  stroke-linejoin: round;
  animation: stroke 0.3s cubic-bezier(0.65, 0, 0.45, 1) 0.6s forwards;
}

@keyframes stroke {
  100% { stroke-dashoffset: 0; }
}
.export-dialog-panel {
  background: rgba(18,18,18,0.96);
  border: 1px solid rgba(255,255,255,0.08);
  border-radius: 14px;
  padding: 24px 28px 20px;
  width: min(400px, 90vw);
  max-height: 90vh;
  overflow-y: auto;
  position: relative;
}
.export-dialog-panel h2 {
  font-size: 14px; font-weight: 700; margin-bottom: 16px;
  background: linear-gradient(135deg, var(--accent-primary), var(--accent-secondary));
  -webkit-background-clip: text; -webkit-text-fill-color: transparent;
}
.ed-row {
  display: flex; justify-content: space-between; align-items: center;
  padding: 7px 0;
  border-bottom: 1px solid rgba(255,255,255,0.04);
  font-size: 12px; color: #aaa;
}
.ed-row:last-child { border-bottom: none; }
.ed-row label { color: #888; font-size: 11px; min-width: 90px; }
.ed-row select, .ed-row input[type="checkbox"] {
  background: rgba(255,255,255,0.07);
  border: 1px solid rgba(255,255,255,0.1);
  border-radius: 5px; color: var(--text-secondary);
  padding: 4px 8px; font-size: 11px; font-family: inherit;
}
.ed-row input[type="checkbox"] { width: 15px; height: 15px; accent-color: var(--accent-primary); }
.ed-estimate {
  margin-top: 12px; padding: 8px 12px;
  background: rgba(255,255,255,0.03);
  border: 1px solid rgba(255,255,255,0.05);
  border-radius: 8px;
  font-size: 11px; color: #666; text-align: center;
}
.ed-actions {
  display: flex; gap: 8px; margin-top: 16px; justify-content: flex-end;
}

/* ============================================================ */
/* LIGHT THEME OVERRIDES */
/* ============================================================ */

/* Asset Browser Modal */
:root[data-theme="light"] .asset-browser {
  background: rgba(255, 255, 255, 0.8);
}

:root[data-theme="light"] .asset-browser-header {
  background: rgba(255, 255, 255, 0.98);
  border-bottom: 1px solid rgba(0, 0, 0, 0.1);
}

:root[data-theme="light"] .asset-browser-header h2 {
  background: linear-gradient(135deg, #0071e3, #8e5cdb);
  -webkit-background-clip: text;
  -webkit-text-fill-color: transparent;
}

:root[data-theme="light"] .asset-browser-header .ab-search {
  background: rgba(0, 0, 0, 0.04);
  border: 1px solid rgba(0, 0, 0, 0.15);
  color: var(--text-primary);
}

:root[data-theme="light"] .asset-browser-header .ab-search:focus {
  border-color: rgba(0, 113, 227, 0.5);
}

:root[data-theme="light"] .ab-close {
  background: rgba(0, 0, 0, 0.04);
  color: var(--text-secondary);
}

:root[data-theme="light"] .ab-close:hover {
  background: rgba(220, 38, 38, 0.1);
  color: #dc2626;
}

:root[data-theme="light"] .ab-sidebar {
  background: rgba(0, 0, 0, 0.02);
  border-right: 1px solid rgba(0, 0, 0, 0.1);
}

:root[data-theme="light"] .ab-folder {
  color: var(--text-secondary);
}

:root[data-theme="light"] .ab-folder:hover {
  color: var(--text-primary);
  background: rgba(0, 0, 0, 0.05);
}

:root[data-theme="light"] .ab-folder.active {
  color: var(--accent-primary);
  background: rgba(0, 113, 227, 0.08);
  border-left-color: var(--accent-primary);
}

:root[data-theme="light"] .ab-folder .ab-count {
  color: var(--text-tertiary);
}

:root[data-theme="light"] .ab-item {
  background: rgba(0, 0, 0, 0.02);
  border: 1px solid rgba(0, 0, 0, 0.08);
}

:root[data-theme="light"] .ab-item:hover {
  border-color: rgba(0, 113, 227, 0.3);
  background: rgba(0, 113, 227, 0.06);
}

:root[data-theme="light"] .ab-item-preview {
  background: #f0f0f0;
  color: var(--text-tertiary);
}

:root[data-theme="light"] .ab-item-name {
  color: var(--text-secondary);
}

:root[data-theme="light"] .ab-item-type {
  color: var(--text-tertiary);
}

:root[data-theme="light"] .ab-badge-lut {
  background: rgba(40, 167, 69, 0.15);
  color: var(--accent-success);
}

:root[data-theme="light"] .ab-badge-video {
  background: rgba(0, 113, 227, 0.15);
  color: var(--accent-primary);
}

:root[data-theme="light"] .ab-badge-image {
  background: rgba(245, 158, 11, 0.15);
  color: var(--accent-warning);
}

:root[data-theme="light"] .ab-badge-audio {
  background: rgba(244, 114, 182, 0.15);
  color: #f472b6;
}

:root[data-theme="light"] .ab-empty {
  color: var(--text-tertiary);
}

:root[data-theme="light"] .ab-breadcrumb {
  color: var(--text-tertiary);
}

:root[data-theme="light"] .ab-breadcrumb span:hover {
  color: var(--accent-primary);
}

:root[data-theme="light"] .ab-breadcrumb .ab-sep {
  color: var(--text-tertiary);
}

:root[data-theme="light"] .ab-loading {
  color: var(--text-secondary);
}

/* Canvas Prompt */
:root[data-theme="light"] .canvas-prompt svg {
  fill: rgba(0, 0, 0, 0.2);
}

:root[data-theme="light"] .canvas-prompt p {
  color: rgba(0, 0, 0, 0.5);
}

:root[data-theme="light"] .canvas-prompt .sub {
  color: rgba(0, 0, 0, 0.3);
}

/* Export Status */
:root[data-theme="light"] .export-status {
  background: rgba(255, 255, 255, 0.95);
  border: 1px solid rgba(0, 0, 0, 0.12);
  color: var(--text-secondary);
}

:root[data-theme="light"] .export-status .bar {
  background: rgba(0, 0, 0, 0.1);
}

:root[data-theme="light"] .export-status .bar-fill {
  background: linear-gradient(90deg, #0071e3, #8e5cdb);
}

/* Welcome Modal */
:root[data-theme="light"] .welcome-overlay {
  background: rgba(255, 255, 255, 0.8);
}

:root[data-theme="light"] .welcome-card {
  background: rgba(255, 255, 255, 0.95);
  border: 1px solid rgba(0, 0, 0, 0.12);
  box-shadow: 0 16px 48px rgba(0, 0, 0, 0.15);
}

:root[data-theme="light"] .welcome-card h2 {
  background: linear-gradient(135deg, #0071e3, #8e5cdb);
  -webkit-background-clip: text;
  -webkit-text-fill-color: transparent;
}

:root[data-theme="light"] .step-icon {
  background: rgba(0, 113, 227, 0.08);
  border: 1px solid rgba(0, 113, 227, 0.3);
}

/* Keyboard Shortcuts Overlay */
:root[data-theme="light"] .kb-overlay {
  background: rgba(255, 255, 255, 0.7);
}

:root[data-theme="light"] .kb-panel {
  background: rgba(255, 255, 255, 0.98);
  border: 1px solid rgba(0, 0, 0, 0.12);
}

:root[data-theme="light"] .kb-panel h2 {
  background: linear-gradient(135deg, #0071e3, #8e5cdb);
  -webkit-background-clip: text;
  -webkit-text-fill-color: transparent;
}

:root[data-theme="light"] .kb-row {
  border-bottom: 1px solid rgba(0, 0, 0, 0.06);
}

:root[data-theme="light"] .kb-key kbd {
  background: rgba(0, 0, 0, 0.06);
  border: 1px solid rgba(0, 0, 0, 0.12);
  color: var(--text-primary);
}

:root[data-theme="light"] .kb-action {
  color: var(--text-secondary);
}

:root[data-theme="light"] .kb-tip {
  border-top: 1px solid rgba(0, 0, 0, 0.06);
  color: var(--text-tertiary);
}

:root[data-theme="light"] .kb-close {
  background: rgba(0, 0, 0, 0.04);
  color: var(--text-secondary);
}

:root[data-theme="light"] .kb-close:hover {
  background: rgba(0, 0, 0, 0.08);
  color: var(--text-primary);
}

/* Export Dialog */
:root[data-theme="light"] .export-dialog {
  background: rgba(255, 255, 255, 0.7);
}

:root[data-theme="light"] .export-dialog-panel {
  background: rgba(255, 255, 255, 0.98);
  border: 1px solid rgba(0, 0, 0, 0.12);
}

:root[data-theme="light"] .export-dialog-panel h2 {
  background: linear-gradient(135deg, #0071e3, #8e5cdb);
  -webkit-background-clip: text;
  -webkit-text-fill-color: transparent;
}

:root[data-theme="light"] .ed-row {
  border-bottom: 1px solid rgba(0, 0, 0, 0.06);
  color: var(--text-secondary);
}

:root[data-theme="light"] .ed-row label {
  color: var(--text-secondary);
}

:root[data-theme="light"] .ed-row select,
:root[data-theme="light"] .ed-row input[type="checkbox"] {
  background: rgba(0, 0, 0, 0.04);
  border: 1px solid rgba(0, 0, 0, 0.15);
  color: var(--text-primary);
}

:root[data-theme="light"] .ed-estimate {
  background: rgba(0, 0, 0, 0.02);
  border: 1px solid rgba(0, 0, 0, 0.08);
  color: var(--text-tertiary);
}

/* ---- Lucide Icons ---- */
.btn i[data-lucide] {
  width: 16px;
  height: 16px;
  stroke-width: 2px;
  margin-right: 4px;
  vertical-align: middle;
  transition: transform 0.2s cubic-bezier(0.4, 0, 0.2, 1);
}

.btn:hover i[data-lucide] {
  transform: scale(1.1);
}

.btn:has(i[data-lucide]:only-child) i[data-lucide] {
  margin-right: 0;
}

.undo-btn i[data-lucide] {
  width: 14px;
  height: 14px;
  stroke-width: 2px;
}

.dev-btn .icon i[data-lucide] {
  width: 20px;
  height: 20px;
  stroke-width: 2px;
}

/* ---- Facecam ---- */
.facecam-preview {
  position: absolute;
  border-radius: 50%;
  overflow: hidden;
  border: 2px solid rgba(255,255,255,0.2);
  pointer-events: none;
  display: none;
}
.facecam-preview video { width: 100%; height: 100%; object-fit: cover; }

/* Range Input Styling */
input[type="range"] {
  -webkit-appearance: none;
  background: rgba(255, 255, 255, 0.1);
  height: 4px;
  border-radius: 2px;
  outline: none;
}

input[type="range"]::-webkit-slider-thumb {
  -webkit-appearance: none;
  width: 16px;
  height: 16px;
  background: var(--accent-primary);
  border-radius: 50%;
  cursor: pointer;
  box-shadow: 0 2px 8px rgba(96, 165, 250, 0.4);
  transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
}

input[type="range"]:hover::-webkit-slider-thumb {
  transform: scale(1.2);
  box-shadow: 0 4px 12px rgba(96, 165, 250, 0.6);
}

input[type="range"]::-moz-range-thumb {
  width: 16px;
  height: 16px;
  background: var(--accent-primary);
  border-radius: 50%;
  border: none;
  cursor: pointer;
  box-shadow: 0 2px 8px rgba(96, 165, 250, 0.4);
  transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
}

input[type="range"]:hover::-moz-range-thumb {
  transform: scale(1.2);
  box-shadow: 0 4px 12px rgba(96, 165, 250, 0.6);
}

/* Loading Skeleton Styles */
.skeleton {
  background: linear-gradient(
    90deg,
    rgba(255, 255, 255, 0.04) 25%,
    rgba(255, 255, 255, 0.08) 50%,
    rgba(255, 255, 255, 0.04) 75%
  );
  background-size: 200% 100%;
  animation: skeleton-loading 1.5s ease infinite;
  border-radius: 6px;
}

@keyframes skeleton-loading {
  0% { background-position: 200% 0; }
  100% { background-position: -200% 0; }
}

.skeleton-preview {
  width: 100%;
  height: 120px;
  margin-bottom: 8px;
}

.preset-skeleton {
  background: rgba(255, 255, 255, 0.03);
  border: 1px solid rgba(255, 255, 255, 0.06);
  border-radius: 8px;
  padding: 8px 4px 6px;
  pointer-events: none;
}

/* Tooltip System */
.tooltip {
  position: fixed;
  background: rgba(18, 18, 18, 0.95);
  backdrop-filter: blur(16px);
  border: 1px solid rgba(255, 255, 255, 0.12);
  border-radius: 8px;
  padding: 8px 12px;
  font-size: 11px;
  color: var(--text-primary);
  pointer-events: none;
  opacity: 0;
  transition: opacity 0.2s ease;
  z-index: 1000;
  max-width: 200px;
  white-space: nowrap;
}

.tooltip.visible {
  opacity: 1;
}

.tooltip-arrow {
  position: absolute;
  width: 0;
  height: 0;
  border-left: 6px solid transparent;
  border-right: 6px solid transparent;
  border-bottom: 6px solid rgba(18, 18, 18, 0.95);
  top: -6px;
  left: 50%;
  transform: translateX(-50%);
}

/* Scrollbar styling for panels */
.panel::-webkit-scrollbar { width: 4px; }
.panel::-webkit-scrollbar-track { background: transparent; }
.panel::-webkit-scrollbar-thumb { background: rgba(255,255,255,0.1); border-radius: 2px; }

.btn-danger {
  color: #f66;
  border-color: rgba(255,100,100,0.2);
}
.btn-danger:hover {
  background: rgba(255,100,100,0.1);
  color: #ff4444;
}

/* Toast Notifications */
.toast-container {
  position: fixed;
  bottom: 24px;
  right: 24px;
  z-index: 500;
  display: flex;
  flex-direction: column-reverse;
  gap: 8px;
  pointer-events: none;
}
.toast-item {
  background: var(--glass-bg);
  backdrop-filter: blur(16px);
  border: 1px solid var(--glass-border);
  border-radius: 10px;
  padding: 10px 16px;
  font-size: 12px;
  color: var(--text-secondary);
  white-space: nowrap;
  border-left: 3px solid rgba(255,255,255,0.15);
  transform: translateX(120%);
  opacity: 0;
  transition: transform 0.3s cubic-bezier(0.4,0,0.2,1), opacity 0.3s ease;
}
.toast-item.visible {
  transform: translateX(0);
  opacity: 1;
}
.toast-item.toast-success { border-left-color: var(--accent-success); }
.toast-item.toast-info { border-left-color: var(--accent-primary); }
.toast-item.toast-error { border-left-color: #f87171; }

/* ============================================================ */
/* LIGHT THEME OVERRIDES */
/* ============================================================ */

/* Range Input Styling */
:root[data-theme="light"] input[type="range"] {
  background: rgba(0, 0, 0, 0.1);
}

:root[data-theme="light"] input[type="range"]::-webkit-slider-thumb {
  background: var(--accent-primary);
  box-shadow: 0 2px 8px rgba(0, 113, 227, 0.3);
}

:root[data-theme="light"] input[type="range"]:hover::-webkit-slider-thumb {
  box-shadow: 0 4px 12px rgba(0, 113, 227, 0.5);
}

:root[data-theme="light"] input[type="range"]::-moz-range-thumb {
  background: var(--accent-primary);
  box-shadow: 0 2px 8px rgba(0, 113, 227, 0.3);
}

:root[data-theme="light"] input[type="range"]:hover::-moz-range-thumb {
  box-shadow: 0 4px 12px rgba(0, 113, 227, 0.5);
}

/* Loading Skeleton Styles */
:root[data-theme="light"] .skeleton {
  background: linear-gradient(
    90deg,
    rgba(0, 0, 0, 0.04) 25%,
    rgba(0, 0, 0, 0.08) 50%,
    rgba(0, 0, 0, 0.04) 75%
  );
}

:root[data-theme="light"] .preset-skeleton {
  background: rgba(0, 0, 0, 0.02);
  border: 1px solid rgba(0, 0, 0, 0.08);
}

/* Tooltip System - Keep dark for readability (industry standard) */
:root[data-theme="light"] .tooltip {
  background: rgba(0, 0, 0, 0.9);
  border: 1px solid rgba(0, 0, 0, 0.1);
  color: #fff;
}

:root[data-theme="light"] .tooltip-arrow {
  border-bottom-color: rgba(0, 0, 0, 0.9);
}

/* Scrollbar styling for panels */
:root[data-theme="light"] .panel::-webkit-scrollbar-thumb {
  background: rgba(0, 0, 0, 0.15);
}

/* Danger buttons */
:root[data-theme="light"] .btn-danger {
  color: #dc2626;
  border-color: rgba(220, 38, 38, 0.2);
}

:root[data-theme="light"] .btn-danger:hover {
  background: rgba(220, 38, 38, 0.1);
  color: #dc2626;
}

/* Toast Notifications */
:root[data-theme="light"] .toast-item {
  background: rgba(255, 255, 255, 0.95);
  border: 1px solid rgba(0, 0, 0, 0.12);
  box-shadow: 0 4px 16px rgba(0, 0, 0, 0.15);
  color: var(--text-primary);
  border-left: 3px solid rgba(0, 0, 0, 0.2);
}

:root[data-theme="light"] .toast-item.toast-success {
  border-left-color: var(--accent-success);
}

:root[data-theme="light"] .toast-item.toast-info {
  border-left-color: var(--accent-primary);
}

:root[data-theme="light"] .toast-item.toast-error {
  border-left-color: var(--accent-error);
}

/* Facecam preview */
:root[data-theme="light"] .facecam-preview {
  border: 2px solid rgba(0, 0, 0, 0.2);
}


/* ============================================================
   RESPONSIVE DESIGN - Industry Standard Mobile-First
   ============================================================ */

/* ---- Mobile: Off-Canvas Panels (< 768px) ---- */
@media (max-width: 767px) {
  /* Hide panels by default on mobile */
  .panel {
    position: fixed;
    top: 0;
    bottom: 0;
    width: 280px;
    max-width: 85vw;
    min-width: 280px;
    transform: translateX(-100%);
    transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    z-index: 400;
    box-shadow: 2px 0 20px rgba(0, 0, 0, 0.5);
  }

  .panel.right-panel {
    transform: translateX(100%);
    right: 0;
    box-shadow: -2px 0 20px rgba(0, 0, 0, 0.5);
  }

  /* Show panel when open */
  .panel.mobile-open {
    transform: translateX(0);
  }

  /* Backdrop overlay when panel is open */
  .panel-backdrop {
    display: none;
    position: fixed;
    inset: 0;
    background: rgba(0, 0, 0, 0.6);
    backdrop-filter: blur(4px);
    z-index: 350;
    opacity: 0;
    transition: opacity 0.3s ease;
  }

  .panel-backdrop.visible {
    display: block;
    opacity: 1;
  }

  /* Mobile-specific toggle buttons (hamburger style) */
  .mobile-menu-toggle {
    display: flex;
    align-items: center;
    justify-content: center;
    width: 40px;
    height: 40px;
    padding: 0;
    background: rgba(255, 255, 255, 0.08);
    border: 1px solid rgba(255, 255, 255, 0.12);
    border-radius: 8px;
    cursor: pointer;
    transition: all 0.2s;
  }

  .mobile-menu-toggle:active {
    transform: scale(0.95);
  }

  /* Hide desktop toggle buttons on mobile */
  .panel-toggle {
    display: none;
  }

  /* Stage should use full width on mobile */
  .stage {
    margin: 0;
  }

  /* Toolbar mobile layout */
  /* Compact mobile toolbar */
  .top-bar {
    height: auto;
    min-height: 56px;
    padding: 8px 12px;
    flex-wrap: nowrap;
    gap: 8px;
    overflow-x: auto;
    overflow-y: hidden;
    -webkit-overflow-scrolling: touch;
    scrollbar-width: none;
  }

  .top-bar::-webkit-scrollbar {
    display: none;
  }

  /* Logo stays visible but compact */
  .top-bar .logo {
    font-size: 12px;
    margin-right: 8px;
    flex-shrink: 0;
  }

  /* Hide less important controls on mobile */
  .top-bar label:has(#presetSelect),
  #customSizeWrap,
  .top-bar label:has(#entranceSelect),
  #entranceDur,
  #entranceDurVal {
    display: none;
  }

  /* Keep essential buttons visible with icons only */
  .top-bar .btn {
    padding: 8px 10px;
    min-height: 40px;
    min-width: 40px;
    font-size: 11px;
    gap: 4px;
    flex-shrink: 0;
  }

  .top-bar .btn i[data-lucide] {
    width: 16px;
    height: 16px;
  }

  /* Hide button text in toolbar */
  .top-bar .btn span {
    display: none;
  }

  /* Hide separators */
  .top-bar .sep {
    display: none;
  }

  /* Hide undo/redo on very small screens */
  .undo-btn {
    display: none;
  }

  /* Panel content optimizations */
  .panel-section {
    padding: 16px 14px;
  }

  .panel-section h3 {
    font-size: 11px;
    margin-bottom: 10px;
  }

  .device-grid,
  .preset-grid {
    gap: 8px;
  }

  .welcome-card {
    padding: 20px;
    max-width: 90vw;
  }

  .welcome-card h2 {
    font-size: 18px;
  }

  .welcome-steps {
    flex-direction: column;
    gap: 16px;
  }

  .step-icon {
    width: 40px;
    height: 40px;
  }

  .step-icon i[data-lucide] {
    width: 20px;
    height: 20px;
  }
}

/* ---- Tablet: Toggleable Overlays (768px - 1023px) ---- */
@media (min-width: 768px) and (max-width: 1023px) {
  /* Panels can overlay or be hidden */
  .panel {
    position: fixed;
    top: 0;
    bottom: 0;
    width: 260px;
    max-width: 35vw;
    min-width: 240px;
    z-index: 300;
    box-shadow: 2px 0 16px rgba(0, 0, 0, 0.4);
  }

  .panel.right-panel {
    right: 0;
    box-shadow: -2px 0 16px rgba(0, 0, 0, 0.4);
  }

  /* Panels can be collapsed */
  .panel:not(.tablet-open) {
    transform: translateX(-100%);
    transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1);
  }

  .panel.right-panel:not(.tablet-open) {
    transform: translateX(100%);
  }

  .panel.tablet-open {
    transform: translateX(0);
  }

  /* Show toggle buttons on tablet */
  .mobile-menu-toggle {
    display: flex;
  }

  /* Toolbar has more space */
  .top-bar {
    padding: 0 12px;
    gap: 8px;
  }

  .btn {
    padding: 7px 12px;
    min-height: 34px;
    font-size: 11px;
    gap: 5px;
  }

  .btn i[data-lucide] {
    width: 15px;
    height: 15px;
  }

  .panel {
    width: 200px;
  }

  .panel-section {
    padding: 14px;
  }

  .welcome-card {
    padding: 28px;
    max-width: 450px;
  }

  .welcome-card h2 {
    font-size: 20px;
  }
}

/* ---- Small Desktop: Side-by-Side (1024px - 1366px) ---- */
@media (min-width: 1024px) and (max-width: 1366px) {
  /* Panels are visible but can be collapsed */
  .panel {
    position: relative;
    width: 220px;
    min-width: 200px;
    max-width: 25vw;
    transform: none; /* Reset transform from mobile/tablet */
  }

  /* Show desktop toggle buttons */
  .panel-toggle {
    display: flex;
  }

  /* Hide mobile menu toggles */
  .mobile-menu-toggle {
    display: none;
  }

  /* Toolbar shows more controls */
  .top-bar {
    padding: 0 12px;
    gap: 8px;
    height: 44px;
    min-height: 44px;
    flex-wrap: nowrap;
    overflow-x: auto;
    overflow-y: hidden;
  }

  .top-bar .btn span {
    display: inline; /* Show button text */
  }

  .undo-btn {
    display: flex;
  }

  /* Show some controls at small desktop, but keep it compact */
  .top-bar label:has(#presetSelect) {
    display: flex;
  }

  /* Hide these until larger screens */
  #customSizeWrap,
  .top-bar label:has(#entranceSelect),
  #entranceDur,
  #entranceDurVal {
    display: none;
  }

  .top-bar .sep {
    display: none;
  }

  .top-bar .logo {
    font-size: 13px;
    margin-right: 8px;
  }
}

/* ---- Large Desktop: Full Layout (1367px+) ---- */
@media (min-width: 1367px) {
  /* Full desktop experience */
  .panel {
    position: relative;
    width: 220px;
    min-width: 220px;
    max-width: 280px;
    transform: none; /* Reset transform from mobile/tablet */
  }

  .mobile-menu-toggle {
    display: none;
  }

  .panel-toggle {
    display: flex;
  }

  /* Full toolbar with all controls */
  .top-bar {
    height: 44px;
    min-height: 44px;
    padding: 0 16px;
    gap: 10px;
    flex-wrap: nowrap;
    overflow-x: auto;
    overflow-y: hidden;
  }

  .top-bar .btn span {
    display: inline;
  }

  .undo-btn {
    display: flex;
  }

  /* Show all toolbar elements on large screens */
  .top-bar label:has(#presetSelect),
  #customSizeWrap,
  .top-bar label:has(#entranceSelect),
  #entranceDur,
  #entranceDurVal {
    display: flex;
  }

  .top-bar .sep {
    display: block;
  }

  .top-bar .logo {
    font-size: 13px;
    margin-right: 12px;
  }
}

/* ---- Auto-collapse panels on narrow screens (below desktop) ---- */
@media (max-width: 1023px) {
  .panel.left-panel:not(.user-expanded):not(.mobile-open):not(.tablet-open),
  .panel.right-panel:not(.user-expanded):not(.mobile-open):not(.tablet-open) {
    width: 36px;
  }

  .panel.left-panel:not(.user-expanded):not(.mobile-open):not(.tablet-open) .panel-section,
  .panel.right-panel:not(.user-expanded):not(.mobile-open):not(.tablet-open) .panel-section {
    display: none;
  }

  .panel.left-panel:not(.user-expanded):not(.mobile-open):not(.tablet-open) .panel-collapsed-label,
  .panel.right-panel:not(.user-expanded):not(.mobile-open):not(.tablet-open) .panel-collapsed-label {
    display: block;
  }
}

/* ---- Compact toolbar for narrow screens ---- */
@media (max-width: 1024px) {
  .top-bar .spacer {
    display: none;
  }

  #customSizeWrap {
    flex-basis: 100%;
  }
}

/* ---- Very Large Screens ---- */
@media (min-width: 1920px) {
  .panel {
    width: 260px;
  }

  .panel-section {
    padding: 18px;
  }

  .top-bar {
    height: 48px;
  }

  .btn {
    padding: 9px 16px;
    min-height: 38px;
    font-size: 13px;
  }
}

/* ---- Height-based responsive (for short screens) ---- */
@media (max-height: 768px) {
  .panel-section {
    padding: 10px;
  }

  .panel-section h3 {
    margin-bottom: 6px;
  }

  .device-grid,
  .preset-grid {
    gap: 4px;
  }

  .dev-btn {
    padding: 6px 4px;
  }

  .preset-card {
    padding: 6px 4px 4px;
  }

  .welcome-card {
    padding: 24px;
  }

  .welcome-steps {
    margin: 16px 0;
    gap: 16px;
  }
}

/* ---- Touch device optimizations ---- */
@media (hover: none) and (pointer: coarse) {
  .btn {
    min-height: 44px; /* iOS recommended touch target */
    padding: 10px 16px;
  }

  .dev-btn {
    min-height: 44px;
    padding: 10px 4px;
  }

  .toggle-btn {
    min-height: 36px;
    padding: 6px 10px;
  }

  .preset-card {
    min-height: 80px;
  }

  .panel-toggle {
    min-width: 44px;
    min-height: 44px;
  }

  /* Disable hover effects on touch devices */
  .btn:hover {
    transform: none;
    box-shadow: none;
  }

  .preset-card:hover,
  .dev-btn:hover {
    transform: none;
    box-shadow: none;
  }
}

/* ---- Landscape phone optimizations ---- */
@media (max-height: 500px) and (orientation: landscape) {
  .top-bar {
    height: auto;
    min-height: 36px;
    padding: 4px 8px;
  }

  .btn {
    padding: 4px 8px;
    min-height: 28px;
    font-size: 10px;
  }

  .panel {
    width: 160px;
    font-size: 9px;
  }

  .panel-section {
    padding: 8px;
  }

  .welcome-card {
    max-height: 90vh;
    overflow-y: auto;
    padding: 16px;
  }
}

/* ---- Print styles ---- */
@media print {
  .top-bar,
  .panel,
  .timeline-bar,
  .playback-bar,
  .toast-container,
  .tooltip,
  .welcome-overlay,
  .kb-overlay,
  .export-dialog,
  .asset-browser {
    display: none !important;
  }

  .stage {
    position: static;
    width: 100%;
    height: auto;
  }

  canvas {
    max-width: 100%;
    height: auto;
  }
}

/* ---- Reduced motion preference ---- */
@media (prefers-reduced-motion: reduce) {
  *,
  *::before,
  *::after {
    animation-duration: 0.01ms !important;
    animation-iteration-count: 1 !important;
    transition-duration: 0.01ms !important;
  }

  .skeleton {
    animation: none;
  }

  .checkmark-circle,
  .checkmark-check {
    animation: none;
    stroke-dashoffset: 0;
  }
}

/* ---- Container queries for future-proofing ---- */
@supports (container-type: inline-size) {
  .panel {
    container-type: inline-size;
  }

  @container (max-width: 200px) {
    .panel-section h3 {
      font-size: 9px;
    }

    .device-grid,
    .preset-grid {
      grid-template-columns: 1fr;
    }
  }
}


</style>
<script src="https://cdn.jsdelivr.net/npm/mp4-muxer@5.1.3/build/mp4-muxer.min.js"></script>
<script src="https://unpkg.com/lucide@latest"></script>
</head>
<body>

<div class="toast-container" id="toastContainer"></div>


<div class="toast-container" id="toastContainer"></div>

<!-- Tooltip -->
<div class="tooltip" id="tooltip">
  <div class="tooltip-content"></div>
  <div class="tooltip-arrow"></div>
</div>

<!-- Welcome Modal -->
<div class="welcome-overlay" id="welcomeOverlay">
  <div class="welcome-card glass-panel">
    <h2>Welcome to Mockup Studio</h2>
    <p style="color: var(--text-secondary); margin: 8px 0 20px;">Create stunning device mockup videos in seconds</p>
    <div class="welcome-steps">
      <div class="step">
        <span class="step-icon"><i data-lucide="smartphone"></i></span>
        <span>Choose a device</span>
      </div>
      <div class="step">
        <span class="step-icon"><i data-lucide="video"></i></span>
        <span>Upload your video</span>
      </div>
      <div class="step">
        <span class="step-icon"><i data-lucide="sparkles"></i></span>
        <span>Export & share</span>
      </div>
    </div>
    <button class="btn btn-primary" id="dismissWelcome" style="width: 100%;">Get Started</button>
  </div>
</div>

<!-- Panel Backdrop for Mobile -->
<div class="panel-backdrop" id="panelBackdrop"></div>

<!-- Top Bar -->
<div class="top-bar">
  <!-- Mobile: Left Panel Toggle (Hamburger Menu) -->
  <button class="mobile-menu-toggle" id="mobileLeftToggle" title="Open menu">
    <i data-lucide="menu" style="width: 20px; height: 20px;"></i>
  </button>

  <span class="logo">Mockup Studio</span>

  <!-- Mobile: Right Panel Toggle -->
  <button class="mobile-menu-toggle" id="mobileRightToggle" title="Open effects" style="margin-left: auto;">
    <i data-lucide="sliders" style="width: 20px; height: 20px;"></i>
  </button>

  <div class="sep"></div>

  <label>Preset
    <select id="presetSelect">
      <option value="device">Device Only</option>
      <option value="reels" selected>Reels/TikTok (1080x1920)</option>
      <option value="twitter">Twitter/X (1080x1350)</option>
      <option value="youtube">YouTube (1920x1080)</option>
      <option value="square">Square (1080x1080)</option>
      <option value="custom">Custom</option>
    </select>
  </label>
  <span id="customSizeWrap" style="display:none">
    <input type="number" id="customW" value="1080" min="100" max="3840"> x
    <input type="number" id="customH" value="1920" min="100" max="3840">
  </span>

  <div class="sep"></div>

  <label>Entrance
    <select id="entranceSelect">
      <option value="none">None</option>
      <option value="fadeIn">Fade In</option>
      <option value="slideUp">Slide Up</option>
      <option value="scaleIn">Scale In</option>
      <option value="rotateIn">Rotate In</option>
    </select>
  </label>
  <label>Dur <input type="range" id="entranceDur" min="500" max="3000" value="1000" style="width:60px;accent-color:#60a5fa"> <span id="entranceDurVal">1.0s</span></label>

  <div class="spacer"></div>

  <button class="undo-btn" id="undoBtn" title="Undo (Ctrl+Z)" disabled><i data-lucide="rotate-ccw"></i></button>
  <button class="undo-btn" id="redoBtn" title="Redo (Ctrl+Shift+Z)" disabled><i data-lucide="rotate-cw"></i></button>
  <div class="sep"></div>

  <button class="btn" id="assetBrowserBtn" data-tooltip="Browse your asset library" style="background:linear-gradient(135deg,rgba(99,102,241,0.2),rgba(168,85,247,0.2));border-color:rgba(139,92,246,0.3)"><i data-lucide="folder"></i><span>Assets</span></button>
  <button class="btn" id="themeToggleBtn" data-tooltip="Toggle light/dark theme"><i data-lucide="sun" id="themeToggleIcon"></i></button>
  <button class="btn" id="loadBtn" data-tooltip="Load a video file to get started"><i data-lucide="upload"></i><span>Load Video</span></button>
  <button class="btn" id="loopBtn" data-tooltip="Toggle video looping"><i data-lucide="repeat"></i><span>Loop</span></button>
  <button class="btn" id="ssBtn" data-tooltip="Save current frame as image"><i data-lucide="camera"></i><span>Screenshot</span></button>
  <button class="btn" id="thumbBtn" data-tooltip="Generate thumbnail from video"><i data-lucide="image"></i><span>Thumbnail</span></button>
  <button class="btn" id="kbHelpBtn" data-tooltip="View keyboard shortcuts" title="Keyboard shortcuts (?)"><i data-lucide="keyboard"></i></button>
  <button class="btn btn-primary" id="exportBtn" data-tooltip="Export your mockup as video"><i data-lucide="download"></i><span>Export</span></button>
</div>

<!-- Keyboard Shortcuts Overlay -->
<div class="kb-overlay" id="kbOverlay">
  <div class="kb-panel" style="position:relative">
    <button class="kb-close" id="kbClose">&times;</button>
    <h2>Keyboard Shortcuts</h2>
    <div class="kb-row"><span class="kb-key"><kbd>Space</kbd></span><span class="kb-action">Play / Pause</span></div>
    <div class="kb-row"><span class="kb-key"><kbd></kbd> <kbd></kbd></span><span class="kb-action">Seek 5 seconds</span></div>
    <div class="kb-row"><span class="kb-key"><kbd>Ctrl</kbd><kbd>S</kbd></span><span class="kb-action">Save Screenshot</span></div>
    <div class="kb-row"><span class="kb-key"><kbd>Ctrl</kbd><kbd>Z</kbd></span><span class="kb-action">Undo</span></div>
    <div class="kb-row"><span class="kb-key"><kbd>Ctrl</kbd><kbd></kbd><kbd>Z</kbd></span><span class="kb-action">Redo</span></div>
    <div class="kb-row"><span class="kb-key"><kbd>[</kbd> <kbd>]</kbd></span><span class="kb-action">Toggle sidebars</span></div>
    <div class="kb-row"><span class="kb-key"><kbd>?</kbd></span><span class="kb-action">Show this help</span></div>
    <div class="kb-tip">Tip: Press <kbd style="background:rgba(255,255,255,0.06);border:1px solid rgba(255,255,255,0.1);border-radius:4px;padding:1px 5px;font-size:9px;font-family:inherit;color:#666">?</kbd> anytime to see shortcuts</div>
  </div>
</div>

<!-- Export Dialog -->
<div class="export-dialog" id="exportDialog">
  <div class="export-dialog-panel">
    <div class="export-success" id="exportSuccess" style="display:none">
      <svg class="checkmark" viewBox="0 0 52 52">
        <circle class="checkmark-circle" cx="26" cy="26" r="25"/>
        <path class="checkmark-check" d="M14.1 27.2l7.1 7.2 16.7-16.8"/>
      </svg>
      <h3 style="color: var(--accent-success); margin-top: 12px;">Export Complete!</h3>
    </div>
    <h2>Export Settings</h2>
    <div class="ed-row"><label>Format</label><select id="edFormat"><option value="webm">WebM</option><option value="mp4">MP4 (H.264)</option></select></div>
    <div id="edFormatNote" style="font-size:9px;color:#666;padding:0 4px 4px;display:none"></div>
    <div class="ed-row"><label>Resolution</label>
      <select id="edResolution">
        <option value="original">Original</option>
        <option value="1080">1080p</option>
        <option value="720">720p</option>
      </select>
    </div>
    <div class="ed-row"><label>Quality</label>
      <select id="edQuality">
        <option value="5000000">Low (5 Mbps)</option>
        <option value="10000000" selected>Medium (10 Mbps)</option>
        <option value="20000000">High (20 Mbps)</option>
        <option value="40000000">Max (40 Mbps)</option>
      </select>
    </div>
    <div class="ed-row"><label>Framerate</label>
      <select id="edFramerate">
        <option value="24">24 fps</option>
        <option value="30" selected>30 fps</option>
        <option value="60">60 fps</option>
      </select>
    </div>
    <div class="ed-row"><label>Include Audio</label><input type="checkbox" id="edAudio" checked></div>
    <div class="ed-estimate" id="edEstimate"></div>
    <div class="ed-actions">
      <button class="btn" id="edCancel">Cancel</button>
      <button class="btn btn-primary" id="edStart">Start Export</button>
    </div>
  </div>
</div>

<!-- Main Layout -->
<div class="main-layout">

  <!-- Left Panel -->
  <div class="panel left-panel" id="leftPanel">
    <div class="panel-header">
      <h3 class="panel-title">Templates</h3>
      <button class="panel-toggle" id="leftPanelToggle" title="Toggle left panel ["></button>
    </div>
    <div class="panel-body">
    <div class="panel-section">
      <div class="section-header">
        <h3>Studio Templates</h3>
        <button class="btn btn-danger" id="resetFullPresetBtn">Custom</button>
      </div>
      <div class="preset-grid" id="fullPresetGrid">
        <div class="preset-card" data-fp="appShowcase"><span class="pc-icon"></span><span class="pc-name">App Showcase</span><span class="pc-desc">Cinematic device promo</span></div>
        <div class="preset-card" data-fp="tiktokViral"><span class="pc-icon"></span><span class="pc-name">TikTok Viral</span><span class="pc-desc">Sunset vibes, trending</span></div>
        <div class="preset-card" data-fp="cleanProduct"><span class="pc-icon"></span><span class="pc-name">Clean Product</span><span class="pc-desc">Minimal white showcase</span></div>
        <div class="preset-card" data-fp="darkCinematic"><span class="pc-icon"></span><span class="pc-name">Dark Cinema</span><span class="pc-desc">Moody film look</span></div>
        <div class="preset-card" data-fp="neonPop"><span class="pc-icon"></span><span class="pc-name">Neon Pop</span><span class="pc-desc">Neon glow effects</span></div>
        <div class="preset-card" data-fp="cleanSocial"><span class="pc-icon"></span><span class="pc-name">Clean Social</span><span class="pc-desc">No device, video only</span></div>
        <div class="preset-card" data-fp="retroFilm"><span class="pc-icon"></span><span class="pc-name">Retro Film</span><span class="pc-desc">Vintage film grain</span></div>
        <div class="preset-card" data-fp="laptopReview"><span class="pc-icon"></span><span class="pc-name">Laptop Review</span><span class="pc-desc">MacBook ocean vibe</span></div>
        <div class="preset-card" data-fp="rawVideo"><span class="pc-icon"></span><span class="pc-name">Raw Video</span><span class="pc-desc">No device, no effects</span></div>
        <div class="preset-card" data-fp="ipadPresent"><span class="pc-icon"></span><span class="pc-name">iPad Present</span><span class="pc-desc">iPad Pro minimal</span></div>
      </div>
    </div>

    <div class="panel-section" id="deviceSection">
      <div class="section-header">
        <h3>Device Frame</h3>
        <button class="collapse-toggle" id="deviceCollapseBtn"></button>
      </div>
      <div class="collapsible-content" id="deviceContent">
        <div class="device-grid" id="deviceGrid">
          <div class="dev-btn" data-device="none"><span class="icon"><i data-lucide="x"></i></span>None</div>
          <div class="dev-btn active" data-device="iphone16"><span class="icon"><i data-lucide="smartphone"></i></span>iPhone 16</div>
          <div class="dev-btn" data-device="ipadpro"><span class="icon"><i data-lucide="tablet"></i></span>iPad Pro</div>
          <div class="dev-btn" data-device="macbookpro"><span class="icon"><i data-lucide="monitor"></i></span>MacBook</div>
          <div class="dev-btn" data-device="applewatch"><span class="icon"><i data-lucide="watch"></i></span>Watch</div>
        </div>
        <div id="colorSwatches" class="color-swatches"></div>
        <div class="toggle-row" id="deviceToggles">
          <button class="toggle-btn" id="landscapeBtn">Landscape</button>
          <button class="toggle-btn" id="comparisonBtn">Compare</button>
        </div>
        <div class="prop-row" style="margin-top:8px">
          <label>Quick Presets</label>
          <select id="devicePresetSelect" style="flex:1">
            <option value="">-- Choose Position --</option>
            <option value="phoneLeft"> Phone Left</option>
            <option value="phoneRight"> Phone Right</option>
            <option value="phoneCenterZoom"> Center Zoom</option>
            <option value="dualComparison"> Dual Comparison</option>
            <option value="tilt3D"> 3D Tilt</option>
            <option value="landscapeView"> Landscape</option>
            <option value="floatingAbove"> Floating</option>
            <option value="bottomCorner"> Corner</option>
            <option value="laptopDesk"> Laptop</option>
            <option value="tabletPresenter"> Tablet</option>
          </select>
        </div>
      </div>
    </div>

    <div class="panel-section comparison-controls" id="comparisonControls">
      <div class="section-header">
        <h3>Device 2</h3>
        <button class="btn btn-danger" id="disableCompareBtn">Disable</button>
      </div>
      <div class="device-grid" id="device2Grid">
        <div class="dev-btn active" data-device="ipadpro"><span class="icon"><i data-lucide="tablet"></i></span>iPad Pro</div>
        <div class="dev-btn" data-device="iphone16"><span class="icon"><i data-lucide="smartphone"></i></span>iPhone 16</div>
        <div class="dev-btn" data-device="macbookpro"><span class="icon"><i data-lucide="monitor"></i></span>MacBook</div>
        <div class="dev-btn" data-device="applewatch"><span class="icon"><i data-lucide="watch"></i></span>Watch</div>
      </div>
      <div id="colorSwatches2" class="color-swatches"></div>
      <button class="btn" id="loadVideo2Btn" style="width:100%;margin-top:6px">Load Video for Device 2</button>
      <input type="file" id="video2Input" accept="video/*" style="display:none">
      <p id="video2Status" style="font-size:9px;color:#555;margin-top:4px">No video loaded for Device 2</p>
    </div>

    <div class="panel-section" id="deviceKeyframesSection" style="display:none">
      <h3>Device Animation</h3>
      <div style="display:flex;gap:4px;margin-bottom:8px">
        <button class="btn" id="addDeviceKeyframeBtn" style="flex:1">
           Add Keyframe
        </button>
        <button class="btn" id="clearDeviceKeyframesBtn" style="flex:1;color:#f66">
          Clear All
        </button>
      </div>
      <div id="deviceKeyframesList" style="max-height:150px;overflow-y:auto">
        <!-- Keyframes will be listed here -->
      </div>
      <div style="margin-top:8px;font-size:11px;color:rgba(255,255,255,0.4)">
        Keyframes: Position, Scale, Rotation, Perspective
      </div>
    </div>

    <div class="panel-section" id="standstillSection" style="display:none">
      <h3>Standstill Mode</h3>
      <select id="standstillModeSelect" style="width:100%;margin-bottom:8px">
        <option value="none">None (Normal Playback)</option>
        <option value="freezeDevice">Freeze Device, Loop Content</option>
        <option value="freezeBoth">Freeze Everything</option>
        <option value="pauseAnimation">Pause Animation Only</option>
      </select>
      <div id="freezeTimeControl" style="display:none;margin-top:8px">
        <label>Freeze At:</label>
        <input type="number" id="freezeTimeInput" min="0" step="0.1" value="0" style="width:80px">
        <button class="btn-sm" id="setFreezeTimeBtn">Use Current</button>
      </div>
      <div id="contentLoopControl" style="display:none;margin-top:8px">
        <label>Content Loop:</label>
        <input type="number" id="contentLoopStart" min="0" max="1" step="0.1" value="0" style="width:60px">
        <span>to</span>
        <input type="number" id="contentLoopEnd" min="0" max="1" step="0.1" value="1" style="width:60px">
      </div>
    </div>

    <div class="panel-section">
      <div class="section-header">
        <h3>Layers</h3>
        <button class="btn btn-danger" id="clearLayersBtn">Clear</button>
      </div>
      <div class="unified-layers" id="unifiedLayers"></div>
      <div class="layer-actions">
        <button class="btn" id="quickAddText">+ Text</button>
        <button class="btn" id="quickAddLogo">+ Logo</button>
      </div>
      <div class="layer-detail" id="layerDetail" style="display:none"></div>
      <div style="margin-top:8px">
        <button class="btn" id="advLayerToggle" style="width:100%;font-size:8px;color:#555">Advanced Render Order</button>
        <div id="advLayerPanel" style="display:none;margin-top:6px">
          <div class="adv-label">Drag to reorder render groups</div>
          <div class="adv-stack" id="advStack"></div>
        </div>
      </div>
      <ul class="layer-list" id="layerList"></ul>
    </div>

    <div class="panel-section">
      <div class="section-header">
        <h3>Hand Overlay</h3>
        <button class="btn btn-danger" id="resetHandBtn" style="display:none">Off</button>
      </div>
      <div class="toggle-row">
        <button class="toggle-btn" id="handBtn">Enable Hand</button>
        <select id="handStyle" style="background:rgba(255,255,255,0.07);border:1px solid rgba(255,255,255,0.1);border-radius:4px;color:#ccc;padding:2px 4px;font-size:10px">
          <option value="right">Right Hand</option>
          <option value="left">Left Hand</option>
        </select>
      </div>
    </div>

    <div class="panel-section">
      <div class="section-header">
        <h3>Scene Templates</h3>
        <button class="btn btn-danger" id="resetSceneBtn">Reset</button>
      </div>
      <div class="device-grid" id="sceneGrid">
        <div class="dev-btn active" data-scene="custom"><span class="icon"></span>Custom</div>
        <div class="dev-btn" data-scene="floating"><span class="icon"></span>Floating</div>
        <div class="dev-btn" data-scene="neon"><span class="icon"></span>Neon Glow</div>
        <div class="dev-btn" data-scene="sunset"><span class="icon"></span>Sunset</div>
        <div class="dev-btn" data-scene="minimal"><span class="icon"></span>Minimal</div>
        <div class="dev-btn" data-scene="ocean"><span class="icon"></span>Ocean</div>
        <div class="dev-btn" data-scene="forest"><span class="icon"></span>Forest</div>
        <div class="dev-btn" data-scene="cinematic"><span class="icon"></span>Cinematic</div>
      </div>
    </div>

    <div class="panel-section">
      <div class="section-header">
        <h3>Animation Presets</h3>
        <button class="btn btn-danger" id="clearAnimPresetBtn">Stop</button>
      </div>
      <div class="device-grid" id="animPresetGrid">
        <div class="dev-btn active" data-anim="none"><span class="icon"></span>None</div>
        <div class="dev-btn" data-anim="zoomBeat"><span class="icon"></span>Zoom Beat</div>
        <div class="dev-btn" data-anim="velocityEdit"><span class="icon"></span>Velocity</div>
        <div class="dev-btn" data-anim="smoothSlide"><span class="icon"></span>Slide</div>
        <div class="dev-btn" data-anim="bounceIn"><span class="icon"></span>Bounce</div>
        <div class="dev-btn" data-anim="glitch"><span class="icon"></span>Glitch</div>
        <div class="dev-btn" data-anim="cinematicPan"><span class="icon"></span>Cine Pan</div>
        <div class="dev-btn" data-anim="shake"><span class="icon"></span>Shake</div>
      </div>
      <div class="prop-row" style="margin-top:8px"><label>Intensity</label><input type="range" id="animIntensity" min="10" max="200" value="100"></div>
      <div class="prop-row"><label>BPM</label><input type="range" id="animBPM" min="60" max="200" value="120"><span id="animBPMVal" style="font-size:9px;color:#666;min-width:30px">120</span></div>
      <div class="prop-row"><label>Auto BPM</label><button class="toggle-btn" id="autoBPMBtn" style="font-size:9px;padding:2px 8px">Off</button><span id="autoBPMStatus" style="font-size:8px;color:#555;margin-left:4px"></span></div>
      <div style="margin-top:6px">
        <button class="btn" id="importCapcutBtn" style="width:100%;font-size:9px">Import CapCut Draft</button>
        <input type="file" id="capcutFileInput" accept=".json,application/json" style="display:none">
        <p style="font-size:8px;color:#555;margin-top:3px">Upload draft_content.json from CapCut Desktop project folder</p>
      </div>
    </div>
    </div>
  </div>

  <!-- Canvas Stage -->
  <div class="stage" id="stage">
    <div class="canvas-wrap" id="canvasWrap">
      <canvas id="renderCanvas"></canvas>
      <div class="canvas-prompt visible" id="prompt">
        <svg viewBox="0 0 24 24"><path d="M19 13h-6v6h-2v-6H5v-2h6V5h2v6h6v2z"/></svg>
        <p>Drop a screen recording here<br>or click to load</p>
        <p class="sub">MP4 / MOV / WebM</p>
      </div>
    </div>
  </div>

  <!-- Right Panel -->
  <div class="panel right-panel" id="rightPanel">
    <div class="panel-header">
      <h3 class="panel-title">Effects</h3>
      <button class="panel-toggle" id="rightPanelToggle" title="Toggle right panel ]"></button>
    </div>
    <div class="panel-body">
    <div class="panel-section">
      <div class="section-header">
        <h3>Background</h3>
        <button class="btn btn-danger" id="resetBgBtn">Reset</button>
      </div>
      <div class="prop-row">
        <label>Type</label>
        <select id="bgType">
          <option value="solid">Solid</option>
          <option value="gradient">Gradient</option>
          <option value="transparent">Transparent</option>
        </select>
      </div>
      <div id="bgSolidControls">
        <div class="prop-row"><label>Color</label><input type="color" id="bgColor" value="#0a0a0a"></div>
      </div>
      <div id="bgGradientControls" style="display:none">
        <div class="prop-row"><label>Color 1</label><input type="color" id="gradColor1" value="#0f0c29"></div>
        <div class="prop-row"><label>Color 2</label><input type="color" id="gradColor2" value="#302b63"></div>
        <div class="prop-row"><label>Color 3</label><input type="color" id="gradColor3" value="#24243e"></div>
        <div class="prop-row"><label>Angle</label><input type="range" id="gradAngle" min="0" max="360" value="135"></div>
        <div class="prop-row"><label>Animate</label>
          <select id="gradAnimated"><option value="false">Off</option><option value="true">On</option></select>
        </div>
      </div>
      <div class="prop-row"><label>Shadow</label><input type="range" id="shadowSlider" min="0" max="100" value="60"></div>
      <div style="margin-top:8px;border-top:1px solid rgba(255,255,255,0.04);padding-top:8px">
        <div class="section-header" style="margin-bottom:4px">
          <label style="font-size:9px;color:#666;font-weight:600">BG VIDEO</label>
          <button class="btn btn-danger" id="removeBgVideoBtn" style="display:none;padding:1px 6px;font-size:8px">Remove</button>
        </div>
        <button class="btn" id="loadBgVideoBtn" style="width:100%;font-size:9px">Load Background Video</button>
        <input type="file" id="bgVideoInput" accept="video/*" style="display:none">
        <p id="bgVideoStatus" style="font-size:8px;color:#555;margin-top:3px"></p>
        <div id="bgVideoControls" style="display:none">
          <div class="prop-row"><label>Opacity</label><input type="range" id="bgVideoOpacity" min="0" max="100" value="100"><span id="bgVideoOpacityVal" style="font-size:9px;color:#666;min-width:28px">100%</span></div>
          <div class="prop-row"><label>Fit</label>
            <select id="bgVideoFit">
              <option value="cover">Cover</option>
              <option value="contain">Contain</option>
              <option value="stretch">Stretch</option>
            </select>
          </div>
        </div>
      </div>
      <div style="margin-top:8px;border-top:1px solid rgba(255,255,255,0.04);padding-top:8px">
        <div class="section-header" style="margin-bottom:4px">
          <label style="font-size:9px;color:#666;font-weight:600">BG AUDIO</label>
        </div>
        <button class="btn" id="loadBgAudioBtn" style="width:100%;font-size:9px">Load Background Audio (MP3)</button>
        <input type="file" id="bgAudioInput" accept="audio/*" style="display:none">
        <p id="bgAudioStatus" style="font-size:8px;color:#555;margin-top:3px"></p>
      </div>
    </div>

    <div class="panel-section">
      <div class="section-header">
        <h3>Chroma Key (BG Remove)</h3>
        <button class="btn btn-danger" id="resetChromaBtn">Off</button>
      </div>
      <div class="prop-row"><label>Enable</label>
        <select id="chromaToggle"><option value="false">Off</option><option value="true">On</option></select>
      </div>
      <div id="chromaControls" style="display:none">
        <div class="prop-row"><label>Key Color</label><input type="color" id="chromaColor" value="#00ff00"></div>
        <div class="prop-row"><label>Tolerance</label><input type="range" id="chromaTolerance" min="10" max="200" value="80"></div>
        <div class="prop-row"><label>Softness</label><input type="range" id="chromaSoftness" min="0" max="80" value="10"></div>
        <p style="font-size:9px;color:#555;margin-top:4px">Pick the background color from your video to remove it. Works best with solid-color backgrounds.</p>
      </div>
    </div>

    <div class="panel-section">
      <div class="section-header">
        <h3>Effects</h3>
        <button class="btn btn-danger" id="resetEffectsBtn">Reset</button>
      </div>
      <div class="prop-row"><label>Particles</label>
        <select id="particleType">
          <option value="off">Off</option>
          <option value="bokeh">Bokeh</option>
          <option value="sparkle">Sparkle</option>
          <option value="confetti">Confetti</option>
          <option value="snow">Snow</option>
        </select>
      </div>
      <div class="prop-row"><label>Count</label><input type="range" id="particleCount" min="5" max="80" value="30"></div>
      <div class="prop-row"><label>Color</label><input type="color" id="particleColor" value="#ffffff"></div>
      <div class="prop-row"><label>Orbit</label>
        <select id="orbitToggle"><option value="false">Off</option><option value="true">On</option></select>
      </div>
      <div class="prop-row"><label>Speed</label><input type="range" id="orbitSpeed" min="5" max="100" value="30"></div>
      <div class="prop-row"><label>Blur</label>
        <select id="motionBlurToggle"><option value="false">Off</option><option value="true">On</option></select>
      </div>
    </div>

    <div class="panel-section">
      <div class="section-header">
        <h3>Overlays</h3>
        <button class="btn btn-danger" id="resetOverlaysBtn">Reset</button>
      </div>
      <div class="prop-row"><label>Progress</label>
        <select id="progressToggle"><option value="false">Off</option><option value="true">On</option></select>
        <input type="color" id="progressColor" value="#60a5fa">
      </div>
      <div class="prop-row"><label>Waveform</label>
        <select id="waveformToggle"><option value="false">Off</option><option value="true">On</option></select>
        <input type="color" id="waveformColor" value="#60a5fa">
      </div>
      <div class="prop-row"><label>Glass CTA</label>
        <select id="glassToggle"><option value="false">Off</option><option value="true">On</option></select>
      </div>
      <div id="glassControls" style="display:none">
        <div class="prop-row"><label>Text</label><input type="text" id="glassText" value="Your CTA Here"></div>
        <div class="prop-row"><label>Blur</label><input type="range" id="glassBlur" min="4" max="30" value="12"></div>
        <div class="prop-row"><label>Opacity</label><input type="range" id="glassOpacity" min="5" max="50" value="15"></div>
      </div>
    </div>

    <div class="panel-section">
      <div class="section-header">
        <h3>Video Overlays</h3>
        <button class="btn btn-danger" id="clearVideoOverlaysBtn">Clear</button>
      </div>
      <p style="font-size:8px;color:#555;margin-bottom:6px">Built-in effects (no files needed):</p>
      <div class="device-grid" id="builtinOverlayGrid" style="margin-bottom:8px">
        <div class="dev-btn" data-builtin="filmGrain">Film Grain</div>
        <div class="dev-btn" data-builtin="lightLeak">Light Leak</div>
        <div class="dev-btn" data-builtin="bokehLights">Bokeh</div>
        <div class="dev-btn" data-builtin="dust">Dust</div>
        <div class="dev-btn" data-builtin="vignette">Vignette</div>
        <div class="dev-btn" data-builtin="chromatic">Chromatic</div>
        <div class="dev-btn" data-builtin="scanlines">Scanlines</div>
        <div class="dev-btn" data-builtin="filmBurn">Film Burn</div>
      </div>
      <p style="font-size:8px;color:#555;margin-bottom:4px">Or load your own overlay videos:</p>
      <button class="btn" id="addVideoOverlayBtn" style="width:100%;margin-bottom:6px">+ Add Overlay Video</button>
      <input type="file" id="videoOverlayInput" accept="video/*" style="display:none" multiple>
      <div id="videoOverlayList"></div>
    </div>

    <div class="panel-section">
      <div class="section-header">
        <h3>Color Grading (LUT)</h3>
        <button class="btn btn-danger" id="clearLutBtn">Remove</button>
      </div>
      <p style="font-size:8px;color:#555;margin-bottom:6px">Quick presets:</p>
      <div class="device-grid" id="lutPresetGrid" style="margin-bottom:8px">
        <div class="dev-btn" data-lut-preset="none">None</div>
        <div class="dev-btn" data-lut-preset="cinematic">Cinematic</div>
        <div class="dev-btn" data-lut-preset="warmVintage">Warm Vintage</div>
        <div class="dev-btn" data-lut-preset="coolTeal">Cool Teal</div>
        <div class="dev-btn" data-lut-preset="bleachBypass">Bleach</div>
        <div class="dev-btn" data-lut-preset="moody">Moody</div>
        <div class="dev-btn" data-lut-preset="orangeTeal">Orange&Teal</div>
        <div class="dev-btn" data-lut-preset="bw">B&W Film</div>
      </div>
      <p style="font-size:8px;color:#555;margin-bottom:4px">Or load a .CUBE file:</p>
      <button class="btn" id="loadLutBtn" style="width:100%;margin-bottom:6px">Load .CUBE LUT</button>
      <input type="file" id="lutFileInput" accept=".cube,.CUBE" style="display:none">
      <div id="lutInfo" style="font-size:9px;color:#666;margin-top:4px"></div>
      <div id="lutControls" style="display:none">
        <div class="prop-row"><label>Intensity</label><input type="range" id="lutIntensity" min="0" max="100" value="100"><span id="lutIntensityVal" style="font-size:9px;color:#666;min-width:28px">100%</span></div>
      </div>
    </div>

    <div class="panel-section">
      <div class="section-header">
        <h3>Device Transform</h3>
        <button class="btn btn-danger" id="resetTransformBtn">Reset</button>
      </div>
      <div class="prop-row">
        <label>Scale</label>
        <input type="range" id="scaleSlider" min="15" max="100" value="45">
        <span id="scaleVal" style="font-size:10px;color:#777;min-width:28px">45%</span>
      </div>
      <div class="prop-row">
        <label>Fit</label>
        <select id="videoFitMode">
          <option value="cover">Cover</option>
          <option value="contain">Contain</option>
          <option value="stretch">Stretch</option>
        </select>
      </div>
      <div class="prop-row">
        <label>Tilt X</label>
        <input type="range" id="tiltX" min="-30" max="30" value="0">
      </div>
      <div class="prop-row">
        <label>Tilt Y</label>
        <input type="range" id="tiltY" min="-30" max="30" value="0">
      </div>
    </div>

    <div class="panel-section">
      <h3>Content</h3>
      <button class="btn" id="addTextBtn" style="width:100%;margin-bottom:6px">+ Add Text</button>
      <button class="btn" id="addLogoBtn" style="width:100%;margin-bottom:6px">+ Add Logo</button>
    </div>

    <div class="panel-section" id="textProps" style="display:none">
      <h3>Text Properties</h3>
      <div class="prop-row"><label>Text</label><input type="text" id="textContent" value="Title"></div>
      <div class="prop-row"><label>Font</label>
        <select id="textFont">
          <option value="SF Pro Display, -apple-system, sans-serif">SF Pro</option>
          <option value="Georgia, serif">Georgia</option>
          <option value="Courier New, monospace">Courier</option>
          <option value="Impact, sans-serif">Impact</option>
          <option value="Arial, sans-serif">Arial</option>
        </select>
      </div>
      <div class="prop-row"><label>Size</label><input type="range" id="textSize" min="12" max="120" value="36"></div>
      <div class="prop-row"><label>Color</label><input type="color" id="textColor" value="#ffffff"></div>
      <div class="prop-row"><label>Weight</label>
        <select id="textWeight">
          <option value="400">Regular</option>
          <option value="600">Semi Bold</option>
          <option value="700" selected>Bold</option>
          <option value="900">Black</option>
        </select>
      </div>
      <div class="prop-row"><label>Shadow</label><input type="range" id="textShadow" min="0" max="20" value="0"></div>
      <div class="prop-row"><label>Outline</label><input type="range" id="textOutline" min="0" max="10" value="0"></div>
    </div>

    <div class="panel-section" id="logoProps" style="display:none">
      <h3>Logo Properties</h3>
      <div class="prop-row"><label>Opacity</label><input type="range" id="logoOpacity" min="0" max="100" value="100"></div>
      <div class="prop-row"><label>Width</label><input type="range" id="logoWidth" min="20" max="400" value="100"></div>
    </div>

    <div class="panel-section">
      <div class="section-header">
        <h3>Annotations</h3>
        <button class="btn btn-danger" id="clearAnnotationsBtn">Clear</button>
      </div>
      <div class="anno-toolbar" id="annoToolbar">
        <button class="anno-btn" data-tool="arrow">Arrow</button>
        <button class="anno-btn" data-tool="circle">Circle</button>
        <button class="anno-btn" data-tool="rect">Rect</button>
        <button class="anno-btn" data-tool="freehand">Draw</button>
        <button class="anno-btn" data-tool="callout">Callout</button>
      </div>
      <div class="prop-row"><label>Color</label><input type="color" id="annoColor" value="#ff4444"></div>
      <div class="prop-row"><label>Width</label><input type="range" id="annoWidth" min="1" max="10" value="3"></div>
      <div id="annoTimingControls" style="display:none;margin-top:6px;padding:6px 0;border-top:1px solid rgba(255,255,255,0.06)">
        <div style="font-size:9px;color:#666;margin-bottom:4px">Timing (selected annotation)</div>
        <div class="prop-row"><label>Start (s)</label><input type="number" id="annoStartTime" min="0" step="0.1" style="width:70px;background:rgba(255,255,255,0.07);border:1px solid rgba(255,255,255,0.1);border-radius:4px;color:#ccc;padding:3px 6px;font-size:11px"></div>
        <div class="prop-row"><label>End (s)</label><input type="number" id="annoEndTime" min="0" step="0.1" style="width:70px;background:rgba(255,255,255,0.07);border:1px solid rgba(255,255,255,0.1);border-radius:4px;color:#ccc;padding:3px 6px;font-size:11px"></div>
        <div class="prop-row"><label>Duration</label><span id="annoDuration" style="font-size:10px;color:#888">5.0s</span></div>
        <div class="prop-row"><label>Full video</label><input type="checkbox" id="annoFullVideo"></div>
      </div>
    </div>

    <div class="panel-section">
      <h3>Facecam</h3>
      <div style="display:flex;gap:4px;margin-bottom:6px">
        <button class="btn" id="facecamBtn" style="flex:1">Webcam</button>
        <button class="btn" id="facecamFileBtn" style="flex:1">Video File</button>
      </div>
      <input type="file" id="facecamFileInput" accept="video/*">
      <div id="facecamProps" style="display:none">
        <div class="prop-row"><label>Size</label><input type="range" id="facecamSize" min="5" max="35" value="15"><span id="facecamSizeVal" style="font-size:9px;color:#666;min-width:24px">15%</span></div>
        <div class="prop-row"><label>Shape</label>
          <select id="facecamShape">
            <option value="circle">Circle</option>
            <option value="roundrect">Rounded Rect</option>
            <option value="square">Square</option>
          </select>
        </div>
        <div class="prop-row"><label>Corner</label>
          <select id="facecamCorner">
            <option value="BR">Bottom Right</option>
            <option value="BL">Bottom Left</option>
            <option value="TR">Top Right</option>
            <option value="TL">Top Left</option>
            <option value="custom">Free Position</option>
          </select>
        </div>
        <div class="prop-row"><label>Border</label><input type="color" id="facecamBorderColor" value="#ffffff"><input type="range" id="facecamBorderWidth" min="0" max="8" value="3" style="flex:1"></div>
        <div class="prop-row"><label>Shadow</label>
          <select id="facecamShadow">
            <option value="true">On</option>
            <option value="false">Off</option>
          </select>
        </div>
        <button class="btn" id="facecamDisableBtn" style="width:100%;margin-top:4px;color:#f66;border-color:rgba(255,100,100,0.2)">Disable Facecam</button>
        <p style="font-size:9px;color:#555;margin-top:4px">Drag the facecam circle on the canvas to reposition</p>
      </div>
    </div>

    <div class="panel-section">
      <div class="section-header">
        <h3>Zoom Keyframes</h3>
        <button class="btn btn-danger" id="clearKeyframesBtn">Clear</button>
      </div>
      <button class="btn" id="addKeyframeBtn" style="width:100%;margin-bottom:6px">+ Add Keyframe</button>
      <div class="prop-row"><label>Zoom</label><input type="range" id="kfZoom" min="100" max="300" value="100"></div>
      <div class="prop-row"><label>Pan X</label><input type="range" id="kfPanX" min="-200" max="200" value="0"></div>
      <div class="prop-row"><label>Pan Y</label><input type="range" id="kfPanY" min="-200" max="200" value="0"></div>
    </div>

    <div class="panel-section">
      <h3>Project</h3>
      <div style="display:flex;gap:4px;margin-bottom:6px">
        <button class="btn" id="saveProjectBtn" style="flex:1">Save Project</button>
        <button class="btn" id="loadProjectBtn" style="flex:1">Load Project</button>
      </div>
      <input type="file" id="projectFileInput" accept=".json,application/json" style="display:none">
      <button class="btn" id="resetAllBtn" style="width:100%;color:#f66;border-color:rgba(255,100,100,0.2)">Reset All</button>
    </div>
    </div>
  </div>
</div>

<!-- Enhanced Multi-Track Timeline System -->
<div class="timeline-system" id="timelineSystem">

  <!-- Background Audio Track -->
  <div class="bg-audio-track" id="bgAudioTrack">
    <div class="track-header" id="audioTrackHeader">
      <div class="track-indicator" style="background: linear-gradient(135deg, #f59e0b, #d97706);"></div>
      <div class="track-label">
        <span class="track-label-icon"></span>
        Background Audio
      </div>
      <div style="flex: 1"></div>
      <div class="track-actions">
        <button class="track-action-btn" id="bgAudioActionsBtn" title="Quick Actions" aria-label="Background audio quick actions" aria-expanded="false" aria-haspopup="true"></button>
        <div class="track-actions-dropdown" id="bgAudioActionsDropdown" role="menu" aria-labelledby="bgAudioActionsBtn">
          <button onclick="applyBgAudioAction('fadeInAudio', 2000)"> Fade In (2s)</button>
          <button onclick="applyBgAudioAction('fadeOutAudio', 2000)"> Fade Out (2s)</button>
          <button onclick="applyBgAudioAction('fadeInSlow')"> Fade In (5s)</button>
          <button onclick="applyBgAudioAction('fadeOutSlow')"> Fade Out (5s)</button>
          <button onclick="applyBgAudioAction('ducking')"> Ducking (30%)</button>
          <button onclick="applyBgAudioAction('loopBeat')"> Loop Beat</button>
          <button onclick="applyBgAudioAction('speedMatch')"> Speed Match</button>
          <button onclick="applyBgAudioAction('volumeBoost')"> Boost (100%)</button>
          <button onclick="applyBgAudioAction('bassBoost')"> Bass Boost</button>
          <button onclick="applyBgAudioAction('reverb')"> Add Reverb</button>
          <button onclick="applyBgAudioAction('syncAudio')"> Sync to Main</button>
          <button onclick="applyBgAudioAction('resetAudio')"> Reset</button>
        </div>
      </div>
      <button class="track-loop-btn" id="audioLoopMarkerBtn" title="Loop Region" aria-label="Configure audio loop region" aria-expanded="false" aria-haspopup="true"></button>
      <div class="track-loop-controls" id="audioLoopControls">
        <label style="font-size:10px">Loop Start:</label>
        <input type="number" id="audioLoopStart" min="0" max="1" step="0.1" value="0" style="width:60px">
        <label style="font-size:10px">End:</label>
        <input type="number" id="audioLoopEnd" min="0" max="1" step="0.1" value="1" style="width:60px">
        <button class="btn-sm" onclick="toggleAudioLoop()">Enable</button>
      </div>
      <button class="track-sync-btn" id="audioSyncBtn" title="Sync with main video">
        <span class="sync-icon"></span> Sync
      </button>
      <button class="track-collapse-btn" id="audioCollapseBtn" title="Collapse/Expand track"></button>
    </div>

    <div class="bg-track-content">
      <div class="bg-video-controls">
        <button class="track-play-btn" id="audioTrackPlayBtn" title="Play/Pause audio">
          <svg class="play-icon" viewBox="0 0 24 24"><path d="M8 5v14l11-7z"/></svg>
          <svg class="pause-icon" style="display:none" viewBox="0 0 24 24"><path d="M6 19h4V5H6v14zm8-14v14h4V5h-4z"/></svg>
        </button>
        <button class="track-loop-btn" id="audioLoopBtn" title="Toggle loop">
          
        </button>
        <input type="range" id="audioVolumeSlider" min="0" max="100" value="100" title="Volume" style="width: 60px; margin: 0 4px;">
      </div>

      <div class="bg-progress-track" id="audioProgressTrack">
        <div class="bg-progress-fill" id="audioProgressFill" style="background: linear-gradient(90deg, rgba(245,158,11,0.3) 0%, rgba(245,158,11,0.2) 100%); border-right-color: rgba(245,158,11,0.8);">
          <div class="bg-progress-handle" style="background: linear-gradient(135deg, #f59e0b, #d97706); box-shadow: 0 2px 8px rgba(245,158,11,0.4), 0 0 0 3px rgba(245,158,11,0.2);"></div>
          <div class="bg-progress-waveform"></div>
        </div>
      </div>

      <div class="bg-video-options">
        <span class="bg-time-display" id="audioTimeDisplay">0:00 / 0:00</span>
        <select class="track-speed-select" id="audioSpeedSelect">
          <option value="0.5">0.5</option>
          <option value="0.75">0.75</option>
          <option value="1" selected>1</option>
          <option value="1.25">1.25</option>
          <option value="1.5">1.5</option>
          <option value="2">2</option>
        </select>
        <button class="btn btn-danger" id="removeAudioBtn" style="padding: 4px 8px; font-size: 9px;">Remove</button>
      </div>

      <!-- Audio Effects Panel -->
      <div class="track-effects-section collapsed" id="bgAudioEffectsSection">
        <button class="effects-toggle-btn" id="bgAudioEffectsToggle">
           Audio Effects
        </button>
        <div class="effects-panel">
          <!-- Mixing Section -->
          <div class="effect-group">
            <h4>Mixing</h4>
            <div class="effect-control">
              <label>Volume</label>
              <input type="range" id="bgAudioVolumeFX" min="0" max="200" value="100">
              <span class="value">100%</span>
            </div>
            <div class="effect-control">
              <label>Pan</label>
              <input type="range" id="bgAudioPan" min="-100" max="100" value="0">
              <span class="value">Center</span>
            </div>
            <button class="solo-btn" data-track="bgAudio">Solo</button>
            <button class="mute-btn" data-track="bgAudio">Mute</button>
          </div>

          <!-- EQ Section -->
          <div class="effect-group">
            <h4>Equalizer (3-Band)</h4>
            <canvas class="eq-graph" id="bgAudioEQGraph" width="200" height="80"></canvas>
            <div class="effect-control">
              <label>Low (200Hz)</label>
              <input type="range" id="bgAudioEQLow" min="-12" max="12" value="0" step="0.5">
              <span class="value">0 dB</span>
            </div>
            <div class="effect-control">
              <label>Mid (1kHz)</label>
              <input type="range" id="bgAudioEQMid" min="-12" max="12" value="0" step="0.5">
              <span class="value">0 dB</span>
            </div>
            <div class="effect-control">
              <label>High (3kHz)</label>
              <input type="range" id="bgAudioEQHigh" min="-12" max="12" value="0" step="0.5">
              <span class="value">0 dB</span>
            </div>
          </div>

          <!-- Compressor Section -->
          <div class="effect-group">
            <h4>Compressor</h4>
            <label>
              <input type="checkbox" id="bgAudioCompressorEnable">
              Enable
            </label>
            <div class="compressor-controls" id="bgAudioCompressorControls" style="display:none">
              <div class="effect-control">
                <label>Threshold</label>
                <input type="range" id="bgAudioCompThreshold" min="-60" max="0" value="-24">
                <span class="value">-24 dB</span>
              </div>
              <div class="effect-control">
                <label>Ratio</label>
                <select id="bgAudioCompRatio">
                  <option value="1.5">1.5:1</option>
                  <option value="3" selected>3:1</option>
                  <option value="8">8:1</option>
                  <option value="20">20:1 (Limiter)</option>
                </select>
              </div>
            </div>
          </div>

          <!-- Effects Section -->
          <div class="effect-group">
            <h4>Effects</h4>
            <label>
              <input type="checkbox" id="bgAudioReverbEnable">
              Reverb
            </label>
            <label>
              <input type="checkbox" id="bgAudioEchoEnable">
              Echo/Delay
            </label>
          </div>

          <!-- Presets -->
          <div class="effect-group">
            <h4>Presets</h4>
            <select id="bgAudioPreset">
              <option value="">-- Load Preset --</option>
              <option value="podcast">Podcast Voice</option>
              <option value="music">Music Enhancement</option>
              <option value="bass">Bass Boost</option>
              <option value="vocal">Vocal Clarity</option>
              <option value="radio">Radio Effect</option>
              <option value="spacious">Spacious Reverb</option>
            </select>
            <button class="save-preset-btn" id="bgAudioSavePreset">Save Custom</button>
          </div>
        </div>
      </div>
    </div>
  </div>

  <!-- Background Video Track -->
  <div class="bg-video-track" id="bgVideoTrack">
    <div class="track-header" id="bgVideoTrackHeader">
      <div class="track-indicator bg-video"></div>
      <div class="track-label">
        <span class="track-label-icon"></span>
        Background Video
      </div>
      <div style="flex: 1"></div>
      <div class="track-actions">
        <button class="track-action-btn" id="bgVideoActionsBtn" title="Quick Actions" aria-label="Background video quick actions" aria-expanded="false" aria-haspopup="true"></button>
        <div class="track-actions-dropdown" id="bgVideoActionsDropdown" role="menu" aria-labelledby="bgVideoActionsBtn">
          <button onclick="applyBgVideoAction('fadeIn', 2000)"> Fade In (2s)</button>
          <button onclick="applyBgVideoAction('fadeOut', 2000)"> Fade Out (2s)</button>
          <button onclick="applyBgVideoAction('overlayMode')"> Overlay Mode (50%)</button>
          <button onclick="applyBgVideoAction('blurBackground')"> Blur Background</button>
          <button onclick="applyBgVideoAction('blackAndWhite')"> Black & White</button>
          <button onclick="applyBgVideoAction('splitScreen')"> Split Screen</button>
          <button onclick="applyBgVideoAction('resetFilters')"> Reset Filters</button>
          <button onclick="applyBgVideoAction('syncPerfect')"> Sync to Main</button>
          <button onclick="applyBgVideoAction('speedSlow')"> Slow (0.5x)</button>
          <button onclick="applyBgVideoAction('speedFast')"> Fast (2x)</button>
          <button onclick="applyBgVideoAction('enableLoop')"> Loop</button>
          <button onclick="applyBgVideoAction('resetToStart')"> Reset</button>
        </div>
      </div>
      <button class="track-loop-btn" id="videoLoopMarkerBtn" title="Loop Region" aria-label="Configure video loop region" aria-expanded="false" aria-haspopup="true"></button>
      <div class="track-loop-controls" id="videoLoopControls">
        <label style="font-size:10px">Loop Start:</label>
        <input type="number" id="videoLoopStart" min="0" max="1" step="0.1" value="0" style="width:60px">
        <label style="font-size:10px">End:</label>
        <input type="number" id="videoLoopEnd" min="0" max="1" step="0.1" value="1" style="width:60px">
        <button class="btn-sm" onclick="toggleVideoLoop()">Enable</button>
      </div>
      <button class="track-sync-btn" id="bgSyncBtn" title="Sync with main video">
        <span class="sync-icon"></span> Sync
      </button>
      <button class="track-collapse-btn" id="bgVideoCollapseBtn" title="Collapse/Expand track"></button>
    </div>

    <div class="bg-track-content">
      <div class="bg-video-controls">
        <button class="track-play-btn" id="bgTrackPlayBtn" title="Play/Pause background video">
          <svg class="play-icon" viewBox="0 0 24 24"><path d="M8 5v14l11-7z"/></svg>
          <svg class="pause-icon" style="display:none" viewBox="0 0 24 24"><path d="M6 19h4V5H6v14zm8-14v14h4V5h-4z"/></svg>
        </button>
        <button class="track-loop-btn" id="bgLoopBtn" title="Toggle loop">
          
        </button>
      </div>

      <div class="bg-progress-track" id="bgProgressTrack">
        <div class="bg-progress-fill" id="bgProgressFill">
          <div class="bg-progress-handle"></div>
          <div class="bg-progress-waveform"></div>
        </div>
      </div>

      <div class="bg-video-options">
        <span class="bg-time-display" id="bgTimeDisplay">0:00 / 0:00</span>
        <select class="track-speed-select" id="bgSpeedSelect">
          <option value="0.5">0.5</option>
          <option value="0.75">0.75</option>
          <option value="1" selected>1</option>
          <option value="1.25">1.25</option>
          <option value="1.5">1.5</option>
          <option value="2">2</option>
        </select>
      </div>

      <!-- Video Effects Panel -->
      <div class="track-effects-section collapsed" id="bgVideoEffectsSection">
        <button class="effects-toggle-btn" id="bgVideoEffectsToggle">
           Video Effects
        </button>
        <div class="effects-panel">
          <!-- Color Correction -->
          <div class="effect-group">
            <h4>Color Correction</h4>
            <div class="effect-control">
              <label>Brightness</label>
              <input type="range" id="bgVideoBrightness" min="-100" max="100" value="0">
              <span class="value">0</span>
            </div>
            <div class="effect-control">
              <label>Contrast</label>
              <input type="range" id="bgVideoContrast" min="-100" max="100" value="0">
              <span class="value">0</span>
            </div>
            <div class="effect-control">
              <label>Saturation</label>
              <input type="range" id="bgVideoSaturation" min="-100" max="100" value="0">
              <span class="value">0</span>
            </div>
            <div class="effect-control">
              <label>Hue</label>
              <input type="range" id="bgVideoHue" min="-180" max="180" value="0">
              <span class="value">0</span>
            </div>
            <div class="effect-control">
              <label>Temperature</label>
              <input type="range" id="bgVideoTemp" min="-100" max="100" value="0">
              <span class="value">0</span>
            </div>
          </div>

          <!-- Effect Stack -->
          <div class="effect-group">
            <h4>Effect Stack</h4>
            <div class="effect-stack" id="bgVideoEffectStack">
              <span style="font-size: 10px; color: #666;">No effects added</span>
            </div>
            <select id="bgVideoAddEffect">
              <option value="">+ Add Effect</option>
              <option value="blur">Blur</option>
              <option value="sharpen">Sharpen</option>
              <option value="pixelate">Pixelate</option>
              <option value="edgedetect">Edge Detect</option>
              <option value="posterize">Posterize</option>
              <option value="grayscale">Grayscale</option>
              <option value="sepia">Sepia</option>
            </select>
          </div>

          <!-- Blend Modes -->
          <div class="effect-group">
            <h4>Blend Mode</h4>
            <select id="bgVideoBlendMode">
              <option value="normal">Normal</option>
              <option value="multiply">Multiply</option>
              <option value="screen">Screen</option>
              <option value="overlay">Overlay</option>
              <option value="darken">Darken</option>
              <option value="lighten">Lighten</option>
            </select>
          </div>

          <!-- Presets -->
          <div class="effect-group">
            <h4>Presets</h4>
            <select id="bgVideoPreset">
              <option value="">-- Load Preset --</option>
              <option value="cinematic">Cinematic</option>
              <option value="vibrant">Vibrant Pop</option>
              <option value="vintage">Vintage Film</option>
              <option value="bwContrast">B&W Contrast</option>
              <option value="cool">Cool Tone</option>
              <option value="warm">Warm Tone</option>
              <option value="fade">Faded Look</option>
              <option value="dramatic">Dramatic</option>
            </select>
            <button class="save-preset-btn" id="bgVideoSavePreset">Save Custom</button>
          </div>
        </div>
      </div>
    </div>
  </div>

  <!-- Main Device Video Track -->
  <div class="main-video-track" id="mainVideoTrack">
    <div class="track-header" id="mainVideoTrackHeader">
      <div class="track-indicator"></div>
      <div class="track-label">
        <span class="track-label-icon"></span>
        Device Content
      </div>
      <div style="flex: 1"></div>
      <button class="track-collapse-btn" id="mainVideoCollapseBtn" title="Collapse/Expand track"></button>
    </div>

    <div class="main-track-content">
      <div style="min-width: 140px">
        <span id="mainVideoFileName" style="font-size: 10px; color: rgba(255,255,255,0.5); display: block; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;"></span>
      </div>

      <!-- Timeline Track (existing multi-clip timeline) -->
      <div class="timeline-track" id="timelineTrack" style="height: 40px; margin: 0;">
        <div class="timeline-scrubber" id="timelineScrubber"></div>
      </div>

      <div style="display: flex; gap: 8px; align-items: center;">
        <button class="btn" id="addClipBtn" style="font-size: 9px; padding: 4px 8px;">+ Clip</button>
        <select id="transitionSelect" class="track-speed-select" style="min-width: 80px;">
          <option value="cut">Cut</option>
          <option value="crossfade">Crossfade</option>
          <option value="slide">Slide</option>
        </select>
      </div>

      <!-- Main Video Effects Panel -->
      <div class="track-effects-section collapsed" id="mainVideoEffectsSection">
        <button class="effects-toggle-btn" id="mainVideoEffectsToggle">
           Video Effects
        </button>
        <div class="effects-panel">
          <!-- Color Correction -->
          <div class="effect-group">
            <h4>Color Correction</h4>
            <div class="effect-control">
              <label>Brightness</label>
              <input type="range" id="mainVideoBrightness" min="-100" max="100" value="0">
              <span class="value">0</span>
            </div>
            <div class="effect-control">
              <label>Contrast</label>
              <input type="range" id="mainVideoContrast" min="-100" max="100" value="0">
              <span class="value">0</span>
            </div>
            <div class="effect-control">
              <label>Saturation</label>
              <input type="range" id="mainVideoSaturation" min="-100" max="100" value="0">
              <span class="value">0</span>
            </div>
            <div class="effect-control">
              <label>Hue</label>
              <input type="range" id="mainVideoHue" min="-180" max="180" value="0">
              <span class="value">0</span>
            </div>
            <div class="effect-control">
              <label>Temperature</label>
              <input type="range" id="mainVideoTemp" min="-100" max="100" value="0">
              <span class="value">0</span>
            </div>
          </div>

          <!-- Effect Stack -->
          <div class="effect-group">
            <h4>Effect Stack</h4>
            <div class="effect-stack" id="mainVideoEffectStack">
              <span style="font-size: 10px; color: #666;">No effects added</span>
            </div>
            <select id="mainVideoAddEffect">
              <option value="">+ Add Effect</option>
              <option value="blur">Blur</option>
              <option value="sharpen">Sharpen</option>
              <option value="pixelate">Pixelate</option>
              <option value="edgedetect">Edge Detect</option>
              <option value="posterize">Posterize</option>
              <option value="grayscale">Grayscale</option>
              <option value="sepia">Sepia</option>
            </select>
          </div>

          <!-- Presets -->
          <div class="effect-group">
            <h4>Presets</h4>
            <select id="mainVideoPreset">
              <option value="">-- Load Preset --</option>
              <option value="cinematic">Cinematic</option>
              <option value="vibrant">Vibrant Pop</option>
              <option value="vintage">Vintage Film</option>
              <option value="bwContrast">B&W Contrast</option>
              <option value="cool">Cool Tone</option>
              <option value="warm">Warm Tone</option>
              <option value="fade">Faded Look</option>
              <option value="dramatic">Dramatic</option>
            </select>
            <button class="save-preset-btn" id="mainVideoSavePreset">Save Custom</button>
          </div>
        </div>
      </div>
    </div>
  </div>

  <!-- Unified Playback Controls -->
  <div class="unified-controls">
    <button class="master-play-btn" id="masterPlayBtn" title="Play/Pause (Space)">
      <svg id="masterIconPlay" viewBox="0 0 24 24"><path d="M8 5v14l11-7z"/></svg>
      <svg id="masterIconPause" viewBox="0 0 24 24" style="display:none"><path d="M6 19h4V5H6v14zm8-14v14h4V5h-4z"/></svg>
    </button>

    <div class="progress-track" id="progressTrack" style="flex: 1; margin: 0;">
      <div class="progress-fill" id="progressFill">
        <div class="progress-handle">
          <div class="progress-tooltip" id="progressTooltip"></div>
        </div>
      </div>
    </div>

    <span class="master-time-display" id="masterTimeDisplay">0:00 / 0:00</span>

    <select class="track-speed-select" id="speedSelect">
      <option value="0.25">0.25</option>
      <option value="0.5">0.5</option>
      <option value="1" selected>1</option>
      <option value="1.5">1.5</option>
      <option value="2">2</option>
    </select>

    <div class="timeline-zoom-control">
      <button class="zoom-btn" id="zoomOutBtn" title="Zoom out timeline"></button>
      <button class="zoom-btn" id="zoomInBtn" title="Zoom in timeline">+</button>
    </div>
  </div>
</div>

<!-- Legacy elements for compatibility -->
<div class="timeline-bar" id="timelineBar" style="display:none"></div>
<div class="playback-bar" id="playbackBar" style="display:none">
  <button class="play-btn" id="playBtn">
    <svg id="iconPlay" viewBox="0 0 24 24"><path d="M8 5v14l11-7z"/></svg>
    <svg id="iconPause" viewBox="0 0 24 24" style="display:none"><path d="M6 19h4V5H6v14zm8-14v14h4V5h-4z"/></svg>
  </button>
  <span class="time-label" id="timeLabel">0:00 / 0:00</span>
  <span id="videoFileName" style="font-size:10px;color:#666"></span>
</div>

<!-- Drop overlay -->
<div class="drop-overlay" id="dropOverlay">Drop video file</div>

<!-- Asset Browser Modal -->
<div class="asset-browser" id="assetBrowser">
  <div class="asset-browser-header">
    <h2>Asset Library</h2>
    <input type="text" class="ab-search" id="abSearch" placeholder="Search assets...">
    <div style="flex:1"></div>
    <span id="abStatus" style="font-size:9px;color:#555;white-space:nowrap"></span>
    <button class="ab-close" id="abClose">&times;</button>
  </div>
  <div class="asset-browser-body">
    <div class="ab-sidebar" id="abSidebar"></div>
    <div class="ab-content" id="abContent">
      <div class="ab-empty" id="abEmpty">
        <div style="font-size:40px"></div>
        <div>Connect your asset folder</div>
        <p style="font-size:10px;color:#444;max-width:250px;text-align:center">Pick your Google Drive or local folder with LUTs, overlays, and video assets</p>
        <button class="btn btn-primary" id="abPickFolder">Choose Folder</button>
      </div>
    </div>
  </div>
</div>

<!-- Export status -->
<div class="export-status" id="exportStatus">
  <span id="exportText">Exporting...</span>
  <div class="bar"><div class="bar-fill" id="exportBarFill"></div></div>
</div>

<!-- Hidden elements -->
<input type="file" id="fileInput" accept="video/*">
<input type="file" id="logoInput" accept="image/*">
<input type="file" id="clipInput" accept="video/*">
<video id="srcVideo" style="display:none" playsinline></video>
<video id="srcVideo2" style="display:none" playsinline loop></video>
<video id="bgVideo" style="display:none" playsinline loop muted></video>
<audio id="bgAudio" style="display:none"></audio>



<script>
// ============================================================
// TOAST NOTIFICATIONS
// ============================================================
const toastContainer = document.getElementById('toastContainer');
function showToast(message, type) {
  type = type || 'info';
  const el = document.createElement('div');
  el.className = 'toast-item toast-' + type;
  el.textContent = message;
  // Enforce max 3 toasts
  while (toastContainer.children.length >= 3) {
    toastContainer.firstChild.remove();
  }
  toastContainer.appendChild(el);
  // Trigger slide-in
  requestAnimationFrame(() => { requestAnimationFrame(() => { el.classList.add('visible'); }); });
  // Auto-dismiss after 3s
  setTimeout(() => {
    el.classList.remove('visible');
    setTimeout(() => el.remove(), 300);
  }, 3000);
}

// Safe wrapper for drawImage with video elements (video may not be loaded/ready)
function safeDrawImage(ctx, source) {
  try {
    if (!source) return;
    if (source.tagName === 'VIDEO' && (source.readyState < 2 || source.videoWidth === 0)) return;
    ctx.drawImage.apply(ctx, Array.prototype.slice.call(arguments, 1));
  } catch (e) { /* skip frame  video not ready or tainted */ }
}

// Safe wrapper for getImageData (can fail with tainted canvas / CORS)
function safeGetImageData(ctx, x, y, w, h) {
  try {
    return ctx.getImageData(x, y, w, h);
  } catch (e) { return null; }
}

// ============================================================
// HELPER: Rounded rect path
// ============================================================
function rrPath(c, x, y, w, h, r) {
  c.beginPath();
  c.moveTo(x + r, y);
  c.lineTo(x + w - r, y);
  c.quadraticCurveTo(x + w, y, x + w, y + r);
  c.lineTo(x + w, y + h - r);
  c.quadraticCurveTo(x + w, y + h, x + w - r, y + h);
  c.lineTo(x + r, y + h);
  c.quadraticCurveTo(x, y + h, x, y + h - r);
  c.lineTo(x, y + r);
  c.quadraticCurveTo(x, y, x + r, y);
  c.closePath();
}

function pillPath(c, x, y, w, h) {
  const r = h / 2;
  c.beginPath();
  c.moveTo(x + r, y);
  c.lineTo(x + w - r, y);
  c.arc(x + w - r, y + r, r, -Math.PI/2, Math.PI/2);
  c.lineTo(x + r, y + h);
  c.arc(x + r, y + r, r, Math.PI/2, -Math.PI/2);
  c.closePath();
}

// ============================================================
// PERFORMANCE OPTIMIZATION UTILITIES
// ============================================================

// Debounce function for expensive operations
function debounce(func, wait) {
  let timeout;
  return function executedFunction(...args) {
    const later = () => {
      clearTimeout(timeout);
      func.apply(this, args);
    };
    clearTimeout(timeout);
    timeout = setTimeout(later, wait);
  };
}

// Throttle function for scroll/resize events
function throttle(func, limit) {
  let inThrottle;
  return function executedFunction(...args) {
    if (!inThrottle) {
      func.apply(this, args);
      inThrottle = true;
      setTimeout(() => (inThrottle = false), limit);
    }
  };
}

// Memoization for expensive calculations
function memoize(fn) {
  const cache = new Map();
  return function memoizedFunction(...args) {
    const key = JSON.stringify(args);
    if (cache.has(key)) {
      return cache.get(key);
    }
    const result = fn.apply(this, args);
    cache.set(key, result);
    return result;
  };
}

// ============================================================

// DEVICE REGISTRY
// ============================================================
const DEVICES = {
  iphone16: {
    id: 'iphone16', name: 'iPhone 16',
    baseW: 420, baseH: 864,
    screenX: 10, screenY: 10, screenW: 400, screenH: 844, screenR: 48, cornerR: 56,
    islandX: 149, islandY: 21, islandW: 122, islandH: 36, islandR: 18,
    camX: 244, camY: 39, camR: 5,
    colors: {
      black:    { edge:'#404042', mid:'#0f0f11', body:'#141416', bezel:'#07070a', label:'Black' },
      white:    { edge:'#e8e8e8', mid:'#f5f5f5', body:'#fafafa', bezel:'#e0e0e0', label:'White' },
      titanium: { edge:'#8a8580', mid:'#6b6560', body:'#7a756f', bezel:'#3a3530', label:'Titanium' },
      blue:     { edge:'#394860', mid:'#2a3548', body:'#313f55', bezel:'#0a0f18', label:'Blue' },
      pink:     { edge:'#e8c4c8', mid:'#dba8ae', body:'#e0b5ba', bezel:'#6a4548', label:'Pink' },
    },
    defaultColor: 'black',
    draw: function(c, S, pal) { drawIPhone16(c, S, this, pal); }
  },
  ipadpro: {
    id: 'ipadpro', name: 'iPad Pro',
    baseW: 620, baseH: 860,
    screenX: 16, screenY: 16, screenW: 588, screenH: 828, screenR: 20, cornerR: 28,
    colors: {
      spaceblack: { edge:'#2a2a2c', mid:'#1a1a1c', body:'#222224', bezel:'#111113', label:'Space Black' },
      silver:     { edge:'#d8d8d8', mid:'#e8e8e8', body:'#f0f0f0', bezel:'#c8c8c8', label:'Silver' },
    },
    defaultColor: 'spaceblack',
    draw: function(c, S, pal) { drawIPadPro(c, S, this, pal); }
  },
  macbookpro: {
    id: 'macbookpro', name: 'MacBook Pro',
    baseW: 800, baseH: 520,
    screenX: 48, screenY: 20, screenW: 704, screenH: 440, screenR: 8, cornerR: 16,
    colors: {
      spaceblack: { edge:'#2a2a2c', mid:'#1a1a1c', body:'#222224', bezel:'#111113', label:'Space Black' },
      silver:     { edge:'#d4d4d4', mid:'#e0e0e0', body:'#e8e8e8', bezel:'#c0c0c0', label:'Silver' },
    },
    defaultColor: 'spaceblack',
    draw: function(c, S, pal) { drawMacBookPro(c, S, this, pal); }
  },
  applewatch: {
    id: 'applewatch', name: 'Apple Watch',
    baseW: 260, baseH: 320,
    screenX: 24, screenY: 36, screenW: 212, screenH: 248, screenR: 40, cornerR: 56,
    colors: {
      midnight:  { edge:'#1a1a2e', mid:'#0f0f1a', body:'#151520', bezel:'#0a0a12', label:'Midnight' },
      starlight: { edge:'#e8e0d0', mid:'#f0e8d8', body:'#f5ede0', bezel:'#d8d0c0', label:'Starlight' },
      silver:    { edge:'#c8c8c8', mid:'#d8d8d8', body:'#e0e0e0', bezel:'#b0b0b0', label:'Silver' },
    },
    defaultColor: 'midnight',
    draw: function(c, S, pal) { drawAppleWatch(c, S, this, pal); }
  },
  none: {
    id: 'none', name: 'No Device',
    baseW: 1080, baseH: 1920,
    screenX: 0, screenY: 0, screenW: 1080, screenH: 1920, screenR: 0, cornerR: 0,
    colors: { default: { edge:'#000', mid:'#000', body:'#000', bezel:'#000', label:'None' } },
    defaultColor: 'default',
    draw: function() {}
  }
};

// ============================================================
// SOCIAL MEDIA PRESETS
// ============================================================
const PRESETS = {
  device: null, // tight crop
  reels:   { w: 1080, h: 1920 },
  twitter: { w: 1080, h: 1350 },
  youtube: { w: 1920, h: 1080 },
  square:  { w: 1080, h: 1080 },
  custom:  { w: 1080, h: 1920 },
};

// ============================================================

// STATE
// ============================================================
const state = {
  device: { type: 'iphone16', color: 'black', landscape: false, scale: 0.45, x: 0, y: 0 },
  videoFit: 'cover',
  perspective: { x: 0, y: 0 },
  background: { color: '#0a0a0a' },
  shadow: 0.6,
  preset: 'reels',
  layers: [],
  timeline: { trimIn: 0, trimOut: 1, speed: 1, clips: [], currentClip: 0, keyframes: [] },
  deviceKeyframes: [],
  loops: {
    main: { enabled: false, start: 0, end: 1 },
    bgVideo: { enabled: false, start: 0, end: 1 },
    bgAudio: { enabled: false, start: 0, end: 1 }
  },
  standstill: {
    mode: 'none',
    freezeTime: 0,
    contentLoop: { enabled: false, start: 0, end: 1 }
  },
  entrance: { type: 'none', duration: 1000 },
  facecam: { enabled: false, size: 0.15, x: -1, y: -1, corner: 'bottomRight', shape: 'circle', borderColor: '#ffffff', borderWidth: 3, shadow: true, source: 'camera', stream: null },
  hand: { enabled: false, style: 'right' },
  comparison: { enabled: false, device2: null, video2: null, x: 0, y: 0 },
  annotation: { tool: null, color: '#ff4444', width: 3 },
  gradient: { enabled: false, type: 'linear', color1: '#0f0c29', color2: '#302b63', color3: '#24243e', angle: 135, animated: false, speed: 1 },
  particles: { enabled: false, type: 'bokeh', count: 30, color: '#ffffff', speed: 0.5 },
  orbit: { enabled: false, speed: 0.3, axis: 'y', range: 15 },
  motionBlur: { enabled: false, amount: 0.15 },
  waveform: { enabled: false, color: '#60a5fa', height: 0.06, position: 'bottom', style: 'bars' },
  progressBar: { enabled: false, color: '#60a5fa', height: 4, position: 'top' },
  glassmorphism: { enabled: false, text: 'Your CTA Here', x: -1, y: -1, width: 280, height: 60, blur: 12, opacity: 15, borderOpacity: 0.2 },
  chromaKey: { enabled: false, color: '#00ff00', tolerance: 80, softness: 10 },
  videoOverlays: [],
  lut: { enabled: false, data: null, size: 0, intensity: 1.0, name: '', _presetKey: '' },
  bgVideo: { enabled: false, opacity: 1.0, fit: 'cover' },
  bgAudio: { enabled: false, volume: 1.0, loop: false, speed: 1.0 },
  bgType: 'solid',
  audioEffects: {
    main: {
      volume: 1.0,
      pan: 0,
      mute: false,
      solo: false,
      eq: { low: 0, mid: 0, high: 0 },
      compressor: {
        enabled: false,
        threshold: -24,
        ratio: 3,
        attack: 0.003,
        release: 0.25
      },
      reverb: { enabled: false, mix: 0.3, decay: 2 },
      echo: { enabled: false, delay: 0.5, feedback: 0.3, mix: 0.5 }
    },
    bgAudio: {
      volume: 1.0,
      pan: 0,
      mute: false,
      solo: false,
      eq: { low: 0, mid: 0, high: 0 },
      compressor: {
        enabled: false,
        threshold: -24,
        ratio: 3,
        attack: 0.003,
        release: 0.25
      },
      reverb: { enabled: false, mix: 0.3, decay: 2 },
      echo: { enabled: false, delay: 0.5, feedback: 0.3, mix: 0.5 }
    }
  },
  videoEffects: {
    main: {
      brightness: 0,
      contrast: 0,
      saturation: 0,
      hue: 0,
      temperature: 0,
      tint: 0,
      levels: {
        inputMin: 0,
        inputMax: 255,
        gamma: 1.0,
        outputMin: 0,
        outputMax: 255
      },
      filters: [],
      blendMode: 'normal',
      crop: { enabled: false, x: 0, y: 0, w: 1, h: 1 }
    },
    bgVideo: {
      brightness: 0,
      contrast: 0,
      saturation: 0,
      hue: 0,
      temperature: 0,
      tint: 0,
      levels: {
        inputMin: 0,
        inputMax: 255,
        gamma: 1.0,
        outputMin: 0,
        outputMax: 255
      },
      filters: [],
      blendMode: 'normal',
      crop: { enabled: false, x: 0, y: 0, w: 1, h: 1 }
    }
  },
  animPreset: { type: 'none', intensity: 1.0, bpm: 120, autoBPM: false },
  scene: 'custom',
  selectedLayer: -1,
  nextLayerId: 1,
  renderStack: [
    { id: 'bgVideo', name: 'BG Video', icon: '' },
    { id: 'particles', name: 'Particles', icon: '' },
    { id: 'device', name: 'Device', icon: '' },
    { id: 'device2', name: 'Device 2', icon: '' },
    { id: 'content', name: 'Content', icon: 'T' },
    { id: 'facecam', name: 'Facecam', icon: '' },
    { id: 'videoOverlays', name: 'Overlays', icon: '' },
    { id: 'uiOverlays', name: 'UI Effects', icon: '' },
  ],
  _particles: [], // runtime particle positions
};

// ============================================================
// UNDO / REDO
// ============================================================
const UNDO_MAX = 30;
const undoStack = [];
const redoStack = [];

function getUndoSnapshot() {
  return {
    device: { type: state.device.type, color: state.device.color, landscape: state.device.landscape, scale: state.device.scale, x: state.device.x, y: state.device.y },
    videoFit: state.videoFit,
    perspective: { x: state.perspective.x, y: state.perspective.y },
    background: { color: state.background.color },
    shadow: state.shadow,
    preset: state.preset,
    bgType: state.bgType,
    gradient: { ...state.gradient },
    particles: { enabled: state.particles.enabled, type: state.particles.type, count: state.particles.count, color: state.particles.color, speed: state.particles.speed },
    orbit: { enabled: state.orbit.enabled, speed: state.orbit.speed, axis: state.orbit.axis, range: state.orbit.range },
    motionBlur: { enabled: state.motionBlur.enabled, amount: state.motionBlur.amount },
    entrance: { type: state.entrance.type, duration: state.entrance.duration },
    animPreset: { type: state.animPreset.type, intensity: state.animPreset.intensity, bpm: state.animPreset.bpm, autoBPM: state.animPreset.autoBPM },
    scene: state.scene,
    chromaKey: { enabled: state.chromaKey.enabled, color: state.chromaKey.color, tolerance: state.chromaKey.tolerance, softness: state.chromaKey.softness },
    lut: { enabled: state.lut.enabled, intensity: state.lut.intensity, name: state.lut.name, _presetKey: state.lut._presetKey || '' },
    waveform: { enabled: state.waveform.enabled, color: state.waveform.color, height: state.waveform.height, position: state.waveform.position, style: state.waveform.style },
    progressBar: { enabled: state.progressBar.enabled, color: state.progressBar.color, height: state.progressBar.height, position: state.progressBar.position },
    glassmorphism: { enabled: state.glassmorphism.enabled, text: state.glassmorphism.text, blur: state.glassmorphism.blur, opacity: state.glassmorphism.opacity },
        hand: { enabled: state.hand.enabled, style: state.hand.style },
        facecam: {
          enabled: state.facecam.enabled,
          size: state.facecam.size,
          corner: state.facecam.corner,
          shape: state.facecam.shape,
          borderColor: state.facecam.borderColor,
          borderWidth: state.facecam.borderWidth,
          shadow: state.facecam.shadow,
          x: state.facecam.x,
          y: state.facecam.y,
        },
        layers: state.layers.map(l => {            const copy = { ...l };
            if (l.type === 'image' && l.img) {
              copy.imgSrc = l.img.src;
            }
            delete copy.img; // non-serializable
            if (l.type === 'annotation') copy.points = [...l.points];
            return copy;
          }),    annotation: { tool: state.annotation.tool, color: state.annotation.color, width: state.annotation.width },
    videoOverlays: state.videoOverlays.filter(ov => ov.builtin).map(ov => ov.builtin),
    selectedLayer: state.selectedLayer,
    audioEffects: JSON.parse(JSON.stringify(state.audioEffects)),
    videoEffects: JSON.parse(JSON.stringify(state.videoEffects)),
  };
}

function applyUndoSnapshot(snap) {
  // Device
  state.device.type = snap.device.type;
  state.device.color = snap.device.color;
  state.device.landscape = snap.device.landscape;
  state.device.scale = snap.device.scale;
  frameCache = {};

  state.videoFit = snap.videoFit;
  state.perspective.x = snap.perspective.x;
  state.perspective.y = snap.perspective.y;
  state.background.color = snap.background.color;
  state.shadow = snap.shadow;
  state.preset = snap.preset;
  state.bgType = snap.bgType;
  Object.assign(state.gradient, snap.gradient);
  Object.assign(state.particles, snap.particles);
  Object.assign(state.orbit, snap.orbit);
  state.motionBlur.enabled = snap.motionBlur.enabled;
  state.motionBlur.amount = snap.motionBlur.amount;
  state.entrance.type = snap.entrance.type;
  state.entrance.duration = snap.entrance.duration;
  Object.assign(state.animPreset, snap.animPreset);
  state.scene = snap.scene;
  Object.assign(state.chromaKey, snap.chromaKey);
  state.lut.enabled = snap.lut.enabled;
  state.lut.intensity = snap.lut.intensity;
  state.lut.name = snap.lut.name;
  state.lut._presetKey = snap.lut._presetKey;
  if (snap.lut.enabled && snap.lut._presetKey) {
    const lut = generateLUTPreset(snap.lut._presetKey);
    state.lut.data = lut; state.lut.size = lut.size;
  } else if (!snap.lut.enabled) {
    state.lut.data = null; state.lut.size = 0;
  }
  Object.assign(state.waveform, snap.waveform);
  Object.assign(state.progressBar, snap.progressBar);
  Object.assign(state.glassmorphism, snap.glassmorphism);
  state.hand.enabled = snap.hand.enabled;
  state.hand.style = snap.hand.style;
  state.annotation.color = snap.annotation.color;
  state.annotation.width = snap.annotation.width;

  // Restore layers (rebuild non-serializable refs)
  state.layers = snap.layers.map(l => {
    const copy = { ...l };
    if (l.type === 'annotation') copy.points = [...l.points];
    if (l.type === 'image' && l.imgSrc) {
      const img = new Image();
      img.src = l.imgSrc;
      copy.img = img;
    }
    return copy;
  });
  state.selectedLayer = snap.selectedLayer;

  // Restore builtin overlays
  state.videoOverlays = state.videoOverlays.filter(ov => !ov.builtin);
  for (const type of snap.videoOverlays) {
    state.videoOverlays.push({ id: Date.now() + Math.random(), builtin: type, name: type, opacity: 0.5, blendMode: 'screen' });
  }

  // Restore audio and video effects
  if (snap.audioEffects) {
    state.audioEffects = JSON.parse(JSON.stringify(snap.audioEffects));
    // Update audio chains
    if (typeof updateAudioEffects === 'function') {
      updateAudioEffects('main');
      updateAudioEffects('bgAudio');
    }
  }
  if (snap.videoEffects) {
    state.videoEffects = JSON.parse(JSON.stringify(snap.videoEffects));
  }
}

function pushUndoState() {
  undoStack.push(getUndoSnapshot());
  if (undoStack.length > UNDO_MAX) undoStack.shift();
  redoStack.length = 0;
  updateUndoButtons();
}

function undo() {
  if (undoStack.length === 0) return;
  redoStack.push(getUndoSnapshot());
  const snap = undoStack.pop();
  applyUndoSnapshot(snap);
  updateUndoUI();
  updateUndoButtons();
  scheduleSave();
}

function redo() {
  if (redoStack.length === 0) return;
  undoStack.push(getUndoSnapshot());
  const snap = redoStack.pop();
  applyUndoSnapshot(snap);
  updateUndoUI();
  updateUndoButtons();
  scheduleSave();
}

function updateUndoButtons() {
  document.getElementById('undoBtn').disabled = undoStack.length === 0;
  document.getElementById('redoBtn').disabled = redoStack.length === 0;
}

function updateUndoUI() {
  // Device grid
  document.querySelectorAll('#deviceGrid .dev-btn').forEach(b => b.classList.toggle('active', b.dataset.device === state.device.type));
  if (typeof updateColorSwatches === 'function') updateColorSwatches();
  document.getElementById('landscapeBtn').classList.toggle('active', state.device.landscape);
  const toggles = document.getElementById('deviceToggles');
  if (toggles) toggles.style.display = state.device.type === 'none' ? 'none' : 'flex';

  // Transform controls
  document.getElementById('scaleSlider').value = Math.round(state.device.scale * 100);
  document.getElementById('videoFitMode').value = state.videoFit;
  document.getElementById('tiltX').value = state.perspective.x;
  document.getElementById('tiltY').value = state.perspective.y;
  document.getElementById('shadowSlider').value = Math.round(state.shadow * 100);

  // Background
  document.getElementById('bgColor').value = state.background.color;
  document.getElementById('bgType').value = state.bgType;
  document.getElementById('bgSolidControls').style.display = state.bgType === 'solid' ? 'block' : 'none';
  document.getElementById('bgGradientControls').style.display = state.bgType === 'gradient' ? 'block' : 'none';
  document.getElementById('gradColor1').value = state.gradient.color1;
  document.getElementById('gradColor2').value = state.gradient.color2;
  document.getElementById('gradColor3').value = state.gradient.color3;
  document.getElementById('gradAngle').value = state.gradient.angle;
  document.getElementById('gradAnimated').value = String(state.gradient.animated);

  // Preset
  document.getElementById('presetSelect').value = state.preset;
  resizeCanvas();

  // Particles
  document.getElementById('particleType').value = state.particles.enabled ? state.particles.type : 'off';
  document.getElementById('particleCount').value = state.particles.count;
  document.getElementById('particleColor').value = state.particles.color;

  // Orbit + motion blur
  document.getElementById('orbitToggle').value = String(state.orbit.enabled);
  document.getElementById('orbitSpeed').value = Math.round(state.orbit.speed * 100);
  document.getElementById('motionBlurToggle').value = String(state.motionBlur.enabled);

  // Entrance
  document.getElementById('entranceSelect').value = state.entrance.type;
  document.getElementById('entranceDur').value = state.entrance.duration;
  document.getElementById('entranceDurVal').textContent = (state.entrance.duration / 1000).toFixed(1) + 's';

  // Animation preset
  document.querySelectorAll('#animPresetGrid .dev-btn').forEach(b => b.classList.toggle('active', b.dataset.anim === state.animPreset.type));
  document.getElementById('animIntensity').value = Math.round(state.animPreset.intensity * 100);
  document.getElementById('animBPM').value = state.animPreset.bpm;
  document.getElementById('animBPMVal').textContent = state.animPreset.bpm;
  document.getElementById('animBPM').disabled = state.animPreset.autoBPM;
  document.getElementById('autoBPMBtn').classList.toggle('active', state.animPreset.autoBPM);
  document.getElementById('autoBPMBtn').textContent = state.animPreset.autoBPM ? 'On' : 'Off';
  document.getElementById('autoBPMStatus').textContent = state.animPreset.autoBPM ? 'Listening...' : '';

  // Scene
  document.querySelectorAll('#sceneGrid .dev-btn').forEach(b => b.classList.toggle('active', b.dataset.scene === state.scene));

  // Chroma key
  document.getElementById('chromaToggle').value = String(state.chromaKey.enabled);
  document.getElementById('chromaControls').style.display = state.chromaKey.enabled ? 'block' : 'none';

  // LUT
  document.querySelectorAll('#lutPresetGrid .dev-btn').forEach(b => b.classList.remove('active'));
  if (state.lut._presetKey) {
    const lb = document.querySelector('#lutPresetGrid .dev-btn[data-lut-preset="' + state.lut._presetKey + '"]');
    if (lb) lb.classList.add('active');
  }
  document.getElementById('lutControls').style.display = state.lut.enabled ? 'block' : 'none';

  // Overlays UI
  document.getElementById('progressToggle').value = String(state.progressBar.enabled);
  document.getElementById('waveformToggle').value = String(state.waveform.enabled);
  document.getElementById('glassToggle').value = String(state.glassmorphism.enabled);
  document.getElementById('glassControls').style.display = state.glassmorphism.enabled ? 'block' : 'none';

  // Hand
  const handBtn = document.getElementById('handBtn');
  handBtn.classList.toggle('active', state.hand.enabled);
  handBtn.textContent = state.hand.enabled ? 'Disable Hand' : 'Enable Hand';
  document.getElementById('resetHandBtn').style.display = state.hand.enabled ? 'inline-block' : 'none';
  document.getElementById('handStyle').value = state.hand.style;

  // Builtin overlays
  document.querySelectorAll('#builtinOverlayGrid .dev-btn').forEach(b => b.classList.remove('active'));
  state.videoOverlays.filter(ov => ov.builtin).forEach(ov => {
    const ob = document.querySelector('#builtinOverlayGrid .dev-btn[data-builtin="' + ov.builtin + '"]');
    if (ob) ob.classList.add('active');
  });

  // Full preset grid
  document.querySelectorAll('#fullPresetGrid .preset-card').forEach(b => b.classList.remove('active'));

  // Layers
  if (typeof rebuildLayerList === 'function') rebuildLayerList();
  if (typeof rebuildUnifiedLayers === 'function') rebuildUnifiedLayers();
  if (typeof rebuildOverlayList === 'function') rebuildOverlayList();

  updatePerspective();
  updateDisplaySize();
}

// ============================================================
// SESSION PERSISTENCE (localStorage)
// ============================================================
const STORAGE_KEY = 'mockupStudioState';

function getSerializableState() {
  return {
    device: { type: state.device.type, color: state.device.color, landscape: state.device.landscape, scale: state.device.scale },
    videoFit: state.videoFit,
    perspective: { x: state.perspective.x, y: state.perspective.y },
    background: { color: state.background.color },
    shadow: state.shadow,
    preset: state.preset,
    bgType: state.bgType,
    gradient: { ...state.gradient },
    particles: { enabled: state.particles.enabled, type: state.particles.type, count: state.particles.count, color: state.particles.color, speed: state.particles.speed },
    orbit: { enabled: state.orbit.enabled, speed: state.orbit.speed, axis: state.orbit.axis, range: state.orbit.range },
    motionBlur: { enabled: state.motionBlur.enabled, amount: state.motionBlur.amount },
    entrance: { type: state.entrance.type, duration: state.entrance.duration },
    animPreset: { type: state.animPreset.type, intensity: state.animPreset.intensity, bpm: state.animPreset.bpm, autoBPM: state.animPreset.autoBPM },
    scene: state.scene,
    chromaKey: { enabled: state.chromaKey.enabled, color: state.chromaKey.color, tolerance: state.chromaKey.tolerance, softness: state.chromaKey.softness },
    lut: { enabled: state.lut.enabled, intensity: state.lut.intensity, name: state.lut.name, presetKey: state.lut._presetKey || '' },
    waveform: { enabled: state.waveform.enabled, color: state.waveform.color, height: state.waveform.height, position: state.waveform.position, style: state.waveform.style },
    progressBar: { enabled: state.progressBar.enabled, color: state.progressBar.color, height: state.progressBar.height, position: state.progressBar.position },
    glassmorphism: { enabled: state.glassmorphism.enabled, text: state.glassmorphism.text, blur: state.glassmorphism.blur, opacity: state.glassmorphism.opacity },
    hand: { enabled: state.hand.enabled, style: state.hand.style },
    facecam: {
      enabled: state.facecam.enabled,
      size: state.facecam.size,
      corner: state.facecam.corner,
      shape: state.facecam.shape,
      borderColor: state.facecam.borderColor,
      borderWidth: state.facecam.borderWidth,
      shadow: state.facecam.shadow,
      x: state.facecam.x,
      y: state.facecam.y,
    },
    layers: state.layers.map(l => {
      const copy = { ...l };
      if (l.type === 'image' && l.img) {
        copy.imgSrc = l.img.src;
      }
      delete copy.img; // non-serializable
      if (l.type === 'annotation') copy.points = [...l.points];
      return copy;
    }),
    builtinOverlays: state.videoOverlays.filter(ov => ov.builtin).map(ov => ov.builtin),
    bgVideo: {
      enabled: state.bgVideo.enabled,
      opacity: state.bgVideo.opacity,
      fit: state.bgVideo.fit,
    },
    comparison: {
      enabled: state.comparison.enabled,
      device2: state.comparison.device2 ? {
        type: state.comparison.device2.type,
        color: state.comparison.device2.color,
      } : null,
      video2: state.comparison.video2 ? {
        src: state.comparison.video2.src,
      } : null,
    },
    isLooping: isLooping,
    speed: state.timeline.speed,
    audioEffects: state.audioEffects,
    videoEffects: state.videoEffects,
  };
}

function saveState() {
  try {
    localStorage.setItem(STORAGE_KEY, JSON.stringify(getSerializableState()));
  } catch (e) { /* quota exceeded or private mode  ignore */ }
}

let _saveTimer = null;
function scheduleSave() {
  clearTimeout(_saveTimer);
  _saveTimer = setTimeout(saveState, 500);
}

function applyStateToUI(s) {
  // Device
  state.device.type = s.device.type;
  state.device.color = s.device.color;
  state.device.landscape = s.device.landscape || false;
  state.device.scale = s.device.scale;
  deviceGrid.querySelectorAll('.dev-btn').forEach(b => {
    b.classList.toggle('active', b.dataset.device === s.device.type);
  });
  if (s.device.landscape) document.getElementById('landscapeBtn').classList.add('active');
  updateColorSwatches();
  frameCache = {};

  // Video fit
  state.videoFit = s.videoFit || 'cover';
  document.getElementById('videoFitMode').value = state.videoFit;

  // Perspective
  state.perspective.x = s.perspective.x;
  state.perspective.y = s.perspective.y;
  document.getElementById('tiltX').value = s.perspective.x;
  document.getElementById('tiltY').value = s.perspective.y;

  // Background
  state.background.color = s.background.color;
  state.bgType = s.bgType;
  document.getElementById('bgColor').value = s.background.color;
  document.getElementById('bgType').value = s.bgType;
  document.getElementById('bgSolidControls').style.display = s.bgType === 'solid' ? 'block' : 'none';
  document.getElementById('bgGradientControls').style.display = s.bgType === 'gradient' ? 'block' : 'none';

  // Gradient
  Object.assign(state.gradient, s.gradient);
  document.getElementById('gradColor1').value = s.gradient.color1;
  document.getElementById('gradColor2').value = s.gradient.color2;
  document.getElementById('gradColor3').value = s.gradient.color3;
  document.getElementById('gradAngle').value = s.gradient.angle;
  document.getElementById('gradAnimated').value = String(s.gradient.animated);

  // Shadow & Scale
  state.shadow = s.shadow;
  state.device.scale = s.device.scale;
  document.getElementById('shadowSlider').value = Math.round(s.shadow * 100);
  document.getElementById('scaleSlider').value = Math.round(s.device.scale * 100);

  // Preset (canvas size)
  state.preset = s.preset;
  document.getElementById('presetSelect').value = s.preset;

  // Particles
  Object.assign(state.particles, s.particles);
  document.getElementById('particleType').value = s.particles.enabled ? s.particles.type : 'off';
  document.getElementById('particleCount').value = s.particles.count;
  document.getElementById('particleColor').value = s.particles.color;

  // Orbit
  Object.assign(state.orbit, s.orbit);
  document.getElementById('orbitToggle').value = String(s.orbit.enabled);
  document.getElementById('orbitSpeed').value = Math.round(s.orbit.speed * 100);

  // Motion blur
  state.motionBlur.enabled = s.motionBlur.enabled;
  state.motionBlur.amount = s.motionBlur.amount;
  document.getElementById('motionBlurToggle').value = String(s.motionBlur.enabled);

  // Entrance
  state.entrance.type = s.entrance.type;
  state.entrance.duration = s.entrance.duration;
  document.getElementById('entranceSelect').value = s.entrance.type;
  document.getElementById('entranceDur').value = s.entrance.duration;
  document.getElementById('entranceDurVal').textContent = (s.entrance.duration / 1000).toFixed(1) + 's';

  // Animation preset
  Object.assign(state.animPreset, s.animPreset);
  document.querySelectorAll('#animPresetGrid .dev-btn').forEach(b => {
    b.classList.toggle('active', b.dataset.anim === s.animPreset.type);
  });
  document.getElementById('animIntensity').value = Math.round(s.animPreset.intensity * 100);
  document.getElementById('animBPM').value = s.animPreset.bpm;
  document.getElementById('animBPMVal').textContent = s.animPreset.bpm;
  if (s.animPreset.autoBPM) {
    document.getElementById('animBPM').disabled = true;
    document.getElementById('autoBPMBtn').classList.add('active');
    document.getElementById('autoBPMBtn').textContent = 'On';
    document.getElementById('autoBPMStatus').textContent = 'Listening...';
  } else {
    document.getElementById('animBPM').disabled = false;
    document.getElementById('autoBPMBtn').classList.remove('active');
    document.getElementById('autoBPMBtn').textContent = 'Off';
    document.getElementById('autoBPMStatus').textContent = '';
  }

  // Scene
  state.scene = s.scene;
  document.querySelectorAll('#sceneGrid .dev-btn').forEach(b => {
    b.classList.toggle('active', b.dataset.scene === s.scene);
  });

  // Chroma key
  Object.assign(state.chromaKey, s.chromaKey);
  document.getElementById('chromaToggle').value = String(s.chromaKey.enabled);
  document.getElementById('chromaColor').value = s.chromaKey.color;
  document.getElementById('chromaTolerance').value = s.chromaKey.tolerance;
  document.getElementById('chromaSoftness').value = s.chromaKey.softness;
  document.getElementById('chromaControls').style.display = s.chromaKey.enabled ? 'block' : 'none';

  // LUT  restore preset if it was a built-in
  state.lut.intensity = s.lut.intensity;
  document.getElementById('lutIntensity').value = Math.round(s.lut.intensity * 100);
  document.getElementById('lutIntensityVal').textContent = Math.round(s.lut.intensity * 100) + '%';
  if (s.lut.presetKey && s.lut.presetKey !== 'none' && s.lut.presetKey !== '') {
    const lutBtn = document.querySelector('#lutPresetGrid .dev-btn[data-lut-preset="' + s.lut.presetKey + '"]');
    if (lutBtn) {
      lutBtn.click(); // triggers the existing handler which sets state.lut properly
    }
  }

  // Overlays (progress bar, waveform, glass CTA)
  if (s.progressBar) {
    Object.assign(state.progressBar, s.progressBar);
    document.getElementById('progressToggle').value = String(s.progressBar.enabled);
    document.getElementById('progressColor').value = s.progressBar.color;
  }
  if (s.waveform) {
    Object.assign(state.waveform, s.waveform);
    document.getElementById('waveformToggle').value = String(s.waveform.enabled);
    document.getElementById('waveformColor').value = s.waveform.color;
  }
  if (s.glassmorphism) {
    Object.assign(state.glassmorphism, s.glassmorphism);
    document.getElementById('glassToggle').value = String(s.glassmorphism.enabled);
    document.getElementById('glassControls').style.display = s.glassmorphism.enabled ? 'block' : 'none';
    document.getElementById('glassText').value = s.glassmorphism.text;
    document.getElementById('glassBlur').value = s.glassmorphism.blur;
    document.getElementById('glassOpacity').value = s.glassmorphism.opacity;
  }

  // Hand
  if (s.hand) {
    state.hand.enabled = s.hand.enabled;
    state.hand.style = s.hand.style;

  // Facecam
  state.facecam.enabled = s.facecam.enabled;
  state.facecam.size = s.facecam.size;
  state.facecam.corner = s.facecam.corner;
  state.facecam.shape = s.facecam.shape;
  state.facecam.borderColor = s.facecam.borderColor;
  state.facecam.borderWidth = s.facecam.borderWidth;
  state.facecam.shadow = s.facecam.shadow;
  state.facecam.x = s.facecam.x;
  state.facecam.y = s.facecam.y;

  // Update UI elements for facecam
  document.getElementById('facecamSize').value = Math.round(s.facecam.size * 100);
  document.getElementById('facecamCorner').value = s.facecam.corner;
  document.getElementById('facecamShape').value = s.facecam.shape;
  document.getElementById('facecamBorderColor').value = s.facecam.borderColor;
  document.getElementById('facecamBorderWidth').value = s.facecam.borderWidth;
  document.getElementById('facecamShadow').value = String(s.facecam.shadow);

  // Layers
  state.layers = s.layers.map(l => {
    const copy = { ...l };
    if (l.type === 'annotation') copy.points = [...l.points];
    if (l.type === 'image' && l.imgSrc) {
      const img = new Image();
      img.src = l.imgSrc;
      copy.img = img;
    }
    return copy;
  });

    document.getElementById('handStyle').value = s.hand.style;
  }

  // Builtin overlays
  if (s.builtinOverlays && s.builtinOverlays.length) {
    state.videoOverlays = [];
    document.querySelectorAll('#builtinOverlayGrid .dev-btn').forEach(b => b.classList.remove('active'));
    for (const type of s.builtinOverlays) {
      const btn = document.querySelector('#builtinOverlayGrid .dev-btn[data-builtin="' + type + '"]');
      if (btn) {
        state.videoOverlays.push({ id: Date.now() + Math.random(), builtin: type, name: btn.textContent, opacity: 0.5, blendMode: 'screen' });
        btn.classList.add('active');
      }
    }
  }

  // Loop & speed
  if (typeof s.isLooping !== 'undefined') {
    isLooping = s.isLooping;
  
    loopBtn.classList.toggle('active', isLooping);
    loopBtn.textContent = isLooping ? 'Loop' : 'No Loop';
  }
  if (s.speed) {
    state.timeline.speed = s.speed;
    video.playbackRate = s.speed;
    document.getElementById('speedSelect').value = s.speed;
  }

  // Background Video
  if (s.bgVideo) {
    state.bgVideo.enabled = s.bgVideo.enabled;
    state.bgVideo.opacity = s.bgVideo.opacity;
    state.bgVideo.fit = s.bgVideo.fit;
    // Potentially update UI elements for bgVideo here
  }

  // Comparison
  if (s.comparison) {
    state.comparison.enabled = s.comparison.enabled;
    if (s.comparison.device2) {
      state.comparison.device2 = { ...s.comparison.device2 };
    } else {
      state.comparison.device2 = null;
    }
    if (s.comparison.video2) {
      // Re-create video element if necessary, or just store src
      // For simplicity, just storing src for now, actual video loading would be external
      state.comparison.video2 = { ...s.comparison.video2 };
    } else {
      state.comparison.video2 = null;
    }
    // Potentially update UI elements for comparison here
  }

  // Audio and Video Effects
  if (s.audioEffects) {
    state.audioEffects = s.audioEffects;
    // Update audio chains if initialized
    if (typeof updateAudioEffects === 'function') {
      updateAudioEffects('main');
      updateAudioEffects('bgAudio');
    }
  }
  if (s.videoEffects) {
    state.videoEffects = s.videoEffects;
  }

  resizeCanvas();
}

function loadState() {
  try {
    const raw = localStorage.getItem(STORAGE_KEY);
    if (!raw) return;
    const s = JSON.parse(raw);
    if (!s || !s.device) return;
    applyStateToUI(s);
  } catch (e) { /* corrupt data  ignore */ }
}

// Auto-save: listen for input/change on all panels
document.querySelectorAll('.panel, .top-bar, .playback-bar').forEach(panel => {
  panel.addEventListener('input', scheduleSave);
  panel.addEventListener('change', scheduleSave);
  panel.addEventListener('click', scheduleSave);
});

// ============================================================

// VIRTUAL TIMELINE ENGINE
// ============================================================
const TRANSITION_DURATION = 0.5; // seconds
let vtTime = 0;         // current position in virtual timeline (seconds)
let vtPlaying = false;
let vtLastTick = 0;
let vtActiveClipIdx = 0;

function vtGetTotalDuration() {
  const clips = state.timeline.clips;
  if (clips.length === 0) return video.duration || 0;
  return clips.reduce((s, c) => s + c.duration * ((c.trimOut || 1) - (c.trimIn || 0)), 0);
}

function vtGetClipAt(t) {
  const clips = state.timeline.clips;
  if (clips.length === 0) return null;
  let offset = 0;
  for (let i = 0; i < clips.length; i++) {
    const c = clips[i];
    const clipDur = c.duration * ((c.trimOut || 1) - (c.trimIn || 0));
    if (t < offset + clipDur + 0.001) {
      const localTime = c.duration * (c.trimIn || 0) + (t - offset);
      return { index: i, clip: c, localTime, offset, clipDur };
    }
    offset += clipDur;
  }
  const last = clips[clips.length - 1];
  const lastDur = last.duration * ((last.trimOut || 1) - (last.trimIn || 0));
  return { index: clips.length - 1, clip: last, localTime: last.duration * (last.trimOut || 1), offset: offset - lastDur, clipDur: lastDur };
}

function vtGetTransition() {
  const clips = state.timeline.clips;
  const transType = document.getElementById('transitionSelect').value;
  if (transType === 'cut' || clips.length <= 1) return null;
  let offset = 0;
  for (let i = 0; i < clips.length - 1; i++) {
    const c = clips[i];
    const clipDur = c.duration * ((c.trimOut || 1) - (c.trimIn || 0));
    const transStart = offset + clipDur - TRANSITION_DURATION;
    if (vtTime >= transStart && vtTime < offset + clipDur) {
      const progress = (vtTime - transStart) / TRANSITION_DURATION;
      const next = clips[i + 1];
      return {
        type: transType,
        progress: Math.max(0, Math.min(1, progress)),
        outClip: c,
        inClip: next,
        outLocalTime: c.duration * (c.trimIn || 0) + (vtTime - offset),
        inLocalTime: next.duration * (next.trimIn || 0) + (vtTime - offset - clipDur) // will be near 0
      };
    }
    offset += clipDur;
  }
  return null;
}

function vtGetActiveVideo() {
  const clips = state.timeline.clips;
  if (clips.length === 0) return video;
  const info = vtGetClipAt(vtTime);
  return info ? info.clip.video : video;
}

function vtSeek(t) {
  const totalDur = vtGetTotalDuration();
  vtTime = Math.max(0, Math.min(t, totalDur));
  const clips = state.timeline.clips;
  if (clips.length === 0) {
    video.currentTime = vtTime;
    syncOverlays();
    // Sync background video
    if (state.bgVideo.enabled) {
      const bgVid = document.getElementById('bgVideo');
      if (bgVid && bgVid.readyState >= 2) {
        bgVid.currentTime = Math.min(vtTime, bgVid.duration - 0.01);
      }
    }
    return;
  }
  // Pause all clips
  clips.forEach(c => { if (c.video !== video) c.video.pause(); });
  const info = vtGetClipAt(vtTime);
  if (info) {
    vtActiveClipIdx = info.index;
    info.clip.video.currentTime = info.localTime;
    syncOverlays();
    // Sync background video
    if (state.bgVideo.enabled) {
      const bgVid = document.getElementById('bgVideo');
      if (bgVid && bgVid.readyState >= 2) {
        bgVid.currentTime = Math.min(vtTime, bgVid.duration - 0.01);
      }
    }
    if (vtPlaying) info.clip.video.play();
  }
}

function vtPlay() {
  if (vtPlaying) return;
  vtPlaying = true;
  vtLastTick = performance.now();
  const clips = state.timeline.clips;
  if (clips.length === 0) {
    video.play().catch(err => { console.warn('Main video play prevented:', err); });
  } else {
    const info = vtGetClipAt(vtTime);
    if (info) {
      vtActiveClipIdx = info.index;
      info.clip.video.currentTime = info.localTime;
      info.clip.video.playbackRate = state.timeline.speed;
      info.clip.video.play().catch(err => { console.warn('Clip video play prevented:', err); });
    }
  }
  iconPlay.style.display = 'none'; iconPause.style.display = 'block';
  state.videoOverlays.forEach(ov => { if (ov.video) ov.video.play().catch(err => { console.warn('Overlay video play prevented:', err); }); });
  if (state.bgVideo.enabled) document.getElementById('bgVideo').play().catch(err => { console.warn('Background video play prevented:', err); });
  syncOverlays();
}

function vtPause() {
  vtPlaying = false;
  const clips = state.timeline.clips;
  if (clips.length === 0) {
    video.pause();
  } else {
    clips.forEach(c => c.video.pause());
  }
  iconPlay.style.display = 'block'; iconPause.style.display = 'none';
  state.videoOverlays.forEach(ov => { if (ov.video) ov.video.pause(); });
  if (state.bgVideo.enabled) document.getElementById('bgVideo').pause();
  syncOverlays();
}

function vtToggle() {
  if (vtPlaying) vtPause(); else vtPlay();
}

function vtTick() {
  if (!vtPlaying) return;
  const now = performance.now();
  const delta = (now - vtLastTick) / 1000;
  vtLastTick = now;
  vtTime += delta * state.timeline.speed;

  const totalDur = vtGetTotalDuration();
  if (vtTime >= totalDur) {
    if (isLooping) {
      vtTime = 0;
      vtSeek(0);
      vtPlay();
    } else {
      vtTime = totalDur;
      vtPause();
    }
    return;
  }

  const clips = state.timeline.clips;
  if (clips.length > 0) {
    const info = vtGetClipAt(vtTime);
    if (info && info.index !== vtActiveClipIdx) {
      // Switch clips
      clips[vtActiveClipIdx].video.pause();
      vtActiveClipIdx = info.index;
      info.clip.video.currentTime = info.localTime;
      info.clip.video.playbackRate = state.timeline.speed;
      info.clip.video.play().catch(err => { console.warn('Clip video play prevented:', err); });
    }
    // Handle transition  keep both clips playing during overlap
    const trans = vtGetTransition();
    if (trans && trans.inClip.video.paused) {
      trans.inClip.video.currentTime = trans.inClip.duration * (trans.inClip.trimIn || 0);
      trans.inClip.video.playbackRate = state.timeline.speed;
      trans.inClip.video.play().catch(err => { console.warn('Transition inClip video play prevented:', err); });
    }
  }

  // Update progress UI
  progressFill.style.width = (vtTime / totalDur * 100) + '%';
  timeLabel.textContent = fmt(vtTime) + ' / ' + fmt(totalDur);
  updateTimelineScrubber();
}

// TIMELINE
// ============================================================
function rebuildTimeline() {
  const track = timelineTrack;
  track.querySelectorAll('.clip-block, .trim-handle, .keyframe-diamond, .clip-trans-indicator, .anno-marker').forEach(el => el.remove());

  const totalDuration = vtGetTotalDuration() || 1;
  const transType = document.getElementById('transitionSelect').value;

  let offset = 0;
  state.timeline.clips.forEach((clip, i) => {
    const clipDur = clip.duration * ((clip.trimOut || 1) - (clip.trimIn || 0));
    const block = document.createElement('div');
    block.className = 'clip-block';
    if (i === vtActiveClipIdx) block.classList.add('active');
    block.style.left = (offset / totalDuration * 100) + '%';
    block.style.width = (clipDur / totalDuration * 100) + '%';
    block.dataset.clipIdx = i;

    // Clip label
    const label = document.createElement('span');
    label.textContent = clip.name || 'Clip ' + (i+1);
    label.style.pointerEvents = 'none';
    block.appendChild(label);

    block.style.background = `rgba(${96 + i*50},${165 - i*30},${250 - i*40},0.2)`;
    block.style.borderColor = `rgba(${96 + i*50},${165 - i*30},${250 - i*40},0.4)`;

    // Per-clip trim handles
    const leftH = document.createElement('div');
    leftH.className = 'clip-trim-handle left';
    block.appendChild(leftH);
    makeClipTrimDraggable(leftH, i, 'left');

    const rightH = document.createElement('div');
    rightH.className = 'clip-trim-handle right';
    block.appendChild(rightH);
    makeClipTrimDraggable(rightH, i, 'right');

    // Click to seek to clip start
    block.addEventListener('click', e => {
      if (e.target.classList.contains('clip-trim-handle')) return;
      let seekT = 0;
      for (let j = 0; j < i; j++) {
        const cj = state.timeline.clips[j];
        seekT += cj.duration * ((cj.trimOut || 1) - (cj.trimIn || 0));
      }
      vtSeek(seekT);
    });

    // Drag reordering
    block.draggable = true;
    block.addEventListener('dragstart', e => {
      e.dataTransfer.setData('text/plain', String(i));
      block.classList.add('dragging');
    });
    block.addEventListener('dragend', () => { block.classList.remove('dragging'); });
    block.addEventListener('dragover', e => { e.preventDefault(); });
    block.addEventListener('drop', e => {
      e.preventDefault();
      const fromIdx = parseInt(e.dataTransfer.getData('text/plain'));
      const toIdx = i;
      if (fromIdx === toIdx) return;
      pushUndoState();
      const [moved] = state.timeline.clips.splice(fromIdx, 1);
      state.timeline.clips.splice(toIdx, 0, moved);
      rebuildTimeline();
    });

    track.appendChild(block);

    // Transition indicator between clips
    if (transType !== 'cut' && i < state.timeline.clips.length - 1) {
      const indicator = document.createElement('div');
      indicator.className = 'clip-trans-indicator';
      indicator.style.left = ((offset + clipDur) / totalDuration * 100) + '%';
      indicator.style.transform = 'translateX(-2px)';
      indicator.title = transType;
      track.appendChild(indicator);
    }

    offset += clipDur;
  });

  // Keyframe diamonds
  state.timeline.keyframes.forEach((kf, i) => {
    const diamond = document.createElement('div');
    diamond.className = 'keyframe-diamond';
    diamond.style.left = (kf.time / totalDuration * 100) + '%';
    diamond.style.bottom = '2px';
    diamond.title = `KF ${i+1}: ${kf.time.toFixed(1)}s`;
    diamond.addEventListener('dblclick', () => {
      state.timeline.keyframes.splice(i, 1);
      rebuildTimeline();
    });
    track.appendChild(diamond);
  });

  // Annotation time range markers
  state.layers.forEach(layer => {
    if (layer.type !== 'annotation') return;
    if (layer.startTime === undefined) return;
    const endT = layer.endTime === Infinity ? totalDuration : layer.endTime;
    const leftPct = Math.max(0, layer.startTime / totalDuration * 100);
    const widthPct = Math.min(100 - leftPct, (endT - layer.startTime) / totalDuration * 100);
    const marker = document.createElement('div');
    marker.className = 'anno-marker';
    marker.style.cssText = 'position:absolute;bottom:0;height:3px;border-radius:1px;opacity:0.7;pointer-events:none;background:' + (layer.color || '#ff4444');
    marker.style.left = leftPct + '%';
    marker.style.width = widthPct + '%';
    marker.title = (layer.annoType || 'Annotation') + ': ' + layer.startTime.toFixed(1) + 's\u2013' + (layer.endTime === Infinity ? 'end' : layer.endTime.toFixed(1) + 's');
    track.appendChild(marker);
  });
}

function makeClipTrimDraggable(handle, clipIdx, side) {
  let dragging = false;
  handle.addEventListener('mousedown', e => { e.stopPropagation(); e.preventDefault(); dragging = true; });
  document.addEventListener('mousemove', e => {
    if (!dragging) return;
    const clip = state.timeline.clips[clipIdx];
    if (!clip) return;
    const block = handle.parentElement;
    const rect = block.getBoundingClientRect();
    let pct = (e.clientX - rect.left) / rect.width;
    pct = Math.max(0, Math.min(1, pct));
    if (side === 'left') {
      clip.trimIn = Math.min(pct, (clip.trimOut || 1) - 0.02);
    } else {
      clip.trimOut = Math.max(pct, (clip.trimIn || 0) + 0.02);
    }
    rebuildTimeline();
  });
  document.addEventListener('mouseup', () => {
    if (dragging) { dragging = false; }
  });
}

function updateTimelineScrubber() {
  // Add null check for scrubber element
  if (!timelineScrubber) {
    console.warn('Timeline scrubber element not found');
    return;
  }

  const totalDuration = vtGetTotalDuration();
  if (!totalDuration || typeof totalDuration !== 'number' || isNaN(totalDuration)) return;

  // Use requestAnimationFrame for smooth animations
  requestAnimationFrame(() => {
    try {
      const pct = (vtTime / totalDuration) * 100;

      // Validate percentage before applying
      if (typeof pct === 'number' && !isNaN(pct)) {
        const clampedPct = Math.max(0, Math.min(100, pct));
        timelineScrubber.style.transform = `translateX(${clampedPct}%)`;
        timelineScrubber.style.left = '0';
      }

      // Update active clip highlight with null check
      if (!timelineTrack) return;

      const info = vtGetClipAt(vtTime);
      if (info) {
        const clipBlocks = timelineTrack.querySelectorAll('.clip-block');
        clipBlocks.forEach((b, i) => {
          b.classList.toggle('active', i === info.index);
        });
      }
    } catch (error) {
      console.error('Error updating timeline scrubber:', error);
    }
  });
}

// ============================================================

// RENDER SCALE + CANVAS
// ============================================================
const RENDER_SCALE = 3;
const canvas = document.getElementById('renderCanvas');
const ctx = canvas.getContext('2d');

function getCanvasSize() {
  const dev = DEVICES[state.device.type];
  const preset = PRESETS[state.preset];
  if (!preset) {
    // Device-only mode  no device means default to reels
    if (state.device.type === 'none') return { w: 1080, h: 1920 };
    let w = dev.baseW, h = dev.baseH;
    if (state.device.landscape) { let t = w; w = h; h = t; }
    return { w: w * RENDER_SCALE, h: h * RENDER_SCALE };
  }
  return { w: preset.w, h: preset.h };
}

function resizeCanvas() {
  const sz = getCanvasSize();
  canvas.width = sz.w;
  canvas.height = sz.h;
  updateDisplaySize();
}

// ============================================================
// DOM REFS
// ============================================================
const video = document.getElementById('srcVideo');
const fileInput = document.getElementById('fileInput');
const logoInput = document.getElementById('logoInput');
const clipInput = document.getElementById('clipInput');
const promptEl = document.getElementById('prompt');
const dropOverlay = document.getElementById('dropOverlay');
const playbackBar = document.getElementById('playbackBar');
const playBtn = document.getElementById('playBtn');
const iconPlay = document.getElementById('iconPlay');
const iconPause = document.getElementById('iconPause');
const progressTrack = document.getElementById('progressTrack');
const progressFill = document.getElementById('progressFill');
const timeLabel = document.getElementById('timeLabel');
const bgColorInput = document.getElementById('bgColor');
const scaleSlider = document.getElementById('scaleSlider');
const scaleVal = document.getElementById('scaleVal');
const shadowSlider = document.getElementById('shadowSlider');
const loadBtn = document.getElementById('loadBtn');
const loopBtn = document.getElementById('loopBtn');
const ssBtn = document.getElementById('ssBtn');
const thumbBtn = document.getElementById('thumbBtn');
const exportBtn = document.getElementById('exportBtn');
const exportStatus = document.getElementById('exportStatus');
const exportText = document.getElementById('exportText');
const exportBarFill = document.getElementById('exportBarFill');
const canvasWrap = document.getElementById('canvasWrap');
const presetSelect = document.getElementById('presetSelect');
const customSizeWrap = document.getElementById('customSizeWrap');
const customW = document.getElementById('customW');
const customH = document.getElementById('customH');
const deviceGrid = document.getElementById('deviceGrid');
const layerList = document.getElementById('layerList');
const tiltXSlider = document.getElementById('tiltX');
const tiltYSlider = document.getElementById('tiltY');
const speedSelect = document.getElementById('speedSelect');
const entranceSelect = document.getElementById('entranceSelect');
const entranceDur = document.getElementById('entranceDur');
const entranceDurVal = document.getElementById('entranceDurVal');
const timelineBar = document.getElementById('timelineBar');
const timelineTrack = document.getElementById('timelineTrack');
const timelineScrubber = document.getElementById('timelineScrubber');

let hasVideo = false;
let isLooping = true;
let isExporting = false;
let playbackStartTime = 0;

// ============================================================
// RENDER LAYER FUNCTIONS (stack-based)
// ============================================================

function renderBackground(ctx, CW, CH) {
  if (state.bgType === 'transparent') return;
  if (state.bgType === 'gradient') {
    drawGradientBG(ctx, CW, CH);
  } else {
    ctx.fillStyle = state.background.color;
    ctx.fillRect(0, 0, CW, CH);
  }
}

function calcDevicePosition(CW, CH) {
  const dev = DEVICES[state.device.type];
  let devW = dev.baseW, devH = dev.baseH;
  if (state.device.landscape) { let t = devW; devW = devH; devH = t; }

  // Get keyframe values if animating
  const kf = hasVideo ? getDeviceKeyframeValues(vtTime) : null;

  // Use keyframe values if available, otherwise use state values
  const deviceX = kf ? kf.x : state.device.x;
  const deviceY = kf ? kf.y : state.device.y;
  const deviceScale = kf ? kf.scale : state.device.scale;
  const rotation = kf ? kf.rotation : 0;

  const preset = PRESETS[state.preset];
  let devScale, devX, devY;
  const isComparing = state.comparison.enabled && state.comparison.device2;
  if (!preset) {
    devScale = RENDER_SCALE;
    devX = 0; devY = 0;
  } else {
    const padFrac = 0.12;
    const areaW = isComparing ? CW * 0.45 : CW;
    const availW = areaW * (1 - padFrac*2);
    const availH = CH * (1 - padFrac*2);
    const fitScale = Math.min(availW / devW, availH / devH);
    devScale = fitScale * deviceScale;
    if (isComparing) {
      devX = CW * 0.25 - (devW * devScale) / 2;
    } else {
      devX = (CW - devW * devScale) / 2;
    }
    devY = (CH - devH * devScale) / 2;
  }
  // Apply user position offset
  devX += deviceX;
  devY += deviceY;
  return { dev, devW, devH, devScale, devX, devY, rotation, isComparing };
}

function calcSceneTransform() {
  const t = hasVideo ? vtTime : 0;
  const elapsed = t * 1000;
  const ent = getEntranceTransform(elapsed);
  const kf = getKeyframeValues(t);
  const animT = getAnimPresetTransform(hasVideo ? t : performance.now() * 0.001);
  return { ent, kf, animT };
}

function applySceneTransform(ctx, CW, CH, t) {
  const combinedZoom = t.kf.zoom * t.animT.zoom;
  const combinedPanX = t.kf.panX + t.animT.panX;
  const combinedPanY = t.kf.panY + t.animT.panY;
  ctx.translate(CW/2, CH/2);
  ctx.scale(combinedZoom, combinedZoom);
  ctx.rotate(t.animT.rotation * Math.PI / 180);
  ctx.translate(-CW/2 + combinedPanX, -CH/2 + combinedPanY);
  ctx.globalAlpha = t.ent.opacity;
  ctx.translate(CW/2, CH/2);
  ctx.translate(t.ent.x, t.ent.y);
  ctx.scale(t.ent.scale, t.ent.scale);
  ctx.rotate(t.ent.rotate * Math.PI/180);
  ctx.translate(-CW/2, -CH/2);
}

function renderBgVideoLayer(ctx, CW, CH) {
  if (!state.bgVideo.enabled) return;
  const bgVid = document.getElementById('bgVideo');
  if (!bgVid || bgVid.readyState < 2) return;
  ctx.save();
  ctx.globalAlpha = state.bgVideo.opacity;
  const vw = bgVid.videoWidth, vh = bgVid.videoHeight;
  let dx = 0, dy = 0, dw = CW, dh = CH;
  if (state.bgVideo.fit === 'cover') {
    const cRatio = CW / CH, vRatio = vw / vh;
    if (vRatio > cRatio) { dh = CH; dw = CH * vRatio; dx = (CW - dw) / 2; }
    else { dw = CW; dh = CW / vRatio; dy = (CH - dh) / 2; }
  } else if (state.bgVideo.fit === 'contain') {
    const cRatio = CW / CH, vRatio = vw / vh;
    if (vRatio > cRatio) { dw = CW; dh = CW / vRatio; dy = (CH - dh) / 2; }
    else { dh = CH; dw = CH * vRatio; dx = (CW - dw) / 2; }
  }
  safeDrawImage(ctx, bgVid, dx, dy, dw, dh);
  ctx.restore();
}

function renderParticlesLayer(ctx, CW, CH) {
  if (state.particles.enabled) drawParticles(ctx, CW, CH);
}

function renderDeviceLayer(ctx, CW, CH, dc) {
  const _activeVid = vtGetActiveVideo();
  // No-device mode: render video full-bleed
  if (state.device.type === 'none') {
    if (hasVideo && _activeVid.readyState >= 2) {
      const chromaFrame = getChromaKeyFrame(_activeVid);
      const vidSrc = chromaFrame || _activeVid;
      const vw = chromaFrame ? chromaFrame.width : _activeVid.videoWidth;
      const vh = chromaFrame ? chromaFrame.height : _activeVid.videoHeight;
      const cRatio = CW / CH, vRatio = vw / vh;
      let dw, dh, dx, dy;
      if (state.videoFit === 'stretch') {
        dx = 0; dy = 0; dw = CW; dh = CH;
      } else if (state.videoFit === 'contain') {
        if (vRatio > cRatio) { dw = CW; dh = CW / vRatio; dx = 0; dy = (CH - dh) / 2; }
        else { dh = CH; dw = CH * vRatio; dx = (CW - dw) / 2; dy = 0; }
      } else {
        if (vRatio > cRatio) { dh = CH; dw = CH * vRatio; dx = (CW - dw) / 2; dy = 0; }
        else { dw = CW; dh = CW / vRatio; dx = 0; dy = (CH - dh) / 2; }
      }
      safeDrawImage(ctx, vidSrc, dx, dy, dw, dh);
      // Transition overlay for no-device mode
      const _transNd = vtGetTransition();
      if (_transNd && _transNd.inClip.video.readyState >= 2) {
        const tVid = _transNd.inClip.video;
        const tSrc2 = getChromaKeyFrame(tVid) || tVid;
        if (_transNd.type === 'crossfade') {
          ctx.globalAlpha = _transNd.progress;
          safeDrawImage(ctx, tSrc2, dx, dy, dw, dh);
          ctx.globalAlpha = 1;
        } else if (_transNd.type === 'slide') {
          safeDrawImage(ctx, tSrc2, dx + CW * (1 - _transNd.progress), dy, dw, dh);
        }
      }
    }
    return;
  }

  const { dev, devW, devH, devScale, devX, devY, rotation } = dc;

  // Hand overlay (behind device)
  if (state.hand.enabled) {
    drawHandOverlay(ctx, dev, devScale, state.hand.style, devX, devY);
  }

  // Drop shadow
  if (state.shadow > 0) {
    ctx.save();
    ctx.shadowColor = 'rgba(0,0,0,' + (0.55 * state.shadow) + ')';
    ctx.shadowBlur = 70 * (devScale/RENDER_SCALE) * state.shadow;
    ctx.shadowOffsetY = 18 * (devScale/RENDER_SCALE) * state.shadow;
    ctx.translate(devX, devY);
    // Apply keyframe rotation
    if (rotation) {
      ctx.translate(devW*devScale/2, devH*devScale/2);
      ctx.rotate(rotation * Math.PI / 180);
      ctx.translate(-devW*devScale/2, -devH*devScale/2);
    }
    if (state.device.landscape) {
      ctx.translate(devW*devScale/2, devH*devScale/2);
      ctx.rotate(-Math.PI/2);
      ctx.translate(-dev.baseW*devScale/2, -dev.baseH*devScale/2);
    }
    rrPath(ctx, 3*(devScale/RENDER_SCALE), 3*(devScale/RENDER_SCALE),
      (dev.baseW-6)*devScale, (dev.baseH-6)*devScale, (dev.cornerR-3)*devScale);
    ctx.fillStyle = '#000'; ctx.fill();
    ctx.restore();
  }

  // Draw video into screen
  ctx.save();
  ctx.translate(devX, devY);
  // Apply keyframe rotation
  if (rotation) {
    ctx.translate(devW*devScale/2, devH*devScale/2);
    ctx.rotate(rotation * Math.PI / 180);
    ctx.translate(-devW*devScale/2, -devH*devScale/2);
  }
  if (state.device.landscape) {
    ctx.translate(devW*devScale/2, devH*devScale/2);
    ctx.rotate(-Math.PI/2);
    ctx.translate(-dev.baseW*devScale/2, -dev.baseH*devScale/2);
  }

  if (hasVideo && _activeVid.readyState >= 2) {
    // Handle standstill modes
    if (state.standstill?.mode === 'freezeBoth') {
      // Freeze both device and content at specific time
      const freezeTime = state.standstill.freezeTime || 0;
      if (_activeVid.currentTime !== freezeTime) {
        _activeVid.currentTime = freezeTime;
      }
      if (vtPlaying) {
        _activeVid.pause();
      }
    } else if (state.standstill?.mode === 'freezeDevice') {
      // Device frozen by keyframe, but content loops
      if (state.standstill.contentLoop?.enabled) {
        const loop = state.standstill.contentLoop;
        const duration = _activeVid.duration;
        const loopStart = loop.start * duration;
        const loopEnd = loop.end * duration;

        if (_activeVid.currentTime >= loopEnd) {
          _activeVid.currentTime = loopStart;
        }
      }
    }

    ctx.save();
    rrPath(ctx, dev.screenX*devScale, dev.screenY*devScale, dev.screenW*devScale, dev.screenH*devScale, dev.screenR*devScale);
    ctx.clip();
    const sw = dev.screenW * devScale, sh = dev.screenH * devScale;
    const chromaFrame = getChromaKeyFrame(_activeVid);
    const vidSrc = chromaFrame || _activeVid;
    const vw = chromaFrame ? chromaFrame.width : _activeVid.videoWidth;
    const vh = chromaFrame ? chromaFrame.height : _activeVid.videoHeight;
    const sRatio = sw/sh, vRatio = vw/vh;
    let dw, dh, dx, dy;
    if (state.videoFit === 'stretch') {
      dx = dev.screenX*devScale; dy = dev.screenY*devScale; dw = sw; dh = sh;
    } else if (state.videoFit === 'contain') {
      if (vRatio > sRatio) { dw = sw; dh = sw/vRatio; dx = dev.screenX*devScale; dy = dev.screenY*devScale+(sh-dh)/2; }
      else { dh = sh; dw = sh*vRatio; dx = dev.screenX*devScale+(sw-dw)/2; dy = dev.screenY*devScale; }
    } else {
      if (vRatio > sRatio) { dh = sh; dw = sh*vRatio; dx = dev.screenX*devScale+(sw-dw)/2; dy = dev.screenY*devScale; }
      else { dw = sw; dh = sw/vRatio; dx = dev.screenX*devScale; dy = dev.screenY*devScale+(sh-dh)/2; }
    }
    safeDrawImage(ctx, vidSrc, dx, dy, dw, dh);

    // Transition overlay (incoming clip)
    const _trans = vtGetTransition();
    if (_trans && _trans.inClip.video.readyState >= 2) {
      const tVid = _trans.inClip.video;
      const tChroma = getChromaKeyFrame(tVid);
      const tSrc = tChroma || tVid;
      const tvw = tChroma ? tChroma.width : tVid.videoWidth;
      const tvh = tChroma ? tChroma.height : tVid.videoHeight;
      const tRatio = tvw/tvh;
      let tdw, tdh, tdx, tdy;
      if (state.videoFit === 'stretch') { tdx = dev.screenX*devScale; tdy = dev.screenY*devScale; tdw = sw; tdh = sh; }
      else if (state.videoFit === 'contain') {
        if (tRatio > sRatio) { tdw=sw; tdh=sw/tRatio; tdx=dev.screenX*devScale; tdy=dev.screenY*devScale+(sh-tdh)/2; }
        else { tdh=sh; tdw=sh*tRatio; tdx=dev.screenX*devScale+(sw-tdw)/2; tdy=dev.screenY*devScale; }
      } else {
        if (tRatio > sRatio) { tdh=sh; tdw=sh*tRatio; tdx=dev.screenX*devScale+(sw-tdw)/2; tdy=dev.screenY*devScale; }
        else { tdw=sw; tdh=sw/tRatio; tdx=dev.screenX*devScale; tdy=dev.screenY*devScale+(sh-tdh)/2; }
      }
      if (_trans.type === 'crossfade') {
        ctx.globalAlpha = _trans.progress;
        safeDrawImage(ctx, tSrc, tdx, tdy, tdw, tdh);
        ctx.globalAlpha = 1;
      } else if (_trans.type === 'slide') {
        const slideOffset = sw * (1 - _trans.progress);
        safeDrawImage(ctx, tSrc, tdx + slideOffset, tdy, tdw, tdh);
      }
    }
    ctx.restore();
  } else {
    ctx.save();
    rrPath(ctx, dev.screenX*devScale, dev.screenY*devScale, dev.screenW*devScale, dev.screenH*devScale, dev.screenR*devScale);
    ctx.fillStyle = '#000'; ctx.fill();
    ctx.restore();
  }

  // Device frame
  const frame = getDeviceFrame(state.device.type, state.device.color);
  ctx.drawImage(frame, 0, 0, frame.width, frame.height, 0, 0, dev.baseW*devScale, dev.baseH*devScale);

  // Glass reflection
  if (hasVideo) {
    ctx.save();
    rrPath(ctx, dev.screenX*devScale, dev.screenY*devScale, dev.screenW*devScale, dev.screenH*devScale, dev.screenR*devScale);
    ctx.clip();
    const g = ctx.createLinearGradient(0, 0, dev.screenW*devScale*0.7, dev.screenH*devScale*0.4);
    g.addColorStop(0, 'rgba(255,255,255,0.025)');
    g.addColorStop(0.35, 'rgba(255,255,255,0)');
    ctx.fillStyle = g;
    ctx.fillRect(0, 0, dev.baseW*devScale, dev.baseH*devScale);
    ctx.restore();
  }

  ctx.restore(); // device translate
}

function renderDevice2Layer(ctx, CW, CH, dc) {
  if (!dc.isComparing) return;
  const dev2Id = state.comparison.device2.type;
  const dev2Color = state.comparison.device2.color;
  const dev2 = DEVICES[dev2Id];
  if (!dev2) return;

  let d2W = dev2.baseW, d2H = dev2.baseH;
  if (state.device.landscape) { let t = d2W; d2W = d2H; d2H = t; }
  const padFrac = 0.12;
  const areaW = CW * 0.45;
  const availW2 = areaW * (1 - padFrac*2);
  const availH2 = CH * (1 - padFrac*2);
  const fitScale2 = Math.min(availW2 / d2W, availH2 / d2H);
  const d2Scale = fitScale2 * state.device.scale;
  let d2X = CW * 0.75 - (d2W * d2Scale) / 2;
  let d2Y = (CH - d2H * d2Scale) / 2;
  // Apply user position offset for device 2
  d2X += state.comparison.x;
  d2Y += state.comparison.y;

  // Shadow for device 2
  if (state.shadow > 0) {
    ctx.save();
    ctx.shadowColor = 'rgba(0,0,0,' + (0.55 * state.shadow) + ')';
    ctx.shadowBlur = 70 * (d2Scale/RENDER_SCALE) * state.shadow;
    ctx.shadowOffsetY = 18 * (d2Scale/RENDER_SCALE) * state.shadow;
    ctx.translate(d2X, d2Y);
    rrPath(ctx, 3*(d2Scale/RENDER_SCALE), 3*(d2Scale/RENDER_SCALE),
      (dev2.baseW-6)*d2Scale, (dev2.baseH-6)*d2Scale, (dev2.cornerR-3)*d2Scale);
    ctx.fillStyle = '#000'; ctx.fill();
    ctx.restore();
  }

  ctx.save();
  ctx.translate(d2X, d2Y);
  if (state.device.landscape) {
    ctx.translate(d2W*d2Scale/2, d2H*d2Scale/2);
    ctx.rotate(-Math.PI/2);
    ctx.translate(-dev2.baseW*d2Scale/2, -dev2.baseH*d2Scale/2);
  }

  // Black screen for device 2
  ctx.save();
  rrPath(ctx, dev2.screenX*d2Scale, dev2.screenY*d2Scale, dev2.screenW*d2Scale, dev2.screenH*d2Scale, dev2.screenR*d2Scale);
  ctx.fillStyle = '#000'; ctx.fill();
  ctx.restore();

  // Draw device 2 video if available
  const vid2 = document.getElementById('srcVideo2');
  if (vid2 && vid2.readyState >= 2 && vid2.src) {
    ctx.save();
    rrPath(ctx, dev2.screenX*d2Scale, dev2.screenY*d2Scale, dev2.screenW*d2Scale, dev2.screenH*d2Scale, dev2.screenR*d2Scale);
    ctx.clip();
    const sw2 = dev2.screenW*d2Scale, sh2 = dev2.screenH*d2Scale;
    const chromaFrame2 = getChromaKeyFrame(vid2);
    const vid2Src = chromaFrame2 || vid2;
    const vw2 = chromaFrame2 ? chromaFrame2.width : vid2.videoWidth;
    const vh2 = chromaFrame2 ? chromaFrame2.height : vid2.videoHeight;
    const sR2 = sw2/sh2, vR2 = vw2/vh2;
    let dw2, dh2, dx2, dy2;
    if (state.videoFit === 'stretch') {
      dx2 = dev2.screenX*d2Scale; dy2 = dev2.screenY*d2Scale; dw2 = sw2; dh2 = sh2;
    } else if (state.videoFit === 'contain') {
      if (vR2 > sR2) { dw2=sw2; dh2=sw2/vR2; dx2=dev2.screenX*d2Scale; dy2=dev2.screenY*d2Scale+(sh2-dh2)/2; }
      else { dh2=sh2; dw2=sh2*vR2; dx2=dev2.screenX*d2Scale+(sw2-dw2)/2; dy2=dev2.screenY*d2Scale; }
    } else {
      if (vR2 > sR2) { dh2=sh2; dw2=sh2*vR2; dx2=dev2.screenX*d2Scale+(sw2-dw2)/2; dy2=dev2.screenY*d2Scale; }
      else { dw2=sw2; dh2=sw2/vR2; dx2=dev2.screenX*d2Scale; dy2=dev2.screenY*d2Scale+(sh2-dh2)/2; }
    }
    safeDrawImage(ctx, vid2Src, dx2, dy2, dw2, dh2);
    ctx.restore();
  }

  const frame2 = getDeviceFrame(dev2Id, dev2Color);
  ctx.drawImage(frame2, 0, 0, frame2.width, frame2.height, 0, 0, dev2.baseW*d2Scale, dev2.baseH*d2Scale);
  ctx.restore();
}

function renderContentLayer(ctx, CW, CH) {
  if (state.layers.length === 0) return;
  const currentTime = hasVideo ? vtTime : 0;
  for (const layer of state.layers) {
    if (layer.visible === false) continue; // hidden via unified layers panel
    if (layer.type === 'text') {
      ctx.save();
      if (layer.opacity !== undefined) ctx.globalAlpha = layer.opacity;
      ctx.font = layer.weight + ' ' + layer.fontSize + 'px ' + layer.fontFamily;
      ctx.fillStyle = layer.color;
      ctx.textAlign = layer.align || 'left';
      ctx.textBaseline = 'top';
      if (layer.shadow > 0) {
        ctx.shadowColor = 'rgba(0,0,0,0.5)';
        ctx.shadowBlur = layer.shadow;
        ctx.shadowOffsetX = 2; ctx.shadowOffsetY = 2;
      }
      if (layer.outline > 0) {
        ctx.strokeStyle = 'rgba(0,0,0,0.7)';
        ctx.lineWidth = layer.outline;
        ctx.strokeText(layer.content, layer.x, layer.y);
      }
      ctx.fillText(layer.content, layer.x, layer.y);
      ctx.restore();
    } else if (layer.type === 'logo' && layer.img) {
      ctx.save();
      ctx.globalAlpha = layer.opacity;
      const aspect = layer.img.naturalWidth / layer.img.naturalHeight;
      const lh = layer.width / aspect;
      ctx.drawImage(layer.img, layer.x, layer.y, layer.width, lh);
      ctx.restore();
    } else if (layer.type === 'annotation') {
      if (layer.startTime !== undefined && (currentTime < layer.startTime || currentTime > layer.endTime)) continue;
      ctx.save();
      ctx.strokeStyle = layer.color;
      ctx.fillStyle = layer.color;
      ctx.lineWidth = layer.lineWidth;
      ctx.lineCap = 'round';
      ctx.lineJoin = 'round';
      if (layer.annoType === 'arrow' && layer.points && layer.points.length >= 2) {
        const p = layer.points;
        ctx.beginPath();
        ctx.moveTo(p[0].x, p[0].y);
        ctx.lineTo(p[1].x, p[1].y);
        ctx.stroke();
        const angle = Math.atan2(p[1].y - p[0].y, p[1].x - p[0].x);
        const headLen = 15;
        ctx.beginPath();
        ctx.moveTo(p[1].x, p[1].y);
        ctx.lineTo(p[1].x - headLen*Math.cos(angle - 0.4), p[1].y - headLen*Math.sin(angle - 0.4));
        ctx.lineTo(p[1].x - headLen*Math.cos(angle + 0.4), p[1].y - headLen*Math.sin(angle + 0.4));
        ctx.closePath();
        ctx.fill();
      } else if (layer.annoType === 'circle' && layer.points && layer.points.length >= 2) {
        const cx = (layer.points[0].x + layer.points[1].x) / 2;
        const cy = (layer.points[0].y + layer.points[1].y) / 2;
        const rx = Math.abs(layer.points[1].x - layer.points[0].x) / 2;
        const ry = Math.abs(layer.points[1].y - layer.points[0].y) / 2;
        ctx.beginPath();
        ctx.ellipse(cx, cy, rx, ry, 0, 0, Math.PI*2);
        ctx.stroke();
      } else if (layer.annoType === 'rect' && layer.points && layer.points.length >= 2) {
        const rx = Math.min(layer.points[0].x, layer.points[1].x);
        const ry = Math.min(layer.points[0].y, layer.points[1].y);
        const rw = Math.abs(layer.points[1].x - layer.points[0].x);
        const rh = Math.abs(layer.points[1].y - layer.points[0].y);
        ctx.strokeRect(rx, ry, rw, rh);
      } else if (layer.annoType === 'freehand' && layer.points && layer.points.length > 1) {
        ctx.beginPath();
        ctx.moveTo(layer.points[0].x, layer.points[0].y);
        for (let i = 1; i < layer.points.length; i++) {
          ctx.lineTo(layer.points[i].x, layer.points[i].y);
        }
        ctx.stroke();
      } else if (layer.annoType === 'callout' && layer.points && layer.points.length >= 1) {
        const p = layer.points[0];
        ctx.fillStyle = 'rgba(0,0,0,0.7)';
        rrPath(ctx, p.x, p.y, 140, 40, 6);
        ctx.fill();
        ctx.fillStyle = layer.color;
        ctx.font = '14px -apple-system, sans-serif';
        ctx.textBaseline = 'middle';
        ctx.fillText(layer.content || 'Note', p.x + 10, p.y + 20);
      }
      ctx.restore();
    }
  }
}

function renderFacecamLayer(ctx, CW, CH) {
  if (!state.facecam.enabled || !state.facecam.stream) return;
  const fcVideo = document.getElementById('facecamVideo');
  if (!fcVideo || fcVideo.readyState < 2) return;

  const sz2 = Math.round(Math.min(CW, CH) * state.facecam.size);
  const margin = Math.round(Math.min(CW, CH) * 0.03);
  let fx, fy;
  if (state.facecam.x >= 0 && state.facecam.y >= 0) {
    fx = state.facecam.x; fy = state.facecam.y;
  } else {
    switch (state.facecam.corner) {
      case 'TL': fx = margin; fy = margin; break;
      case 'TR': fx = CW - sz2 - margin; fy = margin; break;
      case 'BL': fx = margin; fy = CH - sz2 - margin; break;
      case 'custom': fx = state.facecam.x >= 0 ? state.facecam.x : CW/2 - sz2/2; fy = state.facecam.y >= 0 ? state.facecam.y : CH/2 - sz2/2; break;
      default:   fx = CW - sz2 - margin; fy = CH - sz2 - margin;
    }
    state.facecam.x = fx; state.facecam.y = fy;
  }
  // Drop shadow
  if (state.facecam.shadow) {
    ctx.save();
    ctx.shadowColor = 'rgba(0,0,0,0.5)';
    ctx.shadowBlur = sz2 * 0.15;
    ctx.shadowOffsetX = 0;
    ctx.shadowOffsetY = sz2 * 0.04;
    ctx.fillStyle = 'rgba(0,0,0,0.01)';
    if (state.facecam.shape === 'circle') {
      ctx.beginPath(); ctx.arc(fx+sz2/2, fy+sz2/2, sz2/2, 0, Math.PI*2); ctx.fill();
    } else if (state.facecam.shape === 'roundrect') {
      rrPath(ctx, fx, fy, sz2, sz2, sz2*0.2); ctx.fill();
    } else {
      ctx.fillRect(fx, fy, sz2, sz2);
    }
    ctx.restore();
  }
  // Clip to shape and draw video
  ctx.save();
  if (state.facecam.shape === 'circle') {
    ctx.beginPath(); ctx.arc(fx+sz2/2, fy+sz2/2, sz2/2, 0, Math.PI*2); ctx.clip();
  } else if (state.facecam.shape === 'roundrect') {
    rrPath(ctx, fx, fy, sz2, sz2, sz2*0.2); ctx.clip();
  } else {
    ctx.beginPath(); ctx.rect(fx, fy, sz2, sz2); ctx.clip();
  }
  const vw = fcVideo.videoWidth, vh = fcVideo.videoHeight;
  const vAspect = vw/vh;
  let dw, dh, dx, dy;
  if (vAspect > 1) { dh = sz2; dw = sz2*vAspect; dx = fx-(dw-sz2)/2; dy = fy; }
  else { dw = sz2; dh = sz2/vAspect; dx = fx; dy = fy-(dh-sz2)/2; }
  safeDrawImage(ctx, fcVideo, dx, dy, dw, dh);
  ctx.restore();
  // Border
  if (state.facecam.borderWidth > 0) {
    ctx.save();
    ctx.strokeStyle = state.facecam.borderColor;
    ctx.lineWidth = state.facecam.borderWidth;
    if (state.facecam.shape === 'circle') {
      ctx.beginPath(); ctx.arc(fx+sz2/2, fy+sz2/2, sz2/2 - state.facecam.borderWidth/2, 0, Math.PI*2); ctx.stroke();
    } else if (state.facecam.shape === 'roundrect') {
      const bw = state.facecam.borderWidth/2;
      rrPath(ctx, fx+bw, fy+bw, sz2-state.facecam.borderWidth, sz2-state.facecam.borderWidth, sz2*0.2); ctx.stroke();
    } else {
      ctx.strokeRect(fx+state.facecam.borderWidth/2, fy+state.facecam.borderWidth/2, sz2-state.facecam.borderWidth, sz2-state.facecam.borderWidth);
    }
    ctx.restore();
  }
}

function renderVideoOverlaysLayer(ctx, CW, CH) {
  if (state.videoOverlays.length > 0) drawVideoOverlays(ctx, CW, CH);
}

function renderUiOverlaysLayer(ctx, CW, CH) {
  if (state.waveform.enabled && hasVideo) drawWaveform(ctx, CW, CH);
  if (state.progressBar.enabled && hasVideo) drawProgressBar(ctx, CW, CH);
  if (state.glassmorphism.enabled) drawGlassmorphism(ctx, CW, CH);
}

function renderPostProcessing(ctx, CW, CH) {
  if (state.motionBlur.enabled) {
    ctx.save();
    ctx.globalAlpha = state.motionBlur.amount;
    ctx.globalCompositeOperation = 'source-atop';
    ctx.filter = 'blur(3px)';
    ctx.drawImage(canvas, 0, 0);
    ctx.restore();
  }
  drawGlitchEffect(ctx, CW, CH, hasVideo ? vtTime : performance.now() * 0.001);
  if (state.lut.enabled && state.lut.data) applyLUT(canvas, state.lut, state.lut.intensity);
}

// Groups that receive scene transforms (entrance, keyframe, animation)
const SCENE_GROUPS = new Set(['device', 'device2', 'content']);

// Render dispatch map
const RENDER_MAP = {
  bgVideo: renderBgVideoLayer,
  particles: renderParticlesLayer,
  device: renderDeviceLayer,
  device2: renderDevice2Layer,
  content: renderContentLayer,
  facecam: renderFacecamLayer,
  videoOverlays: renderVideoOverlaysLayer,
  uiOverlays: renderUiOverlaysLayer,
};

// ============================================================
// MAIN RENDER (stack-based)
// ============================================================
let _renderErrorCount = 0;
let _renderLastError = null;
let _renderStopped = false;

function render() {
  try {
    vtTick();

    // Auto-setup audio analyser when an animation preset is active and video is loaded
    if (state.animPreset.type !== 'none' && hasVideo && !audioAnalyser) setupAudioAnalyser();

    // Update beat detector every frame
    beatDetector.update(hasVideo ? vtTime : performance.now() * 0.001);

    // Update displayed BPM when auto BPM is active
    if (state.animPreset.autoBPM && beatDetector.estimatedBPM > 0) {
      document.getElementById('animBPMVal').textContent = beatDetector.estimatedBPM;
    }

    const sz = getCanvasSize();
    const CW = sz.w, CH = sz.h;
    ctx.clearRect(0, 0, CW, CH);

    // Background (always first, not in stack)
    renderBackground(ctx, CW, CH);

    // Calculate device positioning
    const dc = calcDevicePosition(CW, CH);

    // Calculate scene transforms
    const sceneT = calcSceneTransform();

    // Iterate render stack in order (skip hidden groups)
    for (const group of state.renderStack) {
      if (group.hidden) continue;
      const fn = RENDER_MAP[group.id];
      if (!fn) continue;

      if (SCENE_GROUPS.has(group.id)) {
        // Scene groups get entrance/keyframe/animation transforms
        ctx.save();
        applySceneTransform(ctx, CW, CH, sceneT);
        fn(ctx, CW, CH, dc);
        ctx.restore();
      } else {
        fn(ctx, CW, CH, dc);
      }
    }

    // Post-processing (always last, not in stack)
    renderPostProcessing(ctx, CW, CH);

    // Successful frame  reset error counter
    _renderErrorCount = 0;

    requestAnimationFrame(render);
  } catch (err) {
    console.error('Render error:', err);
    _renderLastError = err;
    _renderErrorCount++;

    if (_renderErrorCount < 3) {
      // Continue rendering despite error
      requestAnimationFrame(render);
    } else {
      // Stop rendering and show error banner
      _renderStopped = true;
      showRenderErrorBanner(err);
    }
  }
}

function showRenderErrorBanner(err) {
  let banner = document.getElementById('renderErrorBanner');
  if (!banner) {
    banner = document.createElement('div');
    banner.id = 'renderErrorBanner';
    banner.style.cssText = 'position:fixed;top:50px;left:50%;transform:translateX(-50%);z-index:500;background:rgba(30,10,10,0.95);border:1px solid rgba(255,80,80,0.3);border-radius:10px;padding:12px 20px;font-size:12px;color:#f88;display:flex;align-items:center;gap:12px;backdrop-filter:blur(12px)';
    banner.innerHTML = '<span>Rendering paused due to errors.</span><button id="renderRestart" style="background:rgba(255,255,255,0.1);border:1px solid rgba(255,255,255,0.15);border-radius:5px;color:#ccc;padding:4px 12px;font-size:11px;cursor:pointer">Restart</button><button id="renderDetails" style="background:none;border:1px solid rgba(255,255,255,0.1);border-radius:5px;color:#888;padding:4px 12px;font-size:11px;cursor:pointer">Details</button>';
    document.body.appendChild(banner);
    document.getElementById('renderRestart').addEventListener('click', restartRender);
    document.getElementById('renderDetails').addEventListener('click', () => {
      alert(_renderLastError ? _renderLastError.stack || _renderLastError.message : 'No error details available.');
    });
  }
  banner.style.display = 'flex';
}

function restartRender() {
  const banner = document.getElementById('renderErrorBanner');
  if (banner) banner.style.display = 'none';
  _renderErrorCount = 0;
  _renderLastError = null;
  _renderStopped = false;
  requestAnimationFrame(render);
}

// ============================================================
// CANVAS DISPLAY SIZE
// ============================================================
function updateDisplaySize() {
  const sz = getCanvasSize();
  const pct = parseInt(scaleSlider.value) / 100;
  const stage = document.getElementById('stage');
  const maxH = stage.clientHeight - 20;
  const maxW = stage.clientWidth - 20;
  let h = maxH * pct;
  let w = h * (sz.w / sz.h);
  if (w > maxW * pct) { w = maxW * pct; h = w * (sz.h / sz.w); }
  canvas.style.width = w + 'px';
  canvas.style.height = h + 'px';
  scaleVal.textContent = scaleSlider.value + '%';
}

// ============================================================
// 3D PERSPECTIVE
// ============================================================
function updatePerspective() {
  // Get keyframe values if animating, otherwise use sliders
  const kf = hasVideo ? getDeviceKeyframeValues(vtTime) : null;
  const rx = kf ? kf.perspectiveX : parseInt(tiltXSlider.value);
  const ry = kf ? kf.perspectiveY : parseInt(tiltYSlider.value);
  const orbitY = getOrbitAngle();
  const totalRx = rx;
  const totalRy = ry + orbitY;
  if (totalRx === 0 && totalRy === 0 && !state.orbit.enabled) {
    canvasWrap.style.transform = '';
  } else {
    canvasWrap.style.transform = `perspective(1200px) rotateX(${totalRx}deg) rotateY(${totalRy}deg)`;
  }
  // Only update state from sliders if not using keyframes
  if (!kf) {
    state.perspective.x = rx;
    state.perspective.y = ry;
  }
}
// Orbit animation loop
function orbitLoop() {
  if (state.orbit.enabled) updatePerspective();
  requestAnimationFrame(orbitLoop);
}
orbitLoop();

// ============================================================

// HAND OVERLAY SVG PATHS
// ============================================================
function drawHandOverlay(c, dev, S, style, devX, devY) {
  if (dev.id !== 'iphone16' && dev.id !== 'applewatch') return;
  c.save();
  c.translate(devX, devY);

  const w = dev.baseW * S;
  const h = dev.baseH * S;

  c.fillStyle = '#e8c4a0';
  c.strokeStyle = '#c8a080';
  c.lineWidth = 1.5 * S;

  if (style === 'right') {
    // Right hand - fingers wrapping around left side, thumb on right
    // Palm behind phone
    c.beginPath();
    c.ellipse(w * 0.5, h * 1.02, w * 0.42, h * 0.12, 0, 0, Math.PI * 2);
    c.fill(); c.stroke();

    // Fingers on left
    for (let i = 0; i < 4; i++) {
      const fy = h * (0.35 + i * 0.1);
      c.beginPath();
      c.ellipse(-w * 0.04, fy, w * 0.06, h * 0.035, -0.2, 0, Math.PI * 2);
      c.fill(); c.stroke();
    }

    // Thumb on right
    c.beginPath();
    c.ellipse(w * 1.03, h * 0.55, w * 0.05, h * 0.08, 0.3, 0, Math.PI * 2);
    c.fill(); c.stroke();
  } else {
    // Left hand - mirror
    c.beginPath();
    c.ellipse(w * 0.5, h * 1.02, w * 0.42, h * 0.12, 0, 0, Math.PI * 2);
    c.fill(); c.stroke();

    for (let i = 0; i < 4; i++) {
      const fy = h * (0.35 + i * 0.1);
      c.beginPath();
      c.ellipse(w * 1.04, fy, w * 0.06, h * 0.035, 0.2, 0, Math.PI * 2);
      c.fill(); c.stroke();
    }

    c.beginPath();
    c.ellipse(-w * 0.03, h * 0.55, w * 0.05, h * 0.08, -0.3, 0, Math.PI * 2);
    c.fill(); c.stroke();
  }

  c.restore();
}

// ============================================================
// GRADIENT BACKGROUND
// ============================================================
let gradientAngleOffset = 0;

function drawGradientBG(c, CW, CH) {
  const g = state.gradient;
  if (g.animated) gradientAngleOffset += g.speed * 0.3;
  const angle = (g.angle + gradientAngleOffset) % 360;
  const rad = angle * Math.PI / 180;
  const cx = CW/2, cy = CH/2;
  const len = Math.max(CW, CH);
  const x1 = cx - Math.cos(rad) * len/2;
  const y1 = cy - Math.sin(rad) * len/2;
  const x2 = cx + Math.cos(rad) * len/2;
  const y2 = cy + Math.sin(rad) * len/2;
  const grad = c.createLinearGradient(x1, y1, x2, y2);
  grad.addColorStop(0, g.color1);
  grad.addColorStop(0.5, g.color2);
  grad.addColorStop(1, g.color3);
  c.fillStyle = grad;
  c.fillRect(0, 0, CW, CH);
}

// ============================================================
// PARTICLE SYSTEM
// ============================================================
function initParticles(CW, CH) {
  state._particles = [];
  for (let i = 0; i < state.particles.count; i++) {
    state._particles.push({
      x: Math.random() * CW, y: Math.random() * CH,
      size: Math.random() * 15 + 3,
      speedX: (Math.random() - 0.5) * 0.8,
      speedY: (Math.random() - 0.5) * 0.8 - 0.3,
      opacity: Math.random() * 0.5 + 0.2,
      phase: Math.random() * Math.PI * 2,
      hue: Math.random() * 360,
    });
  }
}

function drawParticles(c, CW, CH) {
  if (state._particles.length !== state.particles.count) initParticles(CW, CH);
  const t = performance.now() * 0.001;
  const spd = state.particles.speed;
  for (const p of state._particles) {
    p.x += p.speedX * spd; p.y += p.speedY * spd;
    if (p.y < -20) { p.y = CH + 20; p.x = Math.random() * CW; }
    if (p.x < -20) p.x = CW + 20;
    if (p.x > CW + 20) p.x = -20;
    if (p.y > CH + 20) { p.y = -20; p.x = Math.random() * CW; }
    const flicker = Math.sin(t * 1.5 + p.phase) * 0.3 + 0.7;
    c.save(); c.globalAlpha = p.opacity * flicker;
    if (state.particles.type === 'bokeh') {
      const grad = c.createRadialGradient(p.x, p.y, 0, p.x, p.y, p.size);
      grad.addColorStop(0, state.particles.color); grad.addColorStop(0.4, state.particles.color); grad.addColorStop(1, 'transparent');
      c.fillStyle = grad; c.beginPath(); c.arc(p.x, p.y, p.size, 0, Math.PI*2); c.fill();
    } else if (state.particles.type === 'sparkle') {
      c.fillStyle = state.particles.color; c.translate(p.x, p.y); c.rotate(t + p.phase);
      for (let j = 0; j < 4; j++) { c.fillRect(-0.5, -p.size*0.5, 1, p.size); c.rotate(Math.PI/4); }
    } else if (state.particles.type === 'confetti') {
      c.fillStyle = `hsl(${p.hue}, 80%, 65%)`; c.translate(p.x, p.y); c.rotate(t*2 + p.phase);
      c.fillRect(-p.size/2, -p.size/4, p.size, p.size/2);
    } else if (state.particles.type === 'snow') {
      c.fillStyle = '#fff'; p.x += Math.sin(t + p.phase)*0.3; p.speedY = Math.abs(p.speedY) || 0.5;
      c.beginPath(); c.arc(p.x, p.y, p.size*0.4, 0, Math.PI*2); c.fill();
    }
    c.restore();
  }
}

// ============================================================
// ORBIT (auto-spin)
// ============================================================
function getOrbitAngle() {
  if (!state.orbit.enabled) return 0;
  return Math.sin(performance.now() * 0.001 * state.orbit.speed) * state.orbit.range;
}

// ============================================================
// SHARED AUDIO CONTEXT (singleton  used by analyser, export, beat detector)
// ============================================================
let sharedAudioCtx = null;
let sharedSourceNode = null;

function getSharedAudioContext() {
  if (!sharedAudioCtx) {
    sharedAudioCtx = new (window.AudioContext || window.webkitAudioContext)();
  }
  return sharedAudioCtx;
}

function getSharedSourceNode() {
  if (!sharedSourceNode) {
    var ctx = getSharedAudioContext();
    sharedSourceNode = ctx.createMediaElementSource(document.getElementById('srcVideo'));
  }
  return sharedSourceNode;
}

function reconnectAudioGraph() {
  if (!sharedSourceNode) return;
  try {
    sharedSourceNode.disconnect();
    if (audioAnalyser) {
      sharedSourceNode.connect(audioAnalyser);
    } else if (sharedAudioCtx) {
      sharedSourceNode.connect(sharedAudioCtx.destination);
    }
  } catch(e) {}
}

// ============================================================
// WAVEFORM VISUALIZER
// ============================================================
let audioAnalyser = null, analyserData = null;
function setupAudioAnalyser() {
  if (audioAnalyser) return;
  try {
    var ctx = getSharedAudioContext();
    var source = getSharedSourceNode();
    audioAnalyser = ctx.createAnalyser();
    audioAnalyser.fftSize = 512;
    source.connect(audioAnalyser);
    audioAnalyser.connect(ctx.destination);
    analyserData = new Uint8Array(audioAnalyser.frequencyBinCount);
  } catch(e) {}
}
function drawWaveform(c, CW, CH) {
  if (!audioAnalyser || !analyserData) return;
  audioAnalyser.getByteFrequencyData(analyserData);
  const barCount = analyserData.length, barW = CW / barCount;
  const maxH = CH * state.waveform.height;
  c.save();
  for (let i = 0; i < barCount; i++) {
    const val = analyserData[i] / 255; const h = val * maxH;
    c.fillStyle = state.waveform.color; c.globalAlpha = 0.6 + val*0.4;
    if (state.waveform.position === 'top') c.fillRect(i*barW, 0, barW-1, h);
    else c.fillRect(i*barW, CH-h, barW-1, h);
  }
  c.restore();
}

// ============================================================
// PROGRESS BAR OVERLAY
// ============================================================
function drawProgressBar(c, CW, CH) {
  const totalDur = vtGetTotalDuration();
  if (!totalDur) return;
  const pct = vtTime / totalDur;
  const h = state.progressBar.height;
  const y = state.progressBar.position === 'top' ? 0 : CH - h;
  c.save();
  c.fillStyle = 'rgba(255,255,255,0.1)'; c.fillRect(0, y, CW, h);
  c.fillStyle = state.progressBar.color; c.fillRect(0, y, CW*pct, h);
  c.restore();
}

// ============================================================
// GLASSMORPHISM OVERLAY
// ============================================================
function drawGlassmorphism(c, CW, CH) {
  const g = state.glassmorphism;
  const gx = g.x >= 0 ? g.x : (CW - g.width)/2;
  const gy = g.y >= 0 ? g.y : CH*0.82;
  if (g.x < 0) { g.x = gx; g.y = gy; }
  c.save();
  rrPath(c, gx, gy, g.width, g.height, 16);
  c.fillStyle = `rgba(255,255,255,${g.opacity/100})`; c.fill();
  rrPath(c, gx, gy, g.width, g.height, 16);
  c.strokeStyle = `rgba(255,255,255,${g.borderOpacity})`; c.lineWidth = 1.5; c.stroke();
  rrPath(c, gx, gy, g.width, g.height*0.5, 16);
  c.fillStyle = `rgba(255,255,255,${g.opacity/300})`; c.fill();
  c.fillStyle = '#fff'; c.font = `600 ${Math.round(g.height*0.32)}px -apple-system, sans-serif`;
  c.textAlign = 'center'; c.textBaseline = 'middle';
  c.fillText(g.text, gx + g.width/2, gy + g.height/2);
  c.restore();
}

// ============================================================
// ANIMATION PRESETS (CapCut-style)  with real beat detection support
// ============================================================
let _lastGlitchTriggerTime = -1;

function getAnimPresetTransform(time) {
  const preset = state.animPreset;
  if (preset.type === 'none') return { zoom: 1, panX: 0, panY: 0, rotation: 0 };

  const intensity = preset.intensity;
  const t = time || 0;

  // Determine BPM: auto-detected or manual (fall back to manual if no beats for 2s)
  const useAuto = preset.autoBPM && beatDetector.timeSinceLastBeat < 2;
  const bpm = useAuto ? beatDetector.estimatedBPM : preset.bpm;
  const beatInterval = 60 / bpm;

  // Beat phase: auto uses real beat detection, manual uses fixed metronome
  let beatPhase, halfBeat;
  if (useAuto) {
    beatPhase = Math.min(1, beatDetector.timeSinceLastBeat / beatInterval);
    halfBeat = beatPhase * 2 % 1;
  } else {
    beatPhase = (t % beatInterval) / beatInterval;
    halfBeat = (t % (beatInterval/2)) / (beatInterval/2);
  }

  switch (preset.type) {
    case 'zoomBeat': {
      const zoomPulse = Math.sin(beatPhase * Math.PI) * 0.12 * intensity;
      const amp = useAuto ? Math.max(0.3, beatDetector.beatIntensity) : 1;
      return { zoom: 1 + zoomPulse * amp, panX: 0, panY: 0, rotation: 0 };
    }
    case 'velocityEdit': {
      if (useAuto) {
        const zv = Math.exp(-beatPhase * 4) * 0.08 * intensity * (beatDetector.kickBeat ? 1.5 : 1);
        const rv = Math.sin(t * 1.5) * 1.5 * intensity;
        return { zoom: 1 + zv, panX: 0, panY: 0, rotation: rv };
      }
      const cycle = (t % (beatInterval * 4)) / (beatInterval * 4);
      const slowPhase = cycle < 0.3;
      const zv = slowPhase
        ? Math.sin(cycle / 0.3 * Math.PI) * 0.08 * intensity
        : Math.sin((cycle - 0.3) / 0.7 * Math.PI * 3) * 0.04 * intensity;
      const rv = Math.sin(t * 1.5) * 1.5 * intensity;
      return { zoom: 1 + zv, panX: 0, panY: 0, rotation: rv };
    }
    case 'smoothSlide': {
      const cycle = (t % (beatInterval * 8)) / (beatInterval * 8);
      const px = Math.sin(cycle * Math.PI * 2) * 60 * intensity;
      const py = Math.cos(cycle * Math.PI * 2) * 20 * intensity;
      return { zoom: 1.02, panX: px, panY: py, rotation: 0 };
    }
    case 'bounceIn': {
      const decay = Math.exp(-beatPhase * 6);
      const bounce = Math.sin(beatPhase * Math.PI * 4) * decay;
      return { zoom: 1 + bounce * 0.15 * intensity, panX: 0, panY: bounce * -30 * intensity, rotation: 0 };
    }
    case 'glitch': {
      let isGlitchFrame;
      if (useAuto) {
        if (beatDetector.snareBeat || beatDetector.hihatBeat) _lastGlitchTriggerTime = t;
        isGlitchFrame = (t - _lastGlitchTriggerTime) < 0.06;
      } else {
        isGlitchFrame = halfBeat < 0.15;
      }
      if (isGlitchFrame) {
        const seed = Math.floor(t * 30);
        const rx = ((seed * 9301 + 49297) % 233280) / 233280 - 0.5;
        const ry = ((seed * 7841 + 23497) % 133280) / 133280 - 0.5;
        return { zoom: 1 + rx * 0.04 * intensity, panX: rx * 25 * intensity, panY: ry * 15 * intensity, rotation: rx * 2 * intensity };
      }
      return { zoom: 1, panX: 0, panY: 0, rotation: 0 };
    }
    case 'cinematicPan': {
      const longCycle = (t % 10) / 10;
      const zoom = 1 + longCycle * 0.15 * intensity;
      const px = Math.sin(longCycle * Math.PI) * 40 * intensity;
      const py = Math.cos(longCycle * Math.PI * 0.5) * 15 * intensity;
      return { zoom, panX: px, panY: py, rotation: Math.sin(longCycle * Math.PI) * 0.8 * intensity };
    }
    case 'shake': {
      const freq = 20;
      const energyScale = useAuto ? (0.3 + beatDetector.energy * 0.7) : 1;
      const px = (Math.sin(t * freq * 2.3) * 8 * intensity + Math.sin(t * freq * 3.7) * 4 * intensity) * energyScale;
      const py = (Math.cos(t * freq * 1.9) * 6 * intensity + Math.cos(t * freq * 4.1) * 3 * intensity) * energyScale;
      const rr = Math.sin(t * freq * 1.5) * 0.8 * intensity * energyScale;
      return { zoom: 1, panX: px, panY: py, rotation: rr };
    }
    case 'capcut_imported': {
      return interpolateImportedKeyframes(t);
    }
    default:
      return { zoom: 1, panX: 0, panY: 0, rotation: 0 };
  }
}

// Glitch post-processing (RGB split)  beat-reactive when autoBPM is ON
function drawGlitchEffect(c, CW, CH, time) {
  if (state.animPreset.type !== 'glitch') return;

  const useAuto = state.animPreset.autoBPM && beatDetector.timeSinceLastBeat < 2;
  let shouldGlitch;
  if (useAuto) {
    if (beatDetector.snareBeat || beatDetector.hihatBeat) _lastGlitchTriggerTime = time;
    shouldGlitch = (time - _lastGlitchTriggerTime) < 0.06;
  } else {
    const beatInterval = 60 / state.animPreset.bpm;
    const halfBeat = (time % (beatInterval/2)) / (beatInterval/2);
    shouldGlitch = halfBeat < 0.15;
  }
  if (!shouldGlitch) return;

  const intensity = state.animPreset.intensity;
  const shift = Math.round(3 + intensity * 5);
  c.save();
  c.globalCompositeOperation = 'screen';
  c.globalAlpha = 0.6;
  c.drawImage(canvas, shift, 0, CW - shift, CH, 0, 0, CW - shift, CH);
  c.globalAlpha = 0.4;
  c.drawImage(canvas, 0, 0, CW - shift, CH, shift, 0, CW - shift, CH);
  c.restore();

  c.save();
  c.globalAlpha = 0.08;
  c.fillStyle = '#000';
  for (let y = 0; y < CH; y += 4) {
    c.fillRect(0, y, CW, 2);
  }
  c.restore();
}

// ============================================================
// LUT PARSER & APPLICATOR
// ============================================================
function parseCubeLUT(text) {
  const lines = text.split('\n');
  let size = 0;
  const data = [];
  let title = '';
  for (const line of lines) {
    const trimmed = line.trim();
    if (!trimmed || trimmed.startsWith('#')) continue;
    if (trimmed.startsWith('TITLE')) { title = trimmed.replace(/^TITLE\s*"?/, '').replace(/"?\s*$/, ''); continue; }
    if (trimmed.startsWith('LUT_3D_SIZE')) { size = parseInt(trimmed.split(/\s+/)[1]); continue; }
    if (trimmed.startsWith('DOMAIN_MIN') || trimmed.startsWith('DOMAIN_MAX')) continue;
    const parts = trimmed.split(/\s+/).map(Number);
    if (parts.length >= 3 && !isNaN(parts[0])) {
      data.push(parts[0], parts[1], parts[2]);
    }
  }
  if (size === 0 || data.length < size * size * size * 3) return null;
  return { size, data: new Float32Array(data), title };
}

let lutCanvas = null, lutCtx = null;
function applyLUT(sourceCanvas, lut, intensity) {
  if (!lut || !lut.data) return;
  const fullW = sourceCanvas.width, fullH = sourceCanvas.height;
  // Downscale for performance  process at max 480p then upscale back
  const maxDim = 480;
  const scale = Math.min(1, maxDim / Math.max(fullW, fullH));
  const w = Math.round(fullW * scale), h = Math.round(fullH * scale);
  if (!lutCanvas || lutCanvas.width !== w || lutCanvas.height !== h) {
    lutCanvas = document.createElement('canvas');
    lutCanvas.width = w; lutCanvas.height = h;
    lutCtx = lutCanvas.getContext('2d', { willReadFrequently: true });
  }
  lutCtx.drawImage(sourceCanvas, 0, 0, w, h);
  const imgData = safeGetImageData(lutCtx, 0, 0, w, h);
  if (!imgData) return;
  const px = imgData.data;
  const sz = lut.size;
  const d = lut.data;
  const maxIdx = sz - 1;
  for (let i = 0; i < px.length; i += 4) {
    const r = px[i] / 255, g = px[i+1] / 255, b = px[i+2] / 255;
    const ri = r * maxIdx, gi = g * maxIdx, bi = b * maxIdx;
    const r0 = Math.floor(ri), r1 = Math.min(r0 + 1, maxIdx);
    const g0 = Math.floor(gi), g1 = Math.min(g0 + 1, maxIdx);
    const b0 = Math.floor(bi), b1 = Math.min(b0 + 1, maxIdx);
    const rf = ri - r0, gf = gi - g0, bf = bi - b0;
    const idx = (bv, gv, rv) => (bv * sz * sz + gv * sz + rv) * 3;
    const c000 = idx(b0, g0, r0), c100 = idx(b0, g0, r1);
    const c010 = idx(b0, g1, r0), c110 = idx(b0, g1, r1);
    const c001 = idx(b1, g0, r0), c101 = idx(b1, g0, r1);
    const c011 = idx(b1, g1, r0), c111 = idx(b1, g1, r1);
    for (let ch = 0; ch < 3; ch++) {
      const v000 = d[c000+ch], v100 = d[c100+ch], v010 = d[c010+ch], v110 = d[c110+ch];
      const v001 = d[c001+ch], v101 = d[c101+ch], v011 = d[c011+ch], v111 = d[c111+ch];
      const c00 = v000 + (v100 - v000) * rf;
      const c10 = v010 + (v110 - v010) * rf;
      const c01 = v001 + (v101 - v001) * rf;
      const c11 = v011 + (v111 - v011) * rf;
      const c0 = c00 + (c10 - c00) * gf;
      const c1 = c01 + (c11 - c01) * gf;
      const lutVal = (c0 + (c1 - c0) * bf) * 255;
      const orig = px[i + ch];
      px[i + ch] = Math.round(orig + (lutVal - orig) * intensity);
    }
  }
  lutCtx.putImageData(imgData, 0, 0);
  const srcCtx = sourceCanvas.getContext('2d');
  srcCtx.drawImage(lutCanvas, 0, 0, fullW, fullH);
}

// ============================================================
// VIDEO OVERLAY COMPOSITING
// ============================================================
function drawVideoOverlays(ctx, CW, CH) {
  for (const ov of state.videoOverlays) {
    if (ov.hidden) continue;
    // Built-in overlays (canvas-generated)
    if (ov.builtin) {
      drawBuiltinOverlay(ctx, CW, CH, ov);
      continue;
    }
    if (!ov.video || ov.video.readyState < 2) continue;
    ctx.save();
    ctx.globalAlpha = ov.opacity;
    ctx.globalCompositeOperation = ov.blendMode;
    const vw = ov.video.videoWidth, vh = ov.video.videoHeight;
    const vRatio = vw / vh, cRatio = CW / CH;
    let dw, dh, dx, dy;
    if (vRatio > cRatio) { dh = CH; dw = CH * vRatio; dx = (CW - dw) / 2; dy = 0; }
    else { dw = CW; dh = CW / vRatio; dx = 0; dy = (CH - dh) / 2; }
    safeDrawImage(ctx, ov.video, dx, dy, dw, dh);
    ctx.restore();
  }
}

function drawBuiltinOverlay(ctx, CW, CH, ov) {
  const t = performance.now() * 0.001;
  ctx.save();
  ctx.globalAlpha = ov.opacity;

  if (ov.builtin === 'filmGrain') {
    ctx.globalCompositeOperation = 'overlay';
    const imgData = safeGetImageData(ctx, 0, 0, Math.min(CW, 640), Math.min(CH, 640));
    if (!imgData) { ctx.restore(); return; }
    // Only process a sampled region for performance
    const grainCanvas = ov._cache || document.createElement('canvas');
    if (!ov._cache) { ov._cache = grainCanvas; grainCanvas.width = 320; grainCanvas.height = 320; }
    const gc = grainCanvas.getContext('2d');
    const gd = gc.createImageData(320, 320);
    const px = gd.data;
    for (let i = 0; i < px.length; i += 4) {
      const v = Math.random() * 255;
      px[i] = px[i+1] = px[i+2] = v; px[i+3] = 40;
    }
    gc.putImageData(gd, 0, 0);
    ctx.drawImage(grainCanvas, 0, 0, CW, CH);

  } else if (ov.builtin === 'lightLeak') {
    ctx.globalCompositeOperation = 'screen';
    const g = ctx.createRadialGradient(
      CW * (0.3 + 0.4 * Math.sin(t * 0.5)), CH * (0.3 + 0.2 * Math.cos(t * 0.3)),
      0,
      CW * 0.5, CH * 0.5, CW * 0.7
    );
    const hue = (t * 20) % 360;
    g.addColorStop(0, `hsla(${hue}, 80%, 60%, 0.4)`);
    g.addColorStop(0.4, `hsla(${(hue + 40) % 360}, 70%, 50%, 0.15)`);
    g.addColorStop(1, 'transparent');
    ctx.fillStyle = g;
    ctx.fillRect(0, 0, CW, CH);
    // Second leak
    const g2 = ctx.createRadialGradient(
      CW * (0.7 + 0.2 * Math.cos(t * 0.4)), CH * (0.6 + 0.3 * Math.sin(t * 0.6)),
      0,
      CW * 0.6, CH * 0.4, CW * 0.5
    );
    g2.addColorStop(0, `hsla(${(hue + 180) % 360}, 70%, 55%, 0.25)`);
    g2.addColorStop(1, 'transparent');
    ctx.fillStyle = g2;
    ctx.fillRect(0, 0, CW, CH);

  } else if (ov.builtin === 'bokehLights') {
    ctx.globalCompositeOperation = 'screen';
    if (!ov._bokeh || ov._bokeh.length === 0) {
      ov._bokeh = [];
      for (let i = 0; i < 20; i++) {
        ov._bokeh.push({
          x: Math.random(), y: Math.random(),
          r: 0.02 + Math.random() * 0.06,
          speed: 0.1 + Math.random() * 0.3,
          hue: Math.random() * 360,
          phase: Math.random() * Math.PI * 2
        });
      }
    }
    for (const b of ov._bokeh) {
      const bx = CW * ((b.x + Math.sin(t * b.speed + b.phase) * 0.05) % 1);
      const by = CH * ((b.y + t * b.speed * 0.02) % 1);
      const br = Math.min(CW, CH) * b.r;
      const alpha = 0.15 + 0.1 * Math.sin(t * b.speed * 2 + b.phase);
      const g = ctx.createRadialGradient(bx, by, 0, bx, by, br);
      g.addColorStop(0, `hsla(${b.hue}, 60%, 70%, ${alpha})`);
      g.addColorStop(0.7, `hsla(${b.hue}, 60%, 70%, ${alpha * 0.3})`);
      g.addColorStop(1, 'transparent');
      ctx.fillStyle = g;
      ctx.fillRect(bx - br, by - br, br * 2, br * 2);
    }

  } else if (ov.builtin === 'dust') {
    ctx.globalCompositeOperation = 'screen';
    if (!ov._dust || ov._dust.length === 0) {
      ov._dust = [];
      for (let i = 0; i < 60; i++) {
        ov._dust.push({
          x: Math.random(), y: Math.random(),
          size: 1 + Math.random() * 3,
          speed: 0.01 + Math.random() * 0.03,
          drift: (Math.random() - 0.5) * 0.02,
          alpha: 0.3 + Math.random() * 0.5
        });
      }
    }
    ctx.fillStyle = '#fff';
    for (const d of ov._dust) {
      const dx = CW * ((d.x + d.drift * t) % 1);
      const dy = CH * ((d.y - d.speed * t * 0.5) % 1 + 1) % CH;
      ctx.globalAlpha = ov.opacity * d.alpha * (0.5 + 0.5 * Math.sin(t * 2 + d.x * 10));
      ctx.beginPath();
      ctx.arc(dx, dy, d.size, 0, Math.PI * 2);
      ctx.fill();
    }

  } else if (ov.builtin === 'vignette') {
    ctx.globalCompositeOperation = 'multiply';
    const g = ctx.createRadialGradient(CW/2, CH/2, CW * 0.25, CW/2, CH/2, CW * 0.75);
    g.addColorStop(0, 'rgba(255,255,255,1)');
    g.addColorStop(1, 'rgba(0,0,0,1)');
    ctx.fillStyle = g;
    ctx.fillRect(0, 0, CW, CH);

  } else if (ov.builtin === 'chromatic') {
    ctx.globalCompositeOperation = 'screen';
    const shift = 3 + 2 * Math.sin(t);
    ctx.globalAlpha = 0.15 * ov.opacity;
    ctx.drawImage(ctx.canvas, shift, 0, CW - shift, CH, 0, 0, CW - shift, CH);
    ctx.globalAlpha = 0.1 * ov.opacity;
    ctx.drawImage(ctx.canvas, 0, 0, CW - shift, CH, shift, 0, CW - shift, CH);

  } else if (ov.builtin === 'scanlines') {
    ctx.globalCompositeOperation = 'multiply';
    ctx.fillStyle = 'rgba(0,0,0,1)';
    for (let y = 0; y < CH; y += 4) {
      ctx.globalAlpha = 0.08 * ov.opacity;
      ctx.fillRect(0, y, CW, 2);
    }

  } else if (ov.builtin === 'filmBurn') {
    ctx.globalCompositeOperation = 'screen';
    const phase = t * 0.3;
    const g = ctx.createLinearGradient(
      CW * (0.5 + 0.5 * Math.sin(phase)), 0,
      CW * (0.5 + 0.5 * Math.cos(phase + 1)), CH
    );
    g.addColorStop(0, `hsla(30, 90%, 50%, ${0.15 + 0.1 * Math.sin(t)})`);
    g.addColorStop(0.3, `hsla(15, 80%, 40%, ${0.08 + 0.05 * Math.cos(t * 1.3)})`);
    g.addColorStop(0.6, 'transparent');
    g.addColorStop(1, `hsla(350, 70%, 30%, ${0.05 + 0.03 * Math.sin(t * 0.7)})`);
    ctx.fillStyle = g;
    ctx.fillRect(0, 0, CW, CH);
  }

  ctx.restore();
}

// CapCut draft importer
let importedKeyframes = [];

function parseCapcutDraft(json) {
  try {
    const draft = typeof json === 'string' ? JSON.parse(json) : json;
    const keyframes = [];

    // CapCut stores tracks > segments > common_keyframes
    const tracks = draft.tracks || draft.materials?.tracks || [];
    for (const track of tracks) {
      const segments = track.segments || track.segment_list || [];
      for (const seg of segments) {
        const kfGroups = seg.common_keyframes || seg.keyframes || [];
        for (const kfGroup of kfGroups) {
          const propType = kfGroup.property_type || kfGroup.type || '';
          const kfList = kfGroup.keyframe_list || kfGroup.keyframes || [];
          for (const kf of kfList) {
            const time = (kf.time_offset || kf.time || 0) / 1000000; // microseconds to seconds
            const values = kf.values || [0];
            keyframes.push({ time, property: propType, value: values[0], curve: kf.curveType || 'Linear' });
          }
        }

        // Also extract transform data
        const clip = seg.clip || {};
        const transform = clip.transform || {};
        if (transform.scale_x !== undefined) {
          const startTime = (seg.target_timerange?.start || 0) / 1000000;
          keyframes.push({ time: startTime, property: 'scale', value: transform.scale_x, curve: 'Linear' });
        }
        if (transform.rotation !== undefined) {
          const startTime = (seg.target_timerange?.start || 0) / 1000000;
          keyframes.push({ time: startTime, property: 'rotation', value: transform.rotation, curve: 'Linear' });
        }
        if (transform.position_x !== undefined) {
          const startTime = (seg.target_timerange?.start || 0) / 1000000;
          keyframes.push({ time: startTime, property: 'positionX', value: transform.position_x, curve: 'Linear' });
        }

        // Speed data for velocity edits
        if (clip.speed !== undefined && clip.speed !== 1) {
          const startTime = (seg.target_timerange?.start || 0) / 1000000;
          keyframes.push({ time: startTime, property: 'speed', value: clip.speed, curve: 'Linear' });
        }
      }
    }

    keyframes.sort((a, b) => a.time - b.time);
    return keyframes;
  } catch (e) {
    console.error('CapCut parse error:', e);
    return [];
  }
}

function interpolateImportedKeyframes(time) {
  if (importedKeyframes.length === 0) return { zoom: 1, panX: 0, panY: 0, rotation: 0 };

  let zoom = 1, panX = 0, panY = 0, rotation = 0;

  // Group by property
  const byProp = {};
  for (const kf of importedKeyframes) {
    if (!byProp[kf.property]) byProp[kf.property] = [];
    byProp[kf.property].push(kf);
  }

  function lerp(kfs, t) {
    if (kfs.length === 0) return 0;
    if (kfs.length === 1) return kfs[0].value;
    if (t <= kfs[0].time) return kfs[0].value;
    if (t >= kfs[kfs.length - 1].time) return kfs[kfs.length - 1].value;
    for (let i = 0; i < kfs.length - 1; i++) {
      if (t >= kfs[i].time && t <= kfs[i + 1].time) {
        const p = (t - kfs[i].time) / (kfs[i + 1].time - kfs[i].time);
        return kfs[i].value + (kfs[i + 1].value - kfs[i].value) * p;
      }
    }
    return kfs[kfs.length - 1].value;
  }

  if (byProp['scale'] || byProp['KFTypePositionScale']) {
    zoom = lerp(byProp['scale'] || byProp['KFTypePositionScale'], time);
    if (zoom > 0) zoom = zoom; else zoom = 1;
  }
  if (byProp['positionX'] || byProp['KFTypePositionX']) {
    panX = lerp(byProp['positionX'] || byProp['KFTypePositionX'], time) * state.animPreset.intensity;
  }
  if (byProp['positionY'] || byProp['KFTypePositionY']) {
    panY = lerp(byProp['positionY'] || byProp['KFTypePositionY'], time) * state.animPreset.intensity;
  }
  if (byProp['rotation'] || byProp['KFTypeRotation']) {
    rotation = lerp(byProp['rotation'] || byProp['KFTypeRotation'], time);
  }

  return { zoom, panX, panY, rotation };
}

// ============================================================
// CHROMA KEY (BACKGROUND REMOVER)
// ============================================================
let chromaCanvas = null, chromaCtx = null;

function getChromaKeyFrame(srcVideo) {
  if (!state.chromaKey.enabled || !srcVideo || srcVideo.readyState < 2) return null;

  const maxW = 640; // limit processing size for performance
  const vw = srcVideo.videoWidth, vh = srcVideo.videoHeight;
  const w = Math.min(vw, maxW);
  const h = Math.round(w * vh / vw);

  if (!chromaCanvas || chromaCanvas.width !== w || chromaCanvas.height !== h) {
    chromaCanvas = document.createElement('canvas');
    chromaCanvas.width = w;
    chromaCanvas.height = h;
    chromaCtx = chromaCanvas.getContext('2d', { willReadFrequently: true });
  }

  safeDrawImage(chromaCtx, srcVideo, 0, 0, w, h);
  const imageData = safeGetImageData(chromaCtx, 0, 0, w, h);
  if (!imageData) return null;
  const data = imageData.data;

  const ck = state.chromaKey;
  const r0 = parseInt(ck.color.substr(1,2), 16);
  const g0 = parseInt(ck.color.substr(3,2), 16);
  const b0 = parseInt(ck.color.substr(5,2), 16);
  const tol = ck.tolerance;
  const soft = ck.softness;

  for (let i = 0; i < data.length; i += 4) {
    const dr = data[i] - r0;
    const dg = data[i+1] - g0;
    const db = data[i+2] - b0;
    const dist = Math.sqrt(dr*dr + dg*dg + db*db);

    if (dist < tol) {
      data[i+3] = 0; // fully transparent
    } else if (dist < tol + soft) {
      data[i+3] = Math.round(255 * (dist - tol) / soft);
    }
  }

  chromaCtx.putImageData(imageData, 0, 0);
  return chromaCanvas;
}

// ============================================================
// SCENE TEMPLATES
// ============================================================
// ============================================================
// FULL PRESET TEMPLATES
// ============================================================
const FULL_PRESETS = {
  appShowcase: {
    device: { type: 'iphone16', color: 'black' },
    preset: 'reels', scale: 0.45,
    bg: { type: 'gradient', color: '#0a0a0a', gradient: { enabled:true, color1:'#000000', color2:'#1a1a2e', color3:'#000000', angle:90, animated:false, speed:0 } },
    shadow: 0.8, lut: 'cinematic', overlays: ['vignette'],
    entrance: { type: 'scaleIn', duration: 1000 }, animPreset: 'none',
    particles: { enabled:true, type:'bokeh', count:10, color:'#fbbf24', speed:0.15 },
    orbit: { enabled:true, speed:0.1, range:4 },
    text: [{ content: 'Your App Name', fontSize: 44, color: '#ffffff', weight: '700', yPct: 0.07 }],
  },
  tiktokViral: {
    device: { type: 'iphone16', color: 'pink' },
    preset: 'reels', scale: 0.45,
    bg: { type: 'gradient', color: '#0a0a0a', gradient: { enabled:true, color1:'#f97316', color2:'#db2777', color3:'#7c3aed', angle:160, animated:true, speed:0.3 } },
    shadow: 0.5, lut: 'warmVintage', overlays: ['filmGrain'],
    entrance: { type: 'slideUp', duration: 800 }, animPreset: 'zoomBeat',
    particles: { enabled:true, type:'bokeh', count:15, color:'#fbbf24', speed:0.2 },
    orbit: { enabled:false },
    text: [{ content: 'Watch This', fontSize: 52, color: '#ffffff', weight: '900', yPct: 0.06 }],
  },
  cleanProduct: {
    device: { type: 'iphone16', color: 'white' },
    preset: 'reels', scale: 0.42,
    bg: { type: 'solid', color: '#f5f5f5', gradient: { enabled:false } },
    shadow: 0.3, lut: null, overlays: [],
    entrance: { type: 'fadeIn', duration: 800 }, animPreset: 'none',
    particles: { enabled:false }, orbit: { enabled:false },
    text: [],
  },
  darkCinematic: {
    device: { type: 'iphone16', color: 'black' },
    preset: 'reels', scale: 0.45,
    bg: { type: 'gradient', color: '#0a0a0a', gradient: { enabled:true, color1:'#000000', color2:'#0f0f1a', color3:'#000000', angle:180, animated:false, speed:0 } },
    shadow: 1.0, lut: 'moody', overlays: ['filmBurn', 'vignette'],
    entrance: { type: 'fadeIn', duration: 1500 }, animPreset: 'cinematicPan',
    particles: { enabled:false }, orbit: { enabled:true, speed:0.08, range:3 },
    text: [],
  },
  neonPop: {
    device: { type: 'iphone16', color: 'blue' },
    preset: 'reels', scale: 0.45,
    bg: { type: 'gradient', color: '#0a0a0a', gradient: { enabled:true, color1:'#0a0015', color2:'#1a0030', color3:'#0a0015', angle:180, animated:true, speed:0.8 } },
    shadow: 1.0, lut: 'coolTeal', overlays: ['chromatic'],
    entrance: { type: 'scaleIn', duration: 600 }, animPreset: 'none',
    particles: { enabled:true, type:'sparkle', count:20, color:'#c084fc', speed:0.4 },
    orbit: { enabled:false },
    text: [],
  },
  cleanSocial: {
    device: { type: 'none', color: 'default' },
    preset: 'reels', scale: 0.45,
    bg: { type: 'solid', color: '#0a0a0a', gradient: { enabled:false } },
    shadow: 0, lut: 'orangeTeal', overlays: ['vignette'],
    entrance: { type: 'none', duration: 1000 }, animPreset: 'none',
    particles: { enabled:false }, orbit: { enabled:false },
    text: [],
  },
  retroFilm: {
    device: { type: 'iphone16', color: 'titanium' },
    preset: 'reels', scale: 0.45,
    bg: { type: 'gradient', color: '#0a0a0a', gradient: { enabled:true, color1:'#1a1008', color2:'#2a1a10', color3:'#1a1008', angle:135, animated:false, speed:0 } },
    shadow: 0.6, lut: 'warmVintage', overlays: ['filmGrain', 'scanlines', 'vignette'],
    entrance: { type: 'fadeIn', duration: 1200 }, animPreset: 'none',
    particles: { enabled:true, type:'bokeh', count:8, color:'#fbbf2440', speed:0.1 },
    orbit: { enabled:false },
    text: [],
  },
  laptopReview: {
    device: { type: 'macbookpro', color: 'spaceblack' },
    preset: 'youtube', scale: 0.55,
    bg: { type: 'gradient', color: '#0a0a0a', gradient: { enabled:true, color1:'#0c4a6e', color2:'#155e75', color3:'#164e63', angle:180, animated:true, speed:0.4 } },
    shadow: 0.6, lut: 'cinematic', overlays: ['vignette'],
    entrance: { type: 'scaleIn', duration: 1000 }, animPreset: 'none',
    particles: { enabled:true, type:'bokeh', count:12, color:'#22d3ee', speed:0.2 },
    orbit: { enabled:true, speed:0.1, range:5 },
    text: [],
  },
  rawVideo: {
    device: { type: 'none', color: 'default' },
    preset: 'reels', scale: 0.45,
    bg: { type: 'solid', color: '#000000', gradient: { enabled:false } },
    shadow: 0, lut: null, overlays: [],
    entrance: { type: 'none', duration: 1000 }, animPreset: 'none',
    particles: { enabled:false }, orbit: { enabled:false },
    text: [],
  },
  ipadPresent: {
    device: { type: 'ipadpro', color: 'spaceblack' },
    preset: 'reels', scale: 0.50,
    bg: { type: 'solid', color: '#f5f5f5', gradient: { enabled:false } },
    shadow: 0.4, lut: null, overlays: [],
    entrance: { type: 'fadeIn', duration: 800 }, animPreset: 'none',
    particles: { enabled:false }, orbit: { enabled:false },
    text: [],
  },
};

// ============================================================
// DEVICE POSITION PRESETS
// ============================================================
const DEVICE_PRESETS = {
  phoneLeft: {
    name: 'Phone Left',
    device: { x: -180, y: 0, scale: 0.45, landscape: false },
    perspective: { x: 3, y: -2 },
  },
  phoneRight: {
    name: 'Phone Right',
    device: { x: 180, y: 0, scale: 0.45, landscape: false },
    perspective: { x: -3, y: -2 },
  },
  phoneCenterZoom: {
    name: 'Center Zoom',
    device: { x: 0, y: 0, scale: 0.6, landscape: false },
    perspective: { x: 0, y: 0 },
  },
  dualComparison: {
    name: 'Dual Comparison',
    device: { x: -100, y: 0, scale: 0.38, landscape: false },
    perspective: { x: 2, y: 0 },
    comparison: { enabled: true, x: 100, y: 0 },
  },
  tilt3D: {
    name: '3D Tilt Showcase',
    device: { x: 0, y: -20, scale: 0.48, landscape: false },
    perspective: { x: 8, y: -5 },
    shadow: 0.9,
  },
  landscapeView: {
    name: 'Landscape Mode',
    device: { x: 0, y: 0, scale: 0.55, landscape: true },
    perspective: { x: 0, y: -2 },
  },
  floatingAbove: {
    name: 'Floating Above',
    device: { x: 0, y: -60, scale: 0.42, landscape: false },
    perspective: { x: 0, y: -6 },
    shadow: 1.0,
  },
  bottomCorner: {
    name: 'Bottom Corner',
    device: { x: 120, y: 80, scale: 0.35, landscape: false },
    perspective: { x: -4, y: 2 },
  },
  laptopDesk: {
    name: 'Laptop Desk View',
    device: { x: 0, y: 20, scale: 0.58, landscape: false },
    perspective: { x: 0, y: -8 },
    shadow: 0.7,
  },
  tabletPresenter: {
    name: 'Tablet Presenter',
    device: { x: 0, y: -10, scale: 0.52, landscape: false },
    perspective: { x: 0, y: -4 },
    shadow: 0.6,
  },
};

function applyFullPreset(key) {
  const fp = FULL_PRESETS[key];
  if (!fp) return;

  // --- Reset everything first ---
  // Reset render stack to default order
  state.renderStack = [
    { id: 'bgVideo', name: 'BG Video', icon: '' },
    { id: 'particles', name: 'Particles', icon: '' },
    { id: 'device', name: 'Device', icon: '' },
    { id: 'device2', name: 'Device 2', icon: '' },
    { id: 'content', name: 'Content', icon: 'T' },
    { id: 'facecam', name: 'Facecam', icon: '' },
    { id: 'videoOverlays', name: 'Overlays', icon: '' },
    { id: 'uiOverlays', name: 'UI Effects', icon: '' },
  ];
  // Clear layers (text only - keep user's logos/annotations)
  state.layers = state.layers.filter(l => l.type !== 'text');
  // Clear video overlays (built-in only)
  state.videoOverlays = state.videoOverlays.filter(ov => !ov.builtin);
  document.querySelectorAll('#builtinOverlayGrid .dev-btn').forEach(b => b.classList.remove('active'));
  // Reset LUT
  state.lut = { enabled: false, data: null, size: 0, intensity: 1.0, name: '' };

  // --- Apply device ---
  state.device.type = fp.device.type;
  state.device.color = fp.device.color;
  state.device.scale = fp.scale;
  frameCache = {};
  // Update device grid UI
  document.querySelectorAll('#deviceGrid .dev-btn').forEach(b => {
    b.classList.toggle('active', b.dataset.device === fp.device.type);
  });
  updateColorSwatches();

  // --- Apply export preset ---
  state.preset = fp.preset;
  document.getElementById('presetSelect').value = fp.preset;
  document.getElementById('customSizeWrap').style.display = fp.preset === 'custom' ? '' : 'none';

  // --- Apply background ---
  state.bgType = fp.bg.type;
  state.background.color = fp.bg.color;
  document.getElementById('bgType').value = fp.bg.type;
  document.getElementById('bgColor').value = fp.bg.color;
  document.getElementById('bgSolidControls').style.display = fp.bg.type === 'solid' ? 'block' : 'none';
  document.getElementById('bgGradientControls').style.display = fp.bg.type === 'gradient' ? 'block' : 'none';
  canvasWrap.classList.remove('checker-bg');

  if (fp.bg.gradient) {
    Object.assign(state.gradient, fp.bg.gradient);
    if (fp.bg.gradient.color1) document.getElementById('gradColor1').value = fp.bg.gradient.color1;
    if (fp.bg.gradient.color2) document.getElementById('gradColor2').value = fp.bg.gradient.color2;
    if (fp.bg.gradient.color3) document.getElementById('gradColor3').value = fp.bg.gradient.color3;
  }

  // --- Apply shadow ---
  state.shadow = fp.shadow;
  document.getElementById('shadowSlider').value = Math.round(fp.shadow * 100);

  // --- Apply scale + transform ---
  state.device.scale = fp.scale;
  document.getElementById('scaleSlider').value = Math.round(fp.scale * 100);
  document.getElementById('scaleVal').textContent = Math.round(fp.scale * 100) + '%';
  state.perspective = { x: 0, y: 0 };
  document.getElementById('tiltX').value = 0;
  document.getElementById('tiltY').value = 0;

  // --- Apply LUT ---
  if (fp.lut) {
    const lutData = generateLUTPreset(fp.lut);
    state.lut = { enabled: true, data: lutData, size: lutData.size, intensity: 1.0, name: fp.lut };
    document.getElementById('lutInfo').innerHTML = '<span style="color:#4ade80">Active:</span> ' + fp.lut;
    document.getElementById('lutControls').style.display = 'block';
    document.querySelectorAll('#lutPresetGrid .dev-btn').forEach(b => {
      b.classList.toggle('active', b.dataset.lutPreset === fp.lut);
    });
  } else {
    document.getElementById('lutInfo').textContent = '';
    document.getElementById('lutControls').style.display = 'none';
    document.querySelectorAll('#lutPresetGrid .dev-btn').forEach(b => b.classList.remove('active'));
  }

  // --- Apply built-in overlays ---
  for (const ovType of (fp.overlays || [])) {
    const existing = state.videoOverlays.find(ov => ov.builtin === ovType);
    if (!existing) {
      state.videoOverlays.push({ id: Date.now() + Math.random(), builtin: ovType, name: ovType, opacity: 0.5, blendMode: 'screen' });
    }
    const btn = document.querySelector(`#builtinOverlayGrid .dev-btn[data-builtin="${ovType}"]`);
    if (btn) btn.classList.add('active');
  }
  rebuildOverlayList();

  // --- Apply entrance ---
  state.entrance = { type: fp.entrance.type, duration: fp.entrance.duration };
  document.getElementById('entranceSelect').value = fp.entrance.type;
  document.getElementById('entranceDur').value = fp.entrance.duration;
  document.getElementById('entranceDurVal').textContent = (fp.entrance.duration / 1000).toFixed(1) + 's';

  // --- Apply animation preset ---
  state.animPreset.type = fp.animPreset;
  document.querySelectorAll('#animPresetGrid .dev-btn').forEach(b => {
    b.classList.toggle('active', b.dataset.anim === fp.animPreset);
  });

  // --- Apply particles ---
  if (fp.particles) {
    Object.assign(state.particles, fp.particles);
    document.getElementById('particleType').value = fp.particles.enabled ? fp.particles.type : 'off';
    state._particles = [];
  }

  // --- Apply orbit ---
  if (fp.orbit) {
    Object.assign(state.orbit, fp.orbit);
    document.getElementById('orbitToggle').value = String(fp.orbit.enabled);
  }

  // --- Add text placeholders ---
  const sz = getCanvasSize();
  for (const t of (fp.text || [])) {
    state.layers.push({
      id: state.nextLayerId++, type: 'text',
      content: t.content, x: sz.w / 2, y: sz.h * (t.yPct || 0.08),
      fontSize: t.fontSize, fontFamily: t.fontFamily || 'SF Pro Display, -apple-system, sans-serif',
      color: t.color, weight: t.weight, align: 'center',
      shadow: 0, outline: 0,
    });
  }

  // --- Update UI state ---
  resizeCanvas();
  updatePerspective();
  updateDisplaySize();

  // Update full preset grid
  document.querySelectorAll('#fullPresetGrid .preset-card').forEach(b => {
    b.classList.toggle('active', b.dataset.fp === key);
  });

  // Reset scene grid (full presets supersede scene templates)
  document.querySelectorAll('#sceneGrid .dev-btn').forEach(b => b.classList.remove('active'));
  document.querySelector('#sceneGrid .dev-btn[data-scene="custom"]').classList.add('active');
}

const SCENES = {
  custom: null,
  floating: {
    gradient: { enabled:true, color1:'#0f0c29', color2:'#302b63', color3:'#24243e', angle:135, animated:true, speed:0.5 },
    particles: { enabled:true, type:'bokeh', count:25, color:'#8b5cf6', speed:0.3 },
    shadow:0.8, orbit:{ enabled:true, speed:0.2, range:8 },
  },
  neon: {
    gradient: { enabled:true, color1:'#0a0015', color2:'#1a0030', color3:'#0a0015', angle:180, animated:true, speed:0.8 },
    particles: { enabled:true, type:'sparkle', count:20, color:'#c084fc', speed:0.4 },
    shadow:1.0, orbit:{ enabled:false },
  },
  sunset: {
    gradient: { enabled:true, color1:'#f97316', color2:'#db2777', color3:'#7c3aed', angle:160, animated:true, speed:0.3 },
    particles: { enabled:true, type:'bokeh', count:15, color:'#fbbf24', speed:0.2 },
    shadow:0.5, orbit:{ enabled:false },
  },
  minimal: { gradient:{ enabled:false }, bg:'#f5f5f5', particles:{ enabled:false }, shadow:0.3, orbit:{ enabled:false } },
  ocean: {
    gradient: { enabled:true, color1:'#0c4a6e', color2:'#155e75', color3:'#164e63', angle:180, animated:true, speed:0.4 },
    particles: { enabled:true, type:'bokeh', count:20, color:'#22d3ee', speed:0.3 },
    shadow:0.6, orbit:{ enabled:true, speed:0.15, range:5 },
  },
  forest: {
    gradient: { enabled:true, color1:'#052e16', color2:'#14532d', color3:'#1a2e05', angle:170, animated:true, speed:0.3 },
    particles: { enabled:true, type:'snow', count:15, color:'#86efac', speed:0.2 },
    shadow:0.5, orbit:{ enabled:false },
  },
  cinematic: {
    gradient: { enabled:true, color1:'#000000', color2:'#1a1a2e', color3:'#000000', angle:90, animated:false, speed:0 },
    particles: { enabled:true, type:'bokeh', count:10, color:'#fbbf24', speed:0.15 },
    shadow:1.0, orbit:{ enabled:true, speed:0.1, range:4 }, motionBlur:true,
  },
};
function applyScene(name) {
  state.scene = name;
  const scene = SCENES[name];
  if (!scene) return;
  // Always remove transparent mode when applying a scene
  canvasWrap.classList.remove('checker-bg');
  if (scene.gradient) {
    Object.assign(state.gradient, scene.gradient);
    state.bgType = scene.gradient.enabled ? 'gradient' : 'solid';
    document.getElementById('bgType').value = state.bgType;
    document.getElementById('bgSolidControls').style.display = scene.gradient.enabled ? 'none' : 'block';
    document.getElementById('bgGradientControls').style.display = scene.gradient.enabled ? 'block' : 'none';
    if (scene.gradient.enabled) {
      document.getElementById('gradColor1').value = scene.gradient.color1;
      document.getElementById('gradColor2').value = scene.gradient.color2;
      document.getElementById('gradColor3').value = scene.gradient.color3;
    }
  }
  if (scene.bg) { state.background.color = scene.bg; document.getElementById('bgColor').value = scene.bg; }
  if (scene.particles) {
    Object.assign(state.particles, scene.particles);
    document.getElementById('particleType').value = scene.particles.enabled ? scene.particles.type : 'off';
    state._particles = [];
  }
  if (scene.shadow !== undefined) { state.shadow = scene.shadow; document.getElementById('shadowSlider').value = scene.shadow*100; }
  if (scene.orbit) { Object.assign(state.orbit, scene.orbit); document.getElementById('orbitToggle').value = String(scene.orbit.enabled); }
  if (scene.motionBlur !== undefined) { state.motionBlur.enabled = scene.motionBlur; document.getElementById('motionBlurToggle').value = String(scene.motionBlur); }
}

function applyDevicePreset(key) {
  const preset = DEVICE_PRESETS[key];
  if (!preset) return;

  pushUndoState();

  // Apply device position and scale
  if (preset.device) {
    if (preset.device.x !== undefined) state.device.x = preset.device.x;
    if (preset.device.y !== undefined) state.device.y = preset.device.y;
    if (preset.device.scale !== undefined) state.device.scale = preset.device.scale;
    if (preset.device.landscape !== undefined) state.device.landscape = preset.device.landscape;
  }

  // Apply perspective
  if (preset.perspective) {
    state.perspective.x = preset.perspective.x;
    state.perspective.y = preset.perspective.y;
    updatePerspective();
  }

  // Apply shadow
  if (preset.shadow !== undefined) {
    state.shadow = preset.shadow;
    document.getElementById('shadowSlider').value = preset.shadow * 100;
  }

  // Apply comparison mode
  if (preset.comparison) {
    state.comparison.enabled = true;
    if (preset.comparison.x !== undefined) state.comparison.x = preset.comparison.x;
    if (preset.comparison.y !== undefined) state.comparison.y = preset.comparison.y;
  }

  // Update UI and render
  frameCache = {};
  resizeCanvas();
  updateDisplaySize();
  scheduleSave();

  showToast(`Device preset: ${preset.name}`, 'info');
}

// ============================================================
// ENTRANCE ANIMATION
// ============================================================
function getEntranceTransform(elapsed) {
  const e = state.entrance;
  if (e.type === 'none') return { opacity: 1, x: 0, y: 0, scale: 1, rotate: 0 };
  const t = Math.min(1, elapsed / e.duration);
  const ease = t < 0.5 ? 2*t*t : 1 - Math.pow(-2*t + 2, 2)/2; // ease in-out quad

  switch (e.type) {
    case 'fadeIn':
      return { opacity: ease, x: 0, y: 0, scale: 1, rotate: 0 };
    case 'slideUp':
      return { opacity: ease, x: 0, y: (1 - ease) * 300, scale: 1, rotate: 0 };
    case 'scaleIn':
      return { opacity: ease, x: 0, y: 0, scale: 0.3 + ease * 0.7, rotate: 0 };
    case 'rotateIn':
      return { opacity: ease, x: 0, y: 0, scale: 0.5 + ease * 0.5, rotate: (1 - ease) * -15 };
    default:
      return { opacity: 1, x: 0, y: 0, scale: 1, rotate: 0 };
  }
}

// ============================================================
// KEYFRAME INTERPOLATION
// ============================================================
function getKeyframeValues(time) {
  const kfs = state.timeline.keyframes;
  if (kfs.length === 0) return { zoom: 1, panX: 0, panY: 0 };
  if (kfs.length === 1) return { zoom: kfs[0].zoom, panX: kfs[0].panX, panY: kfs[0].panY };

  // Find surrounding keyframes
  let before = kfs[0], after = kfs[kfs.length - 1];
  for (let i = 0; i < kfs.length - 1; i++) {
    if (time >= kfs[i].time && time <= kfs[i+1].time) {
      before = kfs[i];
      after = kfs[i+1];
      break;
    }
  }
  if (time <= before.time) return { zoom: before.zoom, panX: before.panX, panY: before.panY };
  if (time >= after.time) return { zoom: after.zoom, panX: after.panX, panY: after.panY };

  const t = (time - before.time) / (after.time - before.time);
  const ease = t < 0.5 ? 2*t*t : 1 - Math.pow(-2*t+2, 2)/2;
  return {
    zoom: before.zoom + (after.zoom - before.zoom) * ease,
    panX: before.panX + (after.panX - before.panX) * ease,
    panY: before.panY + (after.panY - before.panY) * ease,
  };
}

// ============================================================
// DEVICE KEYFRAME INTERPOLATION
// ============================================================
function getDeviceKeyframeValues(time) {
  const keyframes = state.deviceKeyframes || [];
  if (keyframes.length === 0) {
    return {
      x: state.device.x,
      y: state.device.y,
      scale: state.device.scale,
      rotation: 0,
      perspectiveX: state.perspective.x,
      perspectiveY: state.perspective.y
    };
  }

  // Find surrounding keyframes
  let prev = null, next = null;
  for (let i = 0; i < keyframes.length; i++) {
    if (keyframes[i].time <= time) prev = keyframes[i];
    if (keyframes[i].time > time) { next = keyframes[i]; break; }
  }

  // Before first keyframe - use first keyframe values
  if (!prev) return { ...keyframes[0] };

  // After last keyframe - use last keyframe values
  if (!next) return { ...prev };

  // Interpolate between prev and next
  const duration = next.time - prev.time;
  const elapsed = time - prev.time;
  let t = duration > 0 ? elapsed / duration : 0;

  // Ease in-out quad
  t = t < 0.5 ? 2 * t * t : 1 - Math.pow(-2 * t + 2, 2) / 2;

  return {
    x: prev.x + (next.x - prev.x) * t,
    y: prev.y + (next.y - prev.y) * t,
    scale: prev.scale + (next.scale - prev.scale) * t,
    rotation: prev.rotation + (next.rotation - prev.rotation) * t,
    perspectiveX: prev.perspectiveX + (next.perspectiveX - prev.perspectiveX) * t,
    perspectiveY: prev.perspectiveY + (next.perspectiveY - prev.perspectiveY) * t
  };
}

// ============================================================
// ENTRANCE ANIMATION
// ============================================================
entranceSelect.addEventListener('change', e => { state.entrance.type = e.target.value; });
entranceDur.addEventListener('input', e => {
  state.entrance.duration = parseInt(e.target.value);
  entranceDurVal.textContent = (parseInt(e.target.value) / 1000).toFixed(1) + 's';
});

// ============================================================

// AUDIO EFFECTS PROCESSOR
// ============================================================
// Professional audio processing using Web Audio API

class AudioEffectChain {
  constructor(audioElement, trackName) {
    this.audioElement = audioElement;
    this.trackName = trackName;
    this.ctx = getSharedAudioContext();

    // Audio nodes
    this.sourceNode = null;
    this.gainNode = null;
    this.panNode = null;
    this.eqLowNode = null;
    this.eqMidNode = null;
    this.eqHighNode = null;
    this.compressorNode = null;
    this.reverbNode = null;
    this.delayNode = null;
    this.delayGainNode = null;
    this.reverbGainNode = null;
    this.analyserNode = null;

    // State
    this.initialized = false;
    this.reverb = { enabled: false, buffer: null, mix: 0.3 };
    this.echo = { enabled: false, delay: 0.5, feedback: 0.3, mix: 0.5 };
  }

  initialize() {
    if (this.initialized) return;

    try {
      // Create source node (only once per audio element)
      if (!this.sourceNode) {
        this.sourceNode = this.ctx.createMediaElementSource(this.audioElement);
      }

      // Create effect nodes
      this.gainNode = this.ctx.createGain();
      this.panNode = this.ctx.createStereoPanner();

      // EQ - 3-band with shelf filters
      this.eqLowNode = this.ctx.createBiquadFilter();
      this.eqLowNode.type = 'lowshelf';
      this.eqLowNode.frequency.value = 200;

      this.eqMidNode = this.ctx.createBiquadFilter();
      this.eqMidNode.type = 'peaking';
      this.eqMidNode.frequency.value = 1000;
      this.eqMidNode.Q.value = 0.5;

      this.eqHighNode = this.ctx.createBiquadFilter();
      this.eqHighNode.type = 'highshelf';
      this.eqHighNode.frequency.value = 3000;

      // Compressor
      this.compressorNode = this.ctx.createDynamicsCompressor();
      this.compressorNode.threshold.value = -24;
      this.compressorNode.knee.value = 30;
      this.compressorNode.ratio.value = 3;
      this.compressorNode.attack.value = 0.003;
      this.compressorNode.release.value = 0.25;

      // Reverb setup (ConvolverNode)
      this.reverbNode = this.ctx.createConvolver();
      this.reverbGainNode = this.ctx.createGain();
      this.reverbGainNode.gain.value = 0;

      // Echo/Delay setup
      this.delayNode = this.ctx.createDelay(2.0);
      this.delayNode.delayTime.value = 0.5;
      this.delayGainNode = this.ctx.createGain();
      this.delayGainNode.gain.value = 0;

      // Analyser for visualization
      this.analyserNode = this.ctx.createAnalyser();
      this.analyserNode.fftSize = 512;

      // Build audio graph
      this.rebuild();

      this.initialized = true;
    } catch (e) {
      console.error(`AudioEffectChain init error (${this.trackName}):`, e);
    }
  }

  rebuild() {
    if (!this.initialized) return;

    try {
      // Disconnect all nodes
      this.sourceNode.disconnect();
      this.gainNode.disconnect();
      this.panNode.disconnect();
      this.eqLowNode.disconnect();
      this.eqMidNode.disconnect();
      this.eqHighNode.disconnect();
      this.compressorNode.disconnect();
      this.delayNode.disconnect();
      this.delayGainNode.disconnect();
      this.reverbNode.disconnect();
      this.reverbGainNode.disconnect();
      this.analyserNode.disconnect();

      // Main chain: source  gain  pan  EQ (low/mid/high)  compressor
      this.sourceNode.connect(this.gainNode);
      this.gainNode.connect(this.panNode);
      this.panNode.connect(this.eqLowNode);
      this.eqLowNode.connect(this.eqMidNode);
      this.eqMidNode.connect(this.eqHighNode);
      this.eqHighNode.connect(this.compressorNode);

      // Reverb send/return
      this.compressorNode.connect(this.reverbNode);
      this.reverbNode.connect(this.reverbGainNode);

      // Delay send/return with feedback
      this.compressorNode.connect(this.delayNode);
      this.delayNode.connect(this.delayGainNode);
      this.delayGainNode.connect(this.delayNode); // Feedback loop

      // Mix everything to analyser
      this.compressorNode.connect(this.analyserNode);
      this.reverbGainNode.connect(this.analyserNode);
      this.delayGainNode.connect(this.analyserNode);

      // Final output
      this.analyserNode.connect(this.ctx.destination);

    } catch (e) {
      console.error(`AudioEffectChain rebuild error (${this.trackName}):`, e);
    }
  }

  // Volume control (0-2 for 0-200%)
  setVolume(value) {
    if (!this.gainNode) return;
    this.gainNode.gain.setValueAtTime(value, this.ctx.currentTime);
  }

  // Pan control (-1 left, 0 center, 1 right)
  setPan(value) {
    if (!this.panNode) return;
    this.panNode.pan.setValueAtTime(value, this.ctx.currentTime);
  }

  // EQ controls (gain in dB: -12 to +12)
  setEQ(band, gainDB) {
    if (!this.initialized) return;
    const gain = gainDB; // Direct dB value

    switch (band) {
      case 'low':
        this.eqLowNode.gain.setValueAtTime(gain, this.ctx.currentTime);
        break;
      case 'mid':
        this.eqMidNode.gain.setValueAtTime(gain, this.ctx.currentTime);
        break;
      case 'high':
        this.eqHighNode.gain.setValueAtTime(gain, this.ctx.currentTime);
        break;
    }
  }

  // Compressor settings
  setCompressor(params) {
    if (!this.compressorNode) return;

    if (params.threshold !== undefined) {
      this.compressorNode.threshold.setValueAtTime(params.threshold, this.ctx.currentTime);
    }
    if (params.ratio !== undefined) {
      this.compressorNode.ratio.setValueAtTime(params.ratio, this.ctx.currentTime);
    }
    if (params.attack !== undefined) {
      this.compressorNode.attack.setValueAtTime(params.attack, this.ctx.currentTime);
    }
    if (params.release !== undefined) {
      this.compressorNode.release.setValueAtTime(params.release, this.ctx.currentTime);
    }
  }

  // Enable/disable reverb
  enableReverb(enabled, mix = 0.3) {
    if (!this.initialized) return;
    this.reverb.enabled = enabled;
    this.reverb.mix = mix;

    if (enabled) {
      // Create impulse response if not exists
      if (!this.reverb.buffer) {
        this.reverb.buffer = this.createReverbImpulse(2.0, 2);
        this.reverbNode.buffer = this.reverb.buffer;
      }
      this.reverbGainNode.gain.setValueAtTime(mix, this.ctx.currentTime);
    } else {
      this.reverbGainNode.gain.setValueAtTime(0, this.ctx.currentTime);
    }
  }

  // Create reverb impulse response
  createReverbImpulse(duration, decay) {
    const sampleRate = this.ctx.sampleRate;
    const length = sampleRate * duration;
    const impulse = this.ctx.createBuffer(2, length, sampleRate);
    const impulseL = impulse.getChannelData(0);
    const impulseR = impulse.getChannelData(1);

    for (let i = 0; i < length; i++) {
      const n = length - i;
      impulseL[i] = (Math.random() * 2 - 1) * Math.pow(n / length, decay);
      impulseR[i] = (Math.random() * 2 - 1) * Math.pow(n / length, decay);
    }

    return impulse;
  }

  // Enable/disable echo/delay
  enableEcho(enabled, params = {}) {
    if (!this.initialized) return;
    this.echo.enabled = enabled;

    if (enabled) {
      const delay = params.delay !== undefined ? params.delay : 0.5;
      const feedback = params.feedback !== undefined ? params.feedback : 0.3;
      const mix = params.mix !== undefined ? params.mix : 0.5;

      this.echo.delay = delay;
      this.echo.feedback = feedback;
      this.echo.mix = mix;

      this.delayNode.delayTime.setValueAtTime(delay, this.ctx.currentTime);
      this.delayGainNode.gain.setValueAtTime(mix * feedback, this.ctx.currentTime);
    } else {
      this.delayGainNode.gain.setValueAtTime(0, this.ctx.currentTime);
    }
  }

  // Get analyser data for visualization
  getAnalyserData() {
    if (!this.analyserNode) return null;
    const data = new Uint8Array(this.analyserNode.frequencyBinCount);
    this.analyserNode.getByteFrequencyData(data);
    return data;
  }

  // Cleanup
  destroy() {
    if (!this.initialized) return;

    try {
      this.sourceNode.disconnect();
      this.gainNode.disconnect();
      this.panNode.disconnect();
      this.eqLowNode.disconnect();
      this.eqMidNode.disconnect();
      this.eqHighNode.disconnect();
      this.compressorNode.disconnect();
      this.delayNode.disconnect();
      this.delayGainNode.disconnect();
      this.reverbNode.disconnect();
      this.reverbGainNode.disconnect();
      this.analyserNode.disconnect();
    } catch (e) {
      // Ignore disconnect errors
    }

    this.initialized = false;
  }
}

// Global audio effect chains (initialized on demand)
const audioChains = {
  main: null,
  bgAudio: null
};

// Initialize audio chain for a track
function initAudioChain(trackName) {
  let audioEl = null;

  if (trackName === 'main') {
    audioEl = document.getElementById('srcVideo');
  } else if (trackName === 'bgAudio') {
    audioEl = document.getElementById('bgAudio');
  }

  if (!audioEl) {
    console.warn(`Audio element not found for track: ${trackName}`);
    return null;
  }

  if (!audioChains[trackName]) {
    audioChains[trackName] = new AudioEffectChain(audioEl, trackName);
  }

  audioChains[trackName].initialize();
  return audioChains[trackName];
}

// Update audio effects from state
function updateAudioEffects(trackName) {
  const effects = state.audioEffects?.[trackName];
  if (!effects) return;

  const chain = audioChains[trackName];
  if (!chain || !chain.initialized) return;

  // Update volume and pan
  chain.setVolume(effects.volume);
  chain.setPan(effects.pan);

  // Update EQ
  chain.setEQ('low', effects.eq.low);
  chain.setEQ('mid', effects.eq.mid);
  chain.setEQ('high', effects.eq.high);

  // Update compressor
  if (effects.compressor.enabled) {
    chain.setCompressor({
      threshold: effects.compressor.threshold,
      ratio: effects.compressor.ratio,
      attack: effects.compressor.attack,
      release: effects.compressor.release
    });
  }

  // Update reverb
  chain.enableReverb(effects.reverb.enabled, effects.reverb.mix);

  // Update echo
  chain.enableEcho(effects.echo.enabled, {
    delay: effects.echo.delay,
    feedback: effects.echo.feedback,
    mix: effects.echo.mix
  });
}

// VIDEO EFFECTS PROCESSOR
// ============================================================
// Professional video processing using CSS filters + WebGL shaders

class VideoEffectProcessor {
  constructor(trackName) {
    this.trackName = trackName;
    this.glCanvas = null;
    this.gl = null;
    this.shaders = {};
    this.initialized = false;
    this._activeBuffers = new Set();
    this._activeTextures = new Set();
    this._lastUsed = Date.now();
    this._frameCount = 0;
  }

  // Apply CSS filters (fast, GPU-accelerated)
  applyCSSFilters(videoElement, effects) {
    if (!videoElement) return;

    const filters = [];

    // Brightness (-100 to 100  0% to 200%)
    if (effects.brightness !== 0) {
      const val = 100 + effects.brightness;
      filters.push(`brightness(${val}%)`);
    }

    // Contrast (-100 to 100  0% to 200%)
    if (effects.contrast !== 0) {
      const val = 100 + effects.contrast;
      filters.push(`contrast(${val}%)`);
    }

    // Saturation (-100 to 100  0% to 200%)
    if (effects.saturation !== 0) {
      const val = 100 + effects.saturation;
      filters.push(`saturate(${val}%)`);
    }

    // Hue rotation (-180 to 180 degrees)
    if (effects.hue !== 0) {
      filters.push(`hue-rotate(${effects.hue}deg)`);
    }

    // Temperature (warm/cool tint using sepia + hue)
    if (effects.temperature !== 0) {
      const warmth = effects.temperature / 100;
      if (warmth > 0) {
        filters.push(`sepia(${warmth * 30}%)`);
        filters.push(`hue-rotate(${warmth * -10}deg)`);
      } else {
        filters.push(`hue-rotate(${warmth * 10}deg)`);
      }
    }

    // Apply filter stack from effects.filters array
    if (effects.filters && effects.filters.length > 0) {
      for (const filter of effects.filters) {
        switch (filter.type) {
          case 'blur':
            filters.push(`blur(${filter.amount || 5}px)`);
            break;
          case 'sharpen':
            // CSS doesn't support sharpen directly, handled by WebGL
            break;
          case 'grayscale':
            filters.push(`grayscale(100%)`);
            break;
          case 'sepia':
            filters.push(`sepia(${filter.amount || 100}%)`);
            break;
        }
      }
    }

    videoElement.style.filter = filters.length > 0 ? filters.join(' ') : '';
  }

  // Check if WebGL effects are needed (advanced filters)
  needsWebGL(effects) {
    if (!effects.filters) return false;

    const webglTypes = ['pixelate', 'edgedetect', 'posterize', 'solarize', 'sharpen'];
    return effects.filters.some(f => webglTypes.includes(f.type));
  }

  // Initialize WebGL context
  initWebGL() {
    if (this.initialized) return true;

    this.glCanvas = document.createElement('canvas');
    this.gl = this.glCanvas.getContext('webgl', {
      preserveDrawingBuffer: true,
      premultipliedAlpha: false
    });

    if (!this.gl) {
      console.warn('WebGL not supported for video effects');
      return false;
    }

    // Compile shaders
    this.compileShaders();
    this.initialized = true;
    return true;
  }

  // Compile GLSL shaders
  compileShaders() {
    const gl = this.gl;

    // Vertex shader (same for all effects)
    const vertexShaderSource = `
      attribute vec2 a_position;
      attribute vec2 a_texCoord;
      varying vec2 v_texCoord;
      void main() {
        gl_Position = vec4(a_position, 0.0, 1.0);
        v_texCoord = a_texCoord;
      }
    `;

    // Pixelate shader
    const pixelateFragmentSource = `
      precision mediump float;
      uniform sampler2D u_texture;
      uniform vec2 u_resolution;
      uniform float u_blockSize;
      varying vec2 v_texCoord;

      void main() {
        vec2 blocks = u_resolution / u_blockSize;
        vec2 coord = floor(v_texCoord * blocks) / blocks;
        gl_FragColor = texture2D(u_texture, coord);
      }
    `;

    // Edge detection shader (Sobel)
    const edgeDetectFragmentSource = `
      precision mediump float;
      uniform sampler2D u_texture;
      uniform vec2 u_resolution;
      varying vec2 v_texCoord;

      void main() {
        vec2 texel = 1.0 / u_resolution;

        // Sobel kernel
        float tl = texture2D(u_texture, v_texCoord + vec2(-texel.x, texel.y)).r;
        float t  = texture2D(u_texture, v_texCoord + vec2(0.0, texel.y)).r;
        float tr = texture2D(u_texture, v_texCoord + vec2(texel.x, texel.y)).r;
        float l  = texture2D(u_texture, v_texCoord + vec2(-texel.x, 0.0)).r;
        float r  = texture2D(u_texture, v_texCoord + vec2(texel.x, 0.0)).r;
        float bl = texture2D(u_texture, v_texCoord + vec2(-texel.x, -texel.y)).r;
        float b  = texture2D(u_texture, v_texCoord + vec2(0.0, -texel.y)).r;
        float br = texture2D(u_texture, v_texCoord + vec2(texel.x, -texel.y)).r;

        float gx = -tl - 2.0*l - bl + tr + 2.0*r + br;
        float gy = -tl - 2.0*t - tr + bl + 2.0*b + br;

        float edge = sqrt(gx*gx + gy*gy);
        gl_FragColor = vec4(vec3(edge), 1.0);
      }
    `;

    // Posterize shader
    const posterizeFragmentSource = `
      precision mediump float;
      uniform sampler2D u_texture;
      uniform float u_levels;
      varying vec2 v_texCoord;

      void main() {
        vec4 color = texture2D(u_texture, v_texCoord);
        vec3 posterized = floor(color.rgb * u_levels) / u_levels;
        gl_FragColor = vec4(posterized, color.a);
      }
    `;

    // Compile and store shaders
    this.shaders.pixelate = this.createProgram(vertexShaderSource, pixelateFragmentSource);
    this.shaders.edgedetect = this.createProgram(vertexShaderSource, edgeDetectFragmentSource);
    this.shaders.posterize = this.createProgram(vertexShaderSource, posterizeFragmentSource);
  }

  // Create shader program
  createProgram(vertexSource, fragmentSource) {
    const gl = this.gl;

    const vertexShader = gl.createShader(gl.VERTEX_SHADER);
    gl.shaderSource(vertexShader, vertexSource);
    gl.compileShader(vertexShader);

    const fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
    gl.shaderSource(fragmentShader, fragmentSource);
    gl.compileShader(fragmentShader);

    const program = gl.createProgram();
    gl.attachShader(program, vertexShader);
    gl.attachShader(program, fragmentShader);
    gl.linkProgram(program);

    if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
      console.error('Shader program link error:', gl.getProgramInfoLog(program));
      return null;
    }

    return program;
  }

  // Apply WebGL effects (advanced)
  applyWebGLEffects(sourceCanvas, effects) {
    if (!this.initWebGL()) return;

    this._lastUsed = Date.now();
    this._frameCount++;

    const gl = this.gl;
    const filters = effects.filters || [];

    // Setup canvas size
    if (this.glCanvas.width !== sourceCanvas.width || this.glCanvas.height !== sourceCanvas.height) {
      this.glCanvas.width = sourceCanvas.width;
      this.glCanvas.height = sourceCanvas.height;
      gl.viewport(0, 0, this.glCanvas.width, this.glCanvas.height);
    }

    // Create texture from source
    const texture = gl.createTexture();
    this._activeTextures.add(texture);
    gl.bindTexture(gl.TEXTURE_2D, texture);
    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, sourceCanvas);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);

    // Setup geometry (full-screen quad)
    const positionBuffer = gl.createBuffer();
    this._activeBuffers.add(positionBuffer);
    gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
      -1, -1,  1, -1,  -1, 1,
      -1, 1,   1, -1,  1, 1
    ]), gl.STATIC_DRAW);

    const texCoordBuffer = gl.createBuffer();
    this._activeBuffers.add(texCoordBuffer);
    gl.bindBuffer(gl.ARRAY_BUFFER, texCoordBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
      0, 1,  1, 1,  0, 0,
      0, 0,  1, 1,  1, 0
    ]), gl.STATIC_DRAW);

    // Apply each filter in sequence
    for (const filter of filters) {
      let program = null;

      switch (filter.type) {
        case 'pixelate':
          program = this.shaders.pixelate;
          if (program) {
            gl.useProgram(program);
            gl.uniform2f(gl.getUniformLocation(program, 'u_resolution'), this.glCanvas.width, this.glCanvas.height);
            gl.uniform1f(gl.getUniformLocation(program, 'u_blockSize'), filter.blockSize || 10);
          }
          break;

        case 'edgedetect':
          program = this.shaders.edgedetect;
          if (program) {
            gl.useProgram(program);
            gl.uniform2f(gl.getUniformLocation(program, 'u_resolution'), this.glCanvas.width, this.glCanvas.height);
          }
          break;

        case 'posterize':
          program = this.shaders.posterize;
          if (program) {
            gl.useProgram(program);
            gl.uniform1f(gl.getUniformLocation(program, 'u_levels'), filter.levels || 8);
          }
          break;
      }

      if (program) {
        // Bind attributes
        const posLoc = gl.getAttribLocation(program, 'a_position');
        gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
        gl.enableVertexAttribArray(posLoc);
        gl.vertexAttribPointer(posLoc, 2, gl.FLOAT, false, 0, 0);

        const texLoc = gl.getAttribLocation(program, 'a_texCoord');
        gl.bindBuffer(gl.ARRAY_BUFFER, texCoordBuffer);
        gl.enableVertexAttribArray(texLoc);
        gl.vertexAttribPointer(texLoc, 2, gl.FLOAT, false, 0, 0);

        // Draw
        gl.drawArrays(gl.TRIANGLES, 0, 6);
      }
    }

    // Copy result back to source canvas
    const srcCtx = sourceCanvas.getContext('2d');
    srcCtx.drawImage(this.glCanvas, 0, 0);

    // Cleanup resources immediately
    if (texture) {
      gl.deleteTexture(texture);
      this._activeTextures.delete(texture);
    }
    if (positionBuffer) {
      gl.deleteBuffer(positionBuffer);
      this._activeBuffers.delete(positionBuffer);
    }
    if (texCoordBuffer) {
      gl.deleteBuffer(texCoordBuffer);
      this._activeBuffers.delete(texCoordBuffer);
    }

    // Periodic memory cleanup every 300 frames
    if (this._frameCount % 300 === 0) {
      this.cleanupUnusedResources();
    }
  }

  // Apply blend mode
  applyBlendMode(ctx, blendMode) {
    ctx.globalCompositeOperation = blendMode || 'normal';
  }

  // Clean up unused resources
  cleanupUnusedResources() {
    if (!this.gl) return;

    const gl = this.gl;

    // Clean up orphaned textures
    for (const texture of this._activeTextures) {
      if (texture && gl.isTexture(texture)) {
        gl.deleteTexture(texture);
      }
    }
    this._activeTextures.clear();

    // Clean up orphaned buffers
    for (const buffer of this._activeBuffers) {
      if (buffer && gl.isBuffer(buffer)) {
        gl.deleteBuffer(buffer);
      }
    }
    this._activeBuffers.clear();
  }

  // Monitor memory usage
  monitorMemoryUsage() {
    if (window.performance?.memory) {
      const memory = window.performance.memory;
      const usedMB = memory.usedJSHeapSize / (1024 * 1024);
      const limitMB = memory.jsHeapSizeLimit / (1024 * 1024);

      // Warn if using more than 100MB
      if (usedMB > 100) {
        console.warn(`High memory usage: ${usedMB.toFixed(2)}MB / ${limitMB.toFixed(2)}MB`);
        this.cleanupUnusedResources();
      }

      // Force cleanup if using more than 70% of available memory
      if (usedMB > limitMB * 0.7) {
        console.warn('Critical memory usage - forcing cleanup');
        this.destroy();
        this.initialized = false;
      }
    }
  }

  // Check if processor is stale (not used in 30 seconds)
  isStale() {
    return Date.now() - this._lastUsed > 30000;
  }

  // Cleanup
  destroy() {
    if (this.gl) {
      const gl = this.gl;

      // Clean up shaders
      for (const key in this.shaders) {
        if (this.shaders[key] && gl.isProgram(this.shaders[key])) {
          gl.deleteProgram(this.shaders[key]);
        }
      }
      this.shaders = {};

      // Clean up remaining resources
      this.cleanupUnusedResources();

      // Force WebGL context loss to free GPU memory
      const loseContextExt = gl.getExtension('WEBGL_lose_context');
      if (loseContextExt) {
        loseContextExt.loseContext();
      }
    }

    this.glCanvas = null;
    this.gl = null;
    this.initialized = false;
    this._frameCount = 0;
  }
}

// Global video effect processors
const videoProcessors = {
  main: new VideoEffectProcessor('main'),
  bgVideo: new VideoEffectProcessor('bgVideo')
};

// ============================================================
// MEMORY MANAGEMENT
// ============================================================

// Monitor memory usage every 5 seconds
if (typeof setInterval !== 'undefined') {
  setInterval(() => {
    for (const key in videoProcessors) {
      const processor = videoProcessors[key];
      if (processor.initialized) {
        processor.monitorMemoryUsage();

        // Clean up stale processors
        if (processor.isStale()) {
          console.log(`Cleaning up stale video processor: ${key}`);
          processor.destroy();
        }
      }
    }
  }, 5000);
}

// Cleanup all processors on page unload
if (typeof window !== 'undefined') {
  window.addEventListener('beforeunload', () => {
    for (const key in videoProcessors) {
      videoProcessors[key].destroy();
    }
  });

  // Also cleanup on visibility change (tab switch)
  document.addEventListener('visibilitychange', () => {
    if (document.hidden) {
      for (const key in videoProcessors) {
        const processor = videoProcessors[key];
        if (processor.initialized && processor.isStale()) {
          processor.cleanupUnusedResources();
        }
      }
    }
  });
}

// Export cleanup function for manual use
window.cleanupVideoProcessors = () => {
  for (const key in videoProcessors) {
    videoProcessors[key].destroy();
  }
  console.log('All video processors cleaned up');
};

// EFFECT PRESETS
// ============================================================
// Predefined audio and video effect configurations

const AUDIO_PRESETS = {
  podcast: {
    name: 'Podcast Voice',
    effects: {
      volume: 1.0,
      pan: 0,
      eq: { low: -2, mid: 3, high: 5 },
      compressor: {
        enabled: true,
        threshold: -18,
        ratio: 4,
        attack: 0.003,
        release: 0.25
      },
      reverb: { enabled: false, mix: 0.3, decay: 2 },
      echo: { enabled: false, delay: 0.5, feedback: 0.3, mix: 0.5 }
    }
  },

  music: {
    name: 'Music Enhancement',
    effects: {
      volume: 1.0,
      pan: 0,
      eq: { low: 3, mid: 0, high: 2 },
      compressor: {
        enabled: true,
        threshold: -12,
        ratio: 2,
        attack: 0.003,
        release: 0.25
      },
      reverb: { enabled: false, mix: 0.3, decay: 2 },
      echo: { enabled: false, delay: 0.5, feedback: 0.3, mix: 0.5 }
    }
  },

  bass: {
    name: 'Bass Boost',
    effects: {
      volume: 1.0,
      pan: 0,
      eq: { low: 8, mid: -2, high: 0 },
      compressor: {
        enabled: false,
        threshold: -24,
        ratio: 3,
        attack: 0.003,
        release: 0.25
      },
      reverb: { enabled: false, mix: 0.3, decay: 2 },
      echo: { enabled: false, delay: 0.5, feedback: 0.3, mix: 0.5 }
    }
  },

  vocal: {
    name: 'Vocal Clarity',
    effects: {
      volume: 1.0,
      pan: 0,
      eq: { low: -3, mid: 5, high: 3 },
      compressor: {
        enabled: true,
        threshold: -15,
        ratio: 3,
        attack: 0.003,
        release: 0.25
      },
      reverb: { enabled: false, mix: 0.3, decay: 2 },
      echo: { enabled: false, delay: 0.5, feedback: 0.3, mix: 0.5 }
    }
  },

  radio: {
    name: 'Radio Effect',
    effects: {
      volume: 1.0,
      pan: 0,
      eq: { low: -8, mid: 6, high: -4 },
      compressor: {
        enabled: true,
        threshold: -12,
        ratio: 8,
        attack: 0.001,
        release: 0.1
      },
      reverb: { enabled: false, mix: 0.3, decay: 2 },
      echo: { enabled: false, delay: 0.5, feedback: 0.3, mix: 0.5 }
    }
  },

  spacious: {
    name: 'Spacious Reverb',
    effects: {
      volume: 1.0,
      pan: 0,
      eq: { low: 0, mid: 0, high: 2 },
      compressor: {
        enabled: false,
        threshold: -24,
        ratio: 3,
        attack: 0.003,
        release: 0.25
      },
      reverb: { enabled: true, mix: 0.5, decay: 3 },
      echo: { enabled: false, delay: 0.5, feedback: 0.3, mix: 0.5 }
    }
  }
};

const VIDEO_PRESETS = {
  cinematic: {
    name: 'Cinematic',
    effects: {
      brightness: -5,
      contrast: 15,
      saturation: -10,
      hue: 0,
      temperature: 5,
      tint: 0,
      levels: {
        inputMin: 0,
        inputMax: 255,
        gamma: 1.1,
        outputMin: 0,
        outputMax: 255
      },
      filters: [],
      blendMode: 'normal',
      crop: { enabled: false, x: 0, y: 0, w: 1, h: 1 }
    }
  },

  vibrant: {
    name: 'Vibrant Pop',
    effects: {
      brightness: 5,
      contrast: 20,
      saturation: 40,
      hue: 0,
      temperature: 0,
      tint: 0,
      levels: {
        inputMin: 0,
        inputMax: 255,
        gamma: 1.0,
        outputMin: 0,
        outputMax: 255
      },
      filters: [],
      blendMode: 'normal',
      crop: { enabled: false, x: 0, y: 0, w: 1, h: 1 }
    }
  },

  vintage: {
    name: 'Vintage Film',
    effects: {
      brightness: -10,
      contrast: 5,
      saturation: -20,
      hue: 0,
      temperature: 25,
      tint: 0,
      levels: {
        inputMin: 0,
        inputMax: 255,
        gamma: 1.05,
        outputMin: 0,
        outputMax: 255
      },
      filters: [
        { type: 'sepia', amount: 30 }
      ],
      blendMode: 'normal',
      crop: { enabled: false, x: 0, y: 0, w: 1, h: 1 }
    }
  },

  bwContrast: {
    name: 'B&W High Contrast',
    effects: {
      brightness: 0,
      contrast: 40,
      saturation: -100,
      hue: 0,
      temperature: 0,
      tint: 0,
      levels: {
        inputMin: 0,
        inputMax: 255,
        gamma: 1.2,
        outputMin: 0,
        outputMax: 255
      },
      filters: [],
      blendMode: 'normal',
      crop: { enabled: false, x: 0, y: 0, w: 1, h: 1 }
    }
  },

  cool: {
    name: 'Cool Tone',
    effects: {
      brightness: 0,
      contrast: 10,
      saturation: 10,
      hue: 0,
      temperature: -30,
      tint: 0,
      levels: {
        inputMin: 0,
        inputMax: 255,
        gamma: 1.0,
        outputMin: 0,
        outputMax: 255
      },
      filters: [],
      blendMode: 'normal',
      crop: { enabled: false, x: 0, y: 0, w: 1, h: 1 }
    }
  },

  warm: {
    name: 'Warm Tone',
    effects: {
      brightness: 5,
      contrast: 5,
      saturation: 10,
      hue: 0,
      temperature: 30,
      tint: 0,
      levels: {
        inputMin: 0,
        inputMax: 255,
        gamma: 1.0,
        outputMin: 0,
        outputMax: 255
      },
      filters: [],
      blendMode: 'normal',
      crop: { enabled: false, x: 0, y: 0, w: 1, h: 1 }
    }
  },

  fade: {
    name: 'Faded Look',
    effects: {
      brightness: 10,
      contrast: -15,
      saturation: -20,
      hue: 0,
      temperature: 0,
      tint: 0,
      levels: {
        inputMin: 20,
        inputMax: 235,
        gamma: 1.0,
        outputMin: 0,
        outputMax: 255
      },
      filters: [],
      blendMode: 'normal',
      crop: { enabled: false, x: 0, y: 0, w: 1, h: 1 }
    }
  },

  dramatic: {
    name: 'Dramatic',
    effects: {
      brightness: -10,
      contrast: 50,
      saturation: 20,
      hue: 0,
      temperature: 0,
      tint: 0,
      levels: {
        inputMin: 0,
        inputMax: 255,
        gamma: 1.3,
        outputMin: 0,
        outputMax: 255
      },
      filters: [],
      blendMode: 'normal',
      crop: { enabled: false, x: 0, y: 0, w: 1, h: 1 }
    }
  }
};

// Load audio preset
function loadAudioPreset(trackName, presetName) {
  const preset = AUDIO_PRESETS[presetName];
  if (!preset || !state.audioEffects) return;

  // Update state
  Object.assign(state.audioEffects[trackName], preset.effects);

  // Update audio chain
  updateAudioEffects(trackName);

  // Update UI
  updateAudioEffectUI(trackName);
}

// Load video preset
function loadVideoPreset(trackName, presetName) {
  const preset = VIDEO_PRESETS[presetName];
  if (!preset || !state.videoEffects) return;

  // Update state
  Object.assign(state.videoEffects[trackName], preset.effects);

  // Update UI
  updateVideoEffectUI(trackName);
}

// Save custom preset to localStorage
function saveCustomPreset(type, trackName, presetName, config) {
  const key = `customPresets_${type}`;
  let presets = {};

  try {
    const stored = localStorage.getItem(key);
    if (stored) presets = JSON.parse(stored);
  } catch (e) {
    console.error('Error loading custom presets:', e);
  }

  presets[presetName] = {
    name: presetName,
    effects: config
  };

  try {
    localStorage.setItem(key, JSON.stringify(presets));
    showToast(`Saved custom preset: ${presetName}`, 'success');
  } catch (e) {
    console.error('Error saving custom preset:', e);
    showToast('Failed to save preset', 'error');
  }
}

// Get custom presets
function getCustomPresets(type) {
  const key = `customPresets_${type}`;
  try {
    const stored = localStorage.getItem(key);
    return stored ? JSON.parse(stored) : {};
  } catch (e) {
    console.error('Error loading custom presets:', e);
    return {};
  }
}

// ============================================================
// BEAT DETECTOR  Real-time audio onset detection
// ============================================================
const beatDetector = {
  // Public properties (updated every frame)
  isBeat: false,
  beatIntensity: 0,
  energy: 0,
  kickBeat: false,
  snareBeat: false,
  hihatBeat: false,
  timeSinceLastBeat: 999,
  estimatedBPM: 120,

  // Internal state
  _lastBeatTime: 0,
  _kickAvg: 0,
  _snareAvg: 0,
  _hihatAvg: 0,
  _overallAvg: 0,
  _beatIntervals: [],
  _minBeatInterval: 0.2,
  _smoothing: 0.92,
  _kickThreshold: 1.4,
  _snareThreshold: 1.3,
  _hihatThreshold: 1.3,

  update: function(currentTime) {
    // Reset per-frame flags
    this.isBeat = false;
    this.kickBeat = false;
    this.snareBeat = false;
    this.hihatBeat = false;

    if (!audioAnalyser || !analyserData) return;

    audioAnalyser.getByteFrequencyData(analyserData);

    var binCount = analyserData.length;
    var sampleRate = sharedAudioCtx ? sharedAudioCtx.sampleRate : 48000;
    var binHz = (sampleRate / 2) / binCount;

    // Band boundaries
    var lowEnd = Math.min(binCount, Math.ceil(300 / binHz));
    var midEnd = Math.min(binCount, Math.ceil(2000 / binHz));

    var lowEnergy = 0, midEnergy = 0, highEnergy = 0, totalEnergy = 0;
    var lowCount = 0, midCount = 0, highCount = 0;

    for (var i = 0; i < binCount; i++) {
      var val = analyserData[i] / 255;
      totalEnergy += val;
      if (i < lowEnd) { lowEnergy += val; lowCount++; }
      else if (i < midEnd) { midEnergy += val; midCount++; }
      else { highEnergy += val; highCount++; }
    }

    // Average per band
    lowEnergy = lowCount > 0 ? lowEnergy / lowCount : 0;
    midEnergy = midCount > 0 ? midEnergy / midCount : 0;
    highEnergy = highCount > 0 ? highEnergy / highCount : 0;
    totalEnergy = binCount > 0 ? totalEnergy / binCount : 0;

    // Update exponential moving averages
    var s = this._smoothing;
    this._kickAvg = this._kickAvg * s + lowEnergy * (1 - s);
    this._snareAvg = this._snareAvg * s + midEnergy * (1 - s);
    this._hihatAvg = this._hihatAvg * s + highEnergy * (1 - s);
    this._overallAvg = this._overallAvg * s + totalEnergy * (1 - s);

    // Smoothed energy (0-1)
    this.energy = Math.min(1, this._overallAvg * 2);

    var now = currentTime || performance.now() * 0.001;
    var elapsed = now - this._lastBeatTime;

    // Per-band beat detection
    if (this._kickAvg > 0.01 && lowEnergy > this._kickAvg * this._kickThreshold) {
      this.kickBeat = true;
    }
    if (this._snareAvg > 0.01 && midEnergy > this._snareAvg * this._snareThreshold) {
      this.snareBeat = true;
    }
    if (this._hihatAvg > 0.01 && highEnergy > this._hihatAvg * this._hihatThreshold) {
      this.hihatBeat = true;
    }

    // Overall beat: kick or snare triggered + minimum interval respected
    if ((this.kickBeat || this.snareBeat) && elapsed >= this._minBeatInterval) {
      this.isBeat = true;
      var intensityRatio = this._overallAvg > 0.01 ? totalEnergy / this._overallAvg : 1;
      this.beatIntensity = Math.min(1, Math.max(0, (intensityRatio - 1) / 0.5));

      // Track beat intervals for BPM estimation
      if (elapsed < 2) {
        this._beatIntervals.push(elapsed);
        if (this._beatIntervals.length > 8) this._beatIntervals.shift();
      }
      this._lastBeatTime = now;

      // Estimate BPM from rolling average of intervals
      if (this._beatIntervals.length >= 2) {
        var sum = 0;
        for (var j = 0; j < this._beatIntervals.length; j++) sum += this._beatIntervals[j];
        var avgInterval = sum / this._beatIntervals.length;
        this.estimatedBPM = Math.max(60, Math.min(200, Math.round(60 / avgInterval)));
      }
    }

    this.timeSinceLastBeat = now - this._lastBeatTime;
  },

  // Reset detector state
  reset: function() {
    this.isBeat = false;
    this.beatIntensity = 0;
    this.energy = 0;
    this.kickBeat = false;
    this.snareBeat = false;
    this.hihatBeat = false;
    this.timeSinceLastBeat = 999;
    this.estimatedBPM = 120;
    this._lastBeatTime = 0;
    this._kickAvg = 0;
    this._snareAvg = 0;
    this._hihatAvg = 0;
    this._overallAvg = 0;
    this._beatIntervals = [];
  },

  // Adjust sensitivity
  setSensitivity: function(level) {
    // level: 'low' | 'medium' | 'high'
    switch (level) {
      case 'low':
        this._kickThreshold = 1.6;
        this._snareThreshold = 1.5;
        this._hihatThreshold = 1.5;
        break;
      case 'high':
        this._kickThreshold = 1.2;
        this._snareThreshold = 1.1;
        this._hihatThreshold = 1.1;
        break;
      default: // medium
        this._kickThreshold = 1.4;
        this._snareThreshold = 1.3;
        this._hihatThreshold = 1.3;
    }
  },

  // Get performance metrics
  getMetrics: function() {
    return {
      energy: this.energy.toFixed(2),
      bpm: this.estimatedBPM,
      timeSinceLastBeat: this.timeSinceLastBeat.toFixed(2),
      beatIntensity: this.beatIntensity.toFixed(2),
      intervalsTracked: this._beatIntervals.length,
      avgKick: this._kickAvg.toFixed(3),
      avgSnare: this._snareAvg.toFixed(3),
      avgHihat: this._hihatAvg.toFixed(3)
    };
  }
};

// Export beat detector methods
if (typeof window !== 'undefined') {
  window.resetBeatDetector = () => beatDetector.reset();
  window.setBeatSensitivity = (level) => beatDetector.setSensitivity(level);
  window.getBeatMetrics = () => beatDetector.getMetrics();
}

// ============================================================

// DEVICE DRAW FUNCTIONS
// ============================================================
function drawIPhone16(c, S, dev, pal) {
  // Outer body
  rrPath(c, 0, 0, dev.baseW*S, dev.baseH*S, dev.cornerR*S);
  const bodyH = c.createLinearGradient(0, 0, dev.baseW*S, 0);
  bodyH.addColorStop(0, pal.edge);
  bodyH.addColorStop(0.015, pal.mid);
  bodyH.addColorStop(0.04, pal.body);
  bodyH.addColorStop(0.15, pal.body);
  bodyH.addColorStop(0.5, pal.mid);
  bodyH.addColorStop(0.85, pal.body);
  bodyH.addColorStop(0.96, pal.body);
  bodyH.addColorStop(0.985, pal.mid);
  bodyH.addColorStop(1, pal.edge);
  c.fillStyle = bodyH;
  c.fill();

  // Vertical ambient
  rrPath(c, 0, 0, dev.baseW*S, dev.baseH*S, dev.cornerR*S);
  const bodyV = c.createLinearGradient(0, 0, 0, dev.baseH*S);
  bodyV.addColorStop(0, 'rgba(255,255,255,0.07)');
  bodyV.addColorStop(0.03, 'rgba(255,255,255,0.03)');
  bodyV.addColorStop(0.15, 'rgba(255,255,255,0)');
  bodyV.addColorStop(0.85, 'rgba(255,255,255,0)');
  bodyV.addColorStop(0.97, 'rgba(255,255,255,0.02)');
  bodyV.addColorStop(1, 'rgba(255,255,255,0.05)');
  c.fillStyle = bodyV;
  c.fill();

  // Chamfered edge
  rrPath(c, 0.4*S, 0.4*S, (dev.baseW-0.8)*S, (dev.baseH-0.8)*S, (dev.cornerR-0.4)*S);
  c.strokeStyle = 'rgba(255,255,255,0.15)';
  c.lineWidth = 0.8*S;
  c.stroke();

  // Inner lip shadow
  rrPath(c, 3.5*S, 3.5*S, (dev.baseW-7)*S, (dev.baseH-7)*S, (dev.cornerR-3.5)*S);
  c.strokeStyle = 'rgba(0,0,0,0.6)';
  c.lineWidth = 1.5*S;
  c.stroke();

  // Screen bezel
  rrPath(c, 5*S, 5*S, (dev.baseW-10)*S, (dev.baseH-10)*S, (dev.cornerR-5)*S);
  c.fillStyle = pal.bezel;
  c.fill();

  // Screen cutout
  c.save();
  rrPath(c, dev.screenX*S, dev.screenY*S, dev.screenW*S, dev.screenH*S, dev.screenR*S);
  c.globalCompositeOperation = 'destination-out';
  c.fillStyle = '#000';
  c.fill();
  c.restore();

  // Dynamic Island
  pillPath(c, dev.islandX*S, dev.islandY*S, dev.islandW*S, dev.islandH*S);
  c.fillStyle = '#000000';
  c.fill();
  pillPath(c, dev.islandX*S, dev.islandY*S, dev.islandW*S, dev.islandH*S);
  c.strokeStyle = 'rgba(255,255,255,0.035)';
  c.lineWidth = 0.6*S;
  c.stroke();

  // Front camera
  const cx = dev.camX*S, cy = dev.camY*S;
  c.beginPath(); c.arc(cx, cy, 5.5*S, 0, Math.PI*2); c.fillStyle = '#0a0a14'; c.fill();
  c.beginPath(); c.arc(cx, cy, 4.5*S, 0, Math.PI*2);
  c.strokeStyle = 'rgba(80,80,140,0.3)'; c.lineWidth = 0.6*S; c.stroke();
  c.beginPath(); c.arc(cx, cy, 3*S, 0, Math.PI*2);
  const lg = c.createRadialGradient(cx, cy, 0, cx, cy, 3*S);
  lg.addColorStop(0, '#14142a'); lg.addColorStop(0.7, '#0d0d1a'); lg.addColorStop(1, '#06060e');
  c.fillStyle = lg; c.fill();
  c.beginPath(); c.arc(cx-1.2*S, cy-1.2*S, 1*S, 0, Math.PI*2);
  c.fillStyle = 'rgba(150,160,220,0.2)'; c.fill();

  // Side buttons
  const btnFill = pal.body === '#fafafa' ? '#d0d0d0' : '#252527';
  rrPath(c, (dev.baseW-0.2)*S, 218*S, 2.8*S, 72*S, 1.4*S);
  c.fillStyle = btnFill; c.fill();
  rrPath(c, -2.6*S, 192*S, 2.8*S, 42*S, 1.4*S);
  c.fillStyle = btnFill; c.fill();
  rrPath(c, -2.6*S, 245*S, 2.8*S, 42*S, 1.4*S);
  c.fillStyle = btnFill; c.fill();
  rrPath(c, -2.6*S, 146*S, 2.8*S, 26*S, 1.4*S);
  c.fillStyle = btnFill; c.fill();

  // Bottom details
  const bY = (dev.baseH - 4.5)*S;
  c.fillStyle = pal.bezel === '#e0e0e0' ? '#b0b0b0' : '#1c1c1e';
  for (let i = 0; i < 6; i++) {
    c.beginPath(); c.arc((dev.baseW/2 - 34 + i*9.5)*S, bY, 1.6*S, 0, Math.PI*2); c.fill();
  }
  for (let i = 0; i < 6; i++) {
    c.beginPath(); c.arc((dev.baseW/2 + 12 + i*9.5)*S, bY, 1.6*S, 0, Math.PI*2); c.fill();
  }
  rrPath(c, (dev.baseW/2 - 11)*S, (dev.baseH-5.5)*S, 22*S, 4.8*S, 2.4*S);
  c.fillStyle = pal.bezel === '#e0e0e0' ? '#c0c0c0' : '#18181b'; c.fill();
  rrPath(c, (dev.baseW/2 - 11)*S, (dev.baseH-5.5)*S, 22*S, 4.8*S, 2.4*S);
  c.strokeStyle = 'rgba(255,255,255,0.03)'; c.lineWidth = 0.3*S; c.stroke();
}

function drawIPadPro(c, S, dev, pal) {
  // Body
  rrPath(c, 0, 0, dev.baseW*S, dev.baseH*S, dev.cornerR*S);
  const bg = c.createLinearGradient(0, 0, dev.baseW*S, 0);
  bg.addColorStop(0, pal.edge); bg.addColorStop(0.02, pal.body);
  bg.addColorStop(0.98, pal.body); bg.addColorStop(1, pal.edge);
  c.fillStyle = bg; c.fill();

  // Edge highlight
  rrPath(c, 0.5*S, 0.5*S, (dev.baseW-1)*S, (dev.baseH-1)*S, (dev.cornerR-0.5)*S);
  c.strokeStyle = 'rgba(255,255,255,0.1)'; c.lineWidth = 0.6*S; c.stroke();

  // Bezel area
  rrPath(c, 8*S, 8*S, (dev.baseW-16)*S, (dev.baseH-16)*S, (dev.cornerR-8)*S);
  c.fillStyle = pal.bezel; c.fill();

  // Screen cutout
  c.save();
  rrPath(c, dev.screenX*S, dev.screenY*S, dev.screenW*S, dev.screenH*S, dev.screenR*S);
  c.globalCompositeOperation = 'destination-out';
  c.fillStyle = '#000'; c.fill();
  c.restore();

  // Front camera (landscape edge - top center)
  const camCx = (dev.baseW/2)*S, camCy = 8*S;
  c.beginPath(); c.arc(camCx, camCy, 3*S, 0, Math.PI*2);
  c.fillStyle = '#0a0a14'; c.fill();
  c.beginPath(); c.arc(camCx, camCy, 2*S, 0, Math.PI*2);
  c.fillStyle = '#06060e'; c.fill();

  // USB-C bottom
  rrPath(c, (dev.baseW/2 - 10)*S, (dev.baseH-4)*S, 20*S, 3.5*S, 1.7*S);
  c.fillStyle = pal.bezel === '#c8c8c8' ? '#a0a0a0' : '#18181b'; c.fill();
}

function drawMacBookPro(c, S, dev, pal) {
  const screenH = dev.screenY + dev.screenH + 16;
  const baseY = screenH;
  const baseH = dev.baseH - screenH;

  // Screen lid
  rrPath(c, 0, 0, dev.baseW*S, screenH*S, dev.cornerR*S);
  const bg = c.createLinearGradient(0, 0, dev.baseW*S, 0);
  bg.addColorStop(0, pal.edge); bg.addColorStop(0.02, pal.body);
  bg.addColorStop(0.98, pal.body); bg.addColorStop(1, pal.edge);
  c.fillStyle = bg; c.fill();

  // Bezel
  rrPath(c, 20*S, 10*S, (dev.baseW-40)*S, (screenH-12)*S, 8*S);
  c.fillStyle = pal.bezel; c.fill();

  // Screen cutout
  c.save();
  rrPath(c, dev.screenX*S, dev.screenY*S, dev.screenW*S, dev.screenH*S, dev.screenR*S);
  c.globalCompositeOperation = 'destination-out';
  c.fillStyle = '#000'; c.fill();
  c.restore();

  // Notch
  const notchW = 120, notchH = 18;
  const notchX = (dev.baseW - notchW) / 2;
  rrPath(c, notchX*S, dev.screenY*S, notchW*S, notchH*S, 6*S);
  c.fillStyle = pal.bezel; c.fill();
  // Camera in notch
  c.beginPath(); c.arc((dev.baseW/2)*S, (dev.screenY + notchH/2)*S, 2.5*S, 0, Math.PI*2);
  c.fillStyle = '#0a0a14'; c.fill();

  // Base / keyboard area
  c.fillStyle = pal.body;
  c.beginPath();
  c.moveTo(4*S, baseY*S);
  c.lineTo((dev.baseW-4)*S, baseY*S);
  c.lineTo((dev.baseW-2)*S, (baseY+3)*S);
  c.lineTo((dev.baseW-2)*S, (dev.baseH-6)*S);
  c.quadraticCurveTo((dev.baseW-2)*S, dev.baseH*S, (dev.baseW-8)*S, dev.baseH*S);
  c.lineTo(8*S, dev.baseH*S);
  c.quadraticCurveTo(2*S, dev.baseH*S, 2*S, (dev.baseH-6)*S);
  c.lineTo(2*S, (baseY+3)*S);
  c.closePath();
  c.fill();

  // Hinge line
  c.fillStyle = 'rgba(0,0,0,0.3)';
  c.fillRect(4*S, baseY*S, (dev.baseW-8)*S, 2*S);

  // Trackpad
  const tpW = 240, tpH = 80;
  const tpX = (dev.baseW - tpW)/2, tpY = baseY + baseH/2 - 10;
  rrPath(c, tpX*S, tpY*S, tpW*S, tpH*S, 6*S);
  c.strokeStyle = 'rgba(255,255,255,0.06)'; c.lineWidth = 0.5*S; c.stroke();
}

function drawAppleWatch(c, S, dev, pal) {
  // Body
  rrPath(c, 0, 0, dev.baseW*S, dev.baseH*S, dev.cornerR*S);
  const bg = c.createLinearGradient(0, 0, dev.baseW*S, 0);
  bg.addColorStop(0, pal.edge); bg.addColorStop(0.03, pal.body);
  bg.addColorStop(0.97, pal.body); bg.addColorStop(1, pal.edge);
  c.fillStyle = bg; c.fill();

  // Edge highlight
  rrPath(c, 0.5*S, 0.5*S, (dev.baseW-1)*S, (dev.baseH-1)*S, (dev.cornerR-0.5)*S);
  c.strokeStyle = 'rgba(255,255,255,0.1)'; c.lineWidth = 0.6*S; c.stroke();

  // Bezel
  rrPath(c, 10*S, 18*S, (dev.baseW-20)*S, (dev.baseH-36)*S, (dev.screenR+4)*S);
  c.fillStyle = pal.bezel; c.fill();

  // Screen cutout
  c.save();
  rrPath(c, dev.screenX*S, dev.screenY*S, dev.screenW*S, dev.screenH*S, dev.screenR*S);
  c.globalCompositeOperation = 'destination-out';
  c.fillStyle = '#000'; c.fill();
  c.restore();

  // Digital Crown (right side)
  rrPath(c, (dev.baseW-1)*S, 100*S, 6*S, 40*S, 3*S);
  c.fillStyle = pal.edge; c.fill();
  // Side button
  rrPath(c, (dev.baseW-0.5)*S, 160*S, 5*S, 24*S, 2*S);
  c.fillStyle = pal.edge; c.fill();
}

// ============================================================
// FRAME CACHE with LRU Management
// ============================================================
let frameCache = {};
let frameCacheMetadata = {}; // Track usage for LRU
const MAX_FRAME_CACHE_SIZE = 20; // Limit cache size

function getDeviceFrame(deviceId, colorKey) {
  const key = deviceId + '_' + colorKey;

  // Cache hit - update last used time
  if (frameCache[key]) {
    if (frameCacheMetadata[key]) {
      frameCacheMetadata[key].lastUsed = Date.now();
      frameCacheMetadata[key].useCount++;
    }
    return frameCache[key];
  }

  // Enforce cache size limit using LRU eviction
  if (Object.keys(frameCache).length >= MAX_FRAME_CACHE_SIZE) {
    evictLeastRecentlyUsedFrame();
  }

  // Cache miss - create new frame
  const dev = DEVICES[deviceId];
  if (!dev) {
    console.warn(`Device not found: ${deviceId}`);
    return null;
  }

  const pal = dev.colors[colorKey];
  if (!pal) {
    console.warn(`Color not found for device ${deviceId}: ${colorKey}`);
    return null;
  }

  const fc = document.createElement('canvas');
  fc.width = dev.baseW * RENDER_SCALE;
  fc.height = dev.baseH * RENDER_SCALE;
  const fCtx = fc.getContext('2d');

  try {
    dev.draw(fCtx, RENDER_SCALE, pal);
    frameCache[key] = fc;
    frameCacheMetadata[key] = {
      created: Date.now(),
      lastUsed: Date.now(),
      useCount: 1,
      size: fc.width * fc.height * 4 // Approximate memory in bytes
    };
    return fc;
  } catch (error) {
    console.error(`Error drawing device frame ${deviceId}:`, error);
    return null;
  }
}

// Evict least recently used frame
function evictLeastRecentlyUsedFrame() {
  const entries = Object.entries(frameCacheMetadata);
  if (entries.length === 0) return;

  // Sort by last used time (oldest first)
  entries.sort((a, b) => a[1].lastUsed - b[1].lastUsed);

  // Remove oldest frame
  const [keyToRemove] = entries[0];
  delete frameCache[keyToRemove];
  delete frameCacheMetadata[keyToRemove];
}

// Clear entire frame cache (call when device changes)
function clearFrameCache() {
  frameCache = {};
  frameCacheMetadata = {};
}

// Get cache statistics
function getFrameCacheStats() {
  const entries = Object.values(frameCacheMetadata);
  const totalSize = entries.reduce((sum, meta) => sum + meta.size, 0);
  const totalUses = entries.reduce((sum, meta) => sum + meta.useCount, 0);

  return {
    entries: entries.length,
    totalSizeMB: (totalSize / (1024 * 1024)).toFixed(2),
    totalUses,
    avgUsesPerFrame: entries.length > 0 ? (totalUses / entries.length).toFixed(1) : 0
  };
}

// Export cleanup for external use
if (typeof window !== 'undefined') {
  window.clearFrameCache = clearFrameCache;
  window.getFrameCacheStats = getFrameCacheStats;
}

// ============================================================

// LAYERS: TEXT
// ============================================================
document.getElementById('addTextBtn').addEventListener('click', () => {
  pushUndoState();
  const sz = getCanvasSize();
  const layer = {
    id: state.nextLayerId++,
    type: 'text',
    content: 'Title',
    x: sz.w / 2 - 50,
    y: 60,
    fontSize: 36,
    fontFamily: 'SF Pro Display, -apple-system, sans-serif',
    color: '#ffffff',
    weight: '700',
    align: 'left',
    shadow: 0,
    outline: 0,
  };
  state.layers.push(layer);
  state.selectedLayer = state.layers.length - 1;
  rebuildLayerList();
  showTextProps();
});

function showTextProps() {
  document.getElementById('textProps').style.display = 'block';
  document.getElementById('logoProps').style.display = 'none';
  const layer = state.layers[state.selectedLayer];
  if (!layer || layer.type !== 'text') return;
  document.getElementById('textContent').value = layer.content;
  document.getElementById('textSize').value = layer.fontSize;
  document.getElementById('textColor').value = layer.color;
  document.getElementById('textWeight').value = layer.weight;
  document.getElementById('textShadow').value = layer.shadow;
  document.getElementById('textOutline').value = layer.outline;
}

// Text property bindings
['textContent','textFont','textSize','textColor','textWeight','textShadow','textOutline'].forEach(id => {
  document.getElementById(id).addEventListener('input', e => {
    const layer = state.layers[state.selectedLayer];
    if (!layer || layer.type !== 'text') return;
    switch (id) {
      case 'textContent': layer.content = e.target.value; break;
      case 'textFont': layer.fontFamily = e.target.value; break;
      case 'textSize': layer.fontSize = parseInt(e.target.value); break;
      case 'textColor': layer.color = e.target.value; break;
      case 'textWeight': layer.weight = e.target.value; break;
      case 'textShadow': layer.shadow = parseInt(e.target.value); break;
      case 'textOutline': layer.outline = parseInt(e.target.value); break;
    }
  });
});

// ============================================================
// LAYERS: LOGO
// ============================================================
document.getElementById('addLogoBtn').addEventListener('click', () => logoInput.click());
logoInput.addEventListener('change', e => {
  const file = e.target.files[0];
  if (!file) return;
  pushUndoState();
  const img = new Image();
  img.onload = () => {
    const sz = getCanvasSize();
    const layer = {
      id: state.nextLayerId++,
      type: 'logo',
      img: img,
      fileName: file.name.replace(/\.[^.]+$/, ''),
      x: sz.w - 120,
      y: sz.h - 80,
      width: 100,
      opacity: 1,
    };
    state.layers.push(layer);
    state.selectedLayer = state.layers.length - 1;
    rebuildLayerList();
    showLogoProps();
  };
  img.src = URL.createObjectURL(file);
});

function showLogoProps() {
  document.getElementById('textProps').style.display = 'none';
  document.getElementById('logoProps').style.display = 'block';
  const layer = state.layers[state.selectedLayer];
  if (!layer || layer.type !== 'logo') return;
  document.getElementById('logoOpacity').value = layer.opacity * 100;
  document.getElementById('logoWidth').value = layer.width;
}

document.getElementById('logoOpacity').addEventListener('input', e => {
  const layer = state.layers[state.selectedLayer];
  if (layer && layer.type === 'logo') layer.opacity = parseInt(e.target.value) / 100;
});
document.getElementById('logoWidth').addEventListener('input', e => {
  const layer = state.layers[state.selectedLayer];
  if (layer && layer.type === 'logo') layer.width = parseInt(e.target.value);
});

// ============================================================
// UNIFIED LAYER PANEL
// ============================================================
const unifiedLayersEl = document.getElementById('unifiedLayers');
const layerDetailEl = document.getElementById('layerDetail');
const advStackEl = document.getElementById('advStack');

function isGroupActive(id) {
  switch (id) {
    case 'bgVideo': return state.bgVideo.enabled;
    case 'particles': return state.particles.enabled;
    case 'device': return true;
    case 'device2': return state.comparison.enabled && !!state.comparison.device2;
    case 'content': return state.layers.length > 0;
    case 'facecam': return state.facecam.enabled;
    case 'videoOverlays': return state.videoOverlays.length > 0;
    case 'uiOverlays': return state.waveform.enabled || state.progressBar.enabled || state.glassmorphism.enabled;
    default: return false;
  }
}

function getSystemLayerName(group) {
  if (group.id === 'device') {
    if (state.device.type === 'none') return 'Video (No Device)';
    const dev = DEVICES[state.device.type];
    return dev ? dev.name : 'Device';
  }
  if (group.id === 'device2' && state.comparison.device2) {
    const dev2 = DEVICES[state.comparison.device2.type];
    return dev2 ? dev2.name + ' (2)' : 'Device 2';
  }
  if (group.id === 'bgVideo') return 'Background Video';
  if (group.id === 'uiOverlays') {
    const parts = [];
    if (state.waveform.enabled) parts.push('Waveform');
    if (state.progressBar.enabled) parts.push('Progress');
    if (state.glassmorphism.enabled) parts.push('CTA');
    return parts.join(' + ') || 'UI Effects';
  }
  return group.name;
}

function getContentLayerName(layer) {
  if (layer.type === 'text') {
    const t = (layer.content || '').substring(0, 24);
    return t || 'Empty Text';
  }
  if (layer.type === 'logo') return layer.fileName || 'Logo';
  if (layer.type === 'annotation') {
    const typeNames = { arrow: 'Arrow', circle: 'Circle', rect: 'Rectangle', freehand: 'Freehand', callout: 'Callout' };
    return typeNames[layer.annoType] || 'Annotation';
  }
  return 'Layer';
}

function getContentLayerIcon(layer) {
  if (layer.type === 'text') return 'T';
  if (layer.type === 'logo') return '';
  if (layer.type === 'annotation') {
    const icons = { arrow: '', circle: '', rect: '', freehand: '', callout: '' };
    return icons[layer.annoType] || '';
  }
  return '';
}

// Build flat display list from render stack
function buildDisplayList() {
  const list = [];
  for (let i = state.renderStack.length - 1; i >= 0; i--) {
    const group = state.renderStack[i];
    if (!isGroupActive(group.id)) continue;

    if (group.id === 'content') {
      // Expand individual content layers
      for (let j = state.layers.length - 1; j >= 0; j--) {
        list.push({
          kind: 'content', groupIdx: i, layerIdx: j,
          name: getContentLayerName(state.layers[j]),
          icon: getContentLayerIcon(state.layers[j]),
          hidden: group.hidden || state.layers[j].visible === false,
        });
      }
    } else if (group.id === 'videoOverlays') {
      // Expand individual overlays
      for (let j = state.videoOverlays.length - 1; j >= 0; j--) {
        const ov = state.videoOverlays[j];
        list.push({
          kind: 'overlay', groupIdx: i, overlayIdx: j,
          name: ov.name || ov.builtin || 'Overlay',
          icon: '',
          hidden: group.hidden || ov.hidden === true,
        });
      }
    } else {
      list.push({
        kind: 'system', groupIdx: i, groupId: group.id,
        name: getSystemLayerName(group),
        icon: group.icon,
        isMain: group.id === 'device',
        hidden: group.hidden,
      });
    }
  }
  return list;
}

function rebuildUnifiedLayers() {
  const list = buildDisplayList();
  unifiedLayersEl.innerHTML = '';

  if (list.length <= 1 && !hasVideo && state.layers.length === 0) {
    unifiedLayersEl.innerHTML = '<div class="ul-empty">Drop a video to get started</div>';
    layerDetailEl.style.display = 'none';
    return;
  }

  list.forEach((item, di) => {
    const div = document.createElement('div');
    let cls = 'ul-item';
    if (item.isMain) cls += ' main-layer';
    if (item.hidden) cls += ' hidden-layer';
    if (item.kind === 'content' && item.layerIdx === state.selectedLayer) cls += ' selected';
    div.className = cls;

    // Eye toggle
    const eye = document.createElement('button');
    eye.className = 'ul-eye' + (item.hidden ? ' off' : '');
    eye.textContent = item.hidden ? '' : '';
    eye.title = item.hidden ? 'Show' : 'Hide';
    eye.addEventListener('click', e => {
      e.stopPropagation();
      if (item.kind === 'content') {
        const layer = state.layers[item.layerIdx];
        layer.visible = layer.visible === false ? true : false;
      } else if (item.kind === 'overlay') {
        const ov = state.videoOverlays[item.overlayIdx];
        if (ov) ov.hidden = !ov.hidden;
      } else {
        const g = state.renderStack[item.groupIdx];
        g.hidden = !g.hidden;
      }
      rebuildUnifiedLayers();
    });
    div.appendChild(eye);

    // Icon
    const icon = document.createElement('span');
    icon.className = 'ul-icon';
    icon.textContent = item.icon;
    div.appendChild(icon);

    // Name
    const name = document.createElement('span');
    name.className = 'ul-name';
    name.textContent = item.name;
    div.appendChild(name);

    // Main tag
    if (item.isMain) {
      const tag = document.createElement('span');
      tag.className = 'ul-tag';
      tag.textContent = 'main';
      div.appendChild(tag);
    }

    // Hover controls
    const controls = document.createElement('span');
    controls.className = 'ul-controls';

    // Find position in display list for system layer reordering
    function moveGroupInStack(groupIdx, direction) {
      // direction: +1 = up in visual (later in array), -1 = down in visual (earlier in array)
      const newIdx = groupIdx + direction;
      if (newIdx < 0 || newIdx >= state.renderStack.length) return;
      const [moved] = state.renderStack.splice(groupIdx, 1);
      state.renderStack.splice(newIdx, 0, moved);
      rebuildUnifiedLayers();
    }

    const upBtn = document.createElement('button');
    upBtn.className = 'ul-btn';
    upBtn.textContent = '';
    upBtn.title = 'Move forward';
    upBtn.addEventListener('click', e => {
      e.stopPropagation();
      if (item.kind === 'content') {
        if (item.layerIdx < state.layers.length - 1) {
          const arr = state.layers;
          [arr[item.layerIdx], arr[item.layerIdx + 1]] = [arr[item.layerIdx + 1], arr[item.layerIdx]];
          if (state.selectedLayer === item.layerIdx) state.selectedLayer = item.layerIdx + 1;
          else if (state.selectedLayer === item.layerIdx + 1) state.selectedLayer = item.layerIdx;
          rebuildUnifiedLayers();
        }
      } else if (item.kind === 'overlay') {
        if (item.overlayIdx < state.videoOverlays.length - 1) {
          const arr = state.videoOverlays;
          [arr[item.overlayIdx], arr[item.overlayIdx + 1]] = [arr[item.overlayIdx + 1], arr[item.overlayIdx]];
          rebuildUnifiedLayers();
        }
      } else if (item.kind === 'system') {
        // Moving "up" in visual = moving later in renderStack (higher index)
        moveGroupInStack(item.groupIdx, 1);
      }
    });

    const downBtn = document.createElement('button');
    downBtn.className = 'ul-btn';
    downBtn.textContent = '';
    downBtn.title = 'Move backward';
    downBtn.addEventListener('click', e => {
      e.stopPropagation();
      if (item.kind === 'content') {
        if (item.layerIdx > 0) {
          const arr = state.layers;
          [arr[item.layerIdx], arr[item.layerIdx - 1]] = [arr[item.layerIdx - 1], arr[item.layerIdx]];
          if (state.selectedLayer === item.layerIdx) state.selectedLayer = item.layerIdx - 1;
          else if (state.selectedLayer === item.layerIdx - 1) state.selectedLayer = item.layerIdx;
          rebuildUnifiedLayers();
        }
      } else if (item.kind === 'overlay') {
        if (item.overlayIdx > 0) {
          const arr = state.videoOverlays;
          [arr[item.overlayIdx], arr[item.overlayIdx - 1]] = [arr[item.overlayIdx - 1], arr[item.overlayIdx]];
          rebuildUnifiedLayers();
        }
      } else if (item.kind === 'system') {
        // Moving "down" in visual = moving earlier in renderStack (lower index)
        moveGroupInStack(item.groupIdx, -1);
      }
    });

    controls.appendChild(upBtn);
    controls.appendChild(downBtn);

    // Delete button only for content and overlay items (not system layers)
    if (item.kind === 'content' || item.kind === 'overlay') {
      const delBtn = document.createElement('button');
      delBtn.className = 'ul-btn del';
      delBtn.textContent = '';
      delBtn.title = 'Remove';
      delBtn.addEventListener('click', e => {
        e.stopPropagation();
        pushUndoState();
        if (item.kind === 'content') {
          state.layers.splice(item.layerIdx, 1);
          state.selectedLayer = Math.min(state.selectedLayer, state.layers.length - 1);
        } else if (item.kind === 'overlay') {
          state.videoOverlays.splice(item.overlayIdx, 1);
        }
        rebuildUnifiedLayers();
      });
      controls.appendChild(delBtn);
    }

    div.appendChild(controls);

    // Click to select (content layers)
    div.addEventListener('click', () => {
      if (item.kind === 'content') {
        state.selectedLayer = item.layerIdx;
        rebuildUnifiedLayers();
        const layer = state.layers[item.layerIdx];
        if (layer.type === 'text') showTextProps();
        else if (layer.type === 'logo') showLogoProps();
        else {
          document.getElementById('textProps').style.display = 'none';
          document.getElementById('logoProps').style.display = 'none';
        }
        showLayerDetail(item.layerIdx);
      } else {
        state.selectedLayer = -1;
        layerDetailEl.style.display = 'none';
        document.getElementById('textProps').style.display = 'none';
        document.getElementById('logoProps').style.display = 'none';
        document.getElementById('annoTimingControls').style.display = 'none';
        rebuildUnifiedLayers();
      }
    });

    unifiedLayersEl.appendChild(div);
  });
}

function showLayerDetail(idx) {
  const layer = state.layers[idx];
  if (!layer) { layerDetailEl.style.display = 'none'; return; }
  layerDetailEl.style.display = 'block';

  const opVal = Math.round((layer.opacity !== undefined ? layer.opacity : 1) * 100);
  let html = `<div class="detail-row"><label>Opacity</label><input type="range" id="detailOpacity" min="0" max="100" value="${opVal}"><span id="detailOpacityVal">${opVal}%</span></div>`;
  if (layer.type === 'text') {
    html += `<div class="detail-row"><label>Size</label><input type="range" id="detailFontSize" min="10" max="200" value="${layer.fontSize}"><span id="detailFontSizeVal">${layer.fontSize}px</span></div>`;
  }
  layerDetailEl.innerHTML = html;

  // Opacity control
  const opSlider = document.getElementById('detailOpacity');
  if (opSlider) {
    opSlider.addEventListener('input', e => {
      const v = parseInt(e.target.value);
      document.getElementById('detailOpacityVal').textContent = v + '%';
      if (layer.type === 'logo') layer.opacity = v / 100;
      else if (layer.type === 'text') layer.opacity = v / 100;
    });
  }
  // Font size control
  const fsSlider = document.getElementById('detailFontSize');
  if (fsSlider) {
    fsSlider.addEventListener('input', e => {
      const v = parseInt(e.target.value);
      document.getElementById('detailFontSizeVal').textContent = v + 'px';
      layer.fontSize = v;
    });
  }

  // Show/hide annotation timing controls
  updateAnnoTimingControls(layer);
}

// ---- Advanced Render Order panel ----
function rebuildAdvStack() {
  advStackEl.innerHTML = '';
  const stackReversed = [...state.renderStack].reverse();
  stackReversed.forEach((group, ri) => {
    const actualIdx = state.renderStack.length - 1 - ri;
    const active = isGroupActive(group.id);
    const div = document.createElement('div');
    div.className = 'adv-item' + (active ? ' active' : '');
    div.dataset.idx = actualIdx;
    div.draggable = true;
    div.innerHTML = `<span class="adv-drag"></span><span class="adv-icon">${group.icon}</span><span class="adv-name">${group.name}</span>`;
    div.addEventListener('dragstart', e => {
      e.dataTransfer.effectAllowed = 'move';
      e.dataTransfer.setData('text/plain', actualIdx);
      div.classList.add('dragging');
    });
    div.addEventListener('dragend', () => {
      div.classList.remove('dragging');
      advStackEl.querySelectorAll('.adv-item').forEach(el => el.classList.remove('drag-over'));
    });
    div.addEventListener('dragover', e => { e.preventDefault(); div.classList.add('drag-over'); });
    div.addEventListener('dragleave', () => div.classList.remove('drag-over'));
    div.addEventListener('drop', e => {
      e.preventDefault();
      div.classList.remove('drag-over');
      const fromIdx = parseInt(e.dataTransfer.getData('text/plain'));
      if (fromIdx === actualIdx) return;
      const [moved] = state.renderStack.splice(fromIdx, 1);
      state.renderStack.splice(actualIdx, 0, moved);
      rebuildAdvStack();
      rebuildUnifiedLayers();
    });
    advStackEl.appendChild(div);
  });
}

// Advanced panel toggle
document.getElementById('advLayerToggle').addEventListener('click', () => {
  const panel = document.getElementById('advLayerPanel');
  const visible = panel.style.display !== 'none';
  panel.style.display = visible ? 'none' : 'block';
  document.getElementById('advLayerToggle').textContent = visible ? 'Advanced Render Order' : 'Hide Advanced';
  if (!visible) rebuildAdvStack();
});

// Quick-add buttons
document.getElementById('quickAddText').addEventListener('click', () => {
  document.getElementById('addTextBtn').click();
});
document.getElementById('quickAddLogo').addEventListener('click', () => {
  document.getElementById('addLogoBtn').click();
});

// Periodic refresh
rebuildUnifiedLayers();
let _lastLayerHash = '';
setInterval(() => {
  const hash = state.renderStack.map(g => g.id + (g.hidden?'h':'')).join(',') + '|' +
    state.layers.map(l => (l.visible===false?'h':'') + l.type + (l.content||'').substring(0,10)).join(',') + '|' +
    state.videoOverlays.map(o => (o.hidden?'h':'') + (o.name||o.builtin||'')).join(',') + '|' + state.selectedLayer + '|' +
    (state.device.type) + '|' + state.comparison.enabled + '|' +
    state.bgVideo.enabled + '|' + state.particles.enabled + '|' +
    state.facecam.enabled + '|' + state.waveform.enabled + '|' +
    state.progressBar.enabled + '|' + state.glassmorphism.enabled;
  if (hash !== _lastLayerHash) {
    _lastLayerHash = hash;
    rebuildUnifiedLayers();
  }
}, 500);

// ============================================================
// LAYER LIST (backwards compat  hidden, still used internally)
// ============================================================
function rebuildLayerList() {
  // The visible unified panel handles display now
  rebuildUnifiedLayers();
}

// ============================================================
// DRAGGING LAYERS ON CANVAS
// ============================================================
let dragLayer = null;
let dragOffset = { x: 0, y: 0 };

canvas.addEventListener('mousedown', e => {
  if (state.annotation.tool) return; // annotation mode
  const rect = canvas.getBoundingClientRect();
  const scaleX = canvas.width / rect.width;
  const scaleY = canvas.height / rect.height;
  const mx = (e.clientX - rect.left) * scaleX;
  const my = (e.clientY - rect.top) * scaleY;

  // Hit test layers (reverse order)
  for (let i = state.layers.length - 1; i >= 0; i--) {
    const layer = state.layers[i];
    let hit = false;
    if (layer.type === 'text') {
      const w = ctx.measureText(layer.content).width || (layer.fontSize * layer.content.length * 0.6);
      hit = mx >= layer.x - 5 && mx <= layer.x + w + 5 && my >= layer.y - 5 && my <= layer.y + layer.fontSize + 5;
    } else if (layer.type === 'logo' && layer.img) {
      const aspect = layer.img.naturalWidth / layer.img.naturalHeight;
      const lh = layer.width / aspect;
      hit = mx >= layer.x && mx <= layer.x + layer.width && my >= layer.y && my <= layer.y + lh;
    }
    if (hit) {
      dragLayer = layer;
      dragOffset.x = mx - layer.x;
      dragOffset.y = my - layer.y;
      state.selectedLayer = i;
      rebuildLayerList();
      if (layer.type === 'text') showTextProps();
      else if (layer.type === 'logo') showLogoProps();
      e.preventDefault();
      return;
    }
  }
  // If no layer hit and has video, toggle playback
  if (hasVideo && !state.annotation.tool) {
    vtToggle();
  }
});

canvas.addEventListener('mousemove', e => {
  if (!dragLayer) return;
  const rect = canvas.getBoundingClientRect();
  const scaleX = canvas.width / rect.width;
  const scaleY = canvas.height / rect.height;
  dragLayer.x = (e.clientX - rect.left) * scaleX - dragOffset.x;
  dragLayer.y = (e.clientY - rect.top) * scaleY - dragOffset.y;
});

document.addEventListener('mouseup', () => { dragLayer = null; });

// Double-click to edit text inline
canvas.addEventListener('dblclick', e => {
  const layer = state.layers[state.selectedLayer];
  if (!layer || layer.type !== 'text') return;
  const newText = prompt('Edit text:', layer.content);
  if (newText !== null) {
    layer.content = newText;
    document.getElementById('textContent').value = newText;
    rebuildLayerList();
  }
});

// ============================================================

// ANNOTATIONS
// ============================================================
let annoDrawing = false;
let annoPoints = [];

document.getElementById('annoToolbar').addEventListener('click', e => {
  const btn = e.target.closest('.anno-btn');
  if (!btn) return;
  const tool = btn.dataset.tool;
  if (state.annotation.tool === tool) {
    state.annotation.tool = null;
    btn.classList.remove('active');
    canvas.style.cursor = 'pointer';
  } else {
    state.annotation.tool = tool;
    document.querySelectorAll('.anno-btn').forEach(b => b.classList.remove('active'));
    btn.classList.add('active');
    canvas.style.cursor = 'crosshair';
  }
});

document.getElementById('annoColor').addEventListener('input', e => { state.annotation.color = e.target.value; });
document.getElementById('annoWidth').addEventListener('input', e => { state.annotation.width = parseInt(e.target.value); });

canvas.addEventListener('mousedown', e => {
  if (!state.annotation.tool) return;
  const rect = canvas.getBoundingClientRect();
  const sx = canvas.width / rect.width;
  const sy = canvas.height / rect.height;
  const mx = (e.clientX - rect.left) * sx;
  const my = (e.clientY - rect.top) * sy;
  annoDrawing = true;
  annoPoints = [{ x: mx, y: my }];
  e.preventDefault();
  e.stopPropagation();
}, true);

canvas.addEventListener('mousemove', e => {
  if (!annoDrawing || !state.annotation.tool) return;
  const rect = canvas.getBoundingClientRect();
  const sx = canvas.width / rect.width;
  const sy = canvas.height / rect.height;
  const mx = (e.clientX - rect.left) * sx;
  const my = (e.clientY - rect.top) * sy;

  if (state.annotation.tool === 'freehand') {
    annoPoints.push({ x: mx, y: my });
  } else {
    if (annoPoints.length > 1) annoPoints.pop();
    annoPoints.push({ x: mx, y: my });
  }

  // Live preview: draw temp annotation
  // (will be rendered next frame since we store temp in a special way)
}, true);

canvas.addEventListener('mouseup', e => {
  if (!annoDrawing || !state.annotation.tool) return;
  annoDrawing = false;
  pushUndoState();

  const currentTime = hasVideo ? vtTime : 0;
  const totalDur = vtGetTotalDuration() || Infinity;
  const remaining = totalDur - currentTime;
  const defaultEnd = remaining < 5 ? totalDur : currentTime + 5;
  const layer = {
    id: state.nextLayerId++,
    type: 'annotation',
    annoType: state.annotation.tool,
    points: [...annoPoints],
    color: state.annotation.color,
    lineWidth: state.annotation.width,
    content: state.annotation.tool === 'callout' ? 'Note' : '',
    startTime: currentTime,
    endTime: defaultEnd,
  };
  state.layers.push(layer);
  rebuildLayerList();
  annoPoints = [];
}, true);

// ---- Annotation timing controls ----
const annoTimingEl = document.getElementById('annoTimingControls');
const annoStartInput = document.getElementById('annoStartTime');
const annoEndInput = document.getElementById('annoEndTime');
const annoDurationEl = document.getElementById('annoDuration');
const annoFullVideoCb = document.getElementById('annoFullVideo');
let annoTimingLayer = null;

function updateAnnoTimingControls(layer) {
  if (!layer || layer.type !== 'annotation') {
    annoTimingEl.style.display = 'none';
    annoTimingLayer = null;
    return;
  }
  annoTimingLayer = layer;
  annoTimingEl.style.display = 'block';
  const isFullVideo = layer.startTime === 0 && layer.endTime === Infinity;
  annoFullVideoCb.checked = isFullVideo;
  annoStartInput.value = isFullVideo ? 0 : layer.startTime.toFixed(1);
  annoEndInput.value = isFullVideo ? '' : (layer.endTime === Infinity ? '' : layer.endTime.toFixed(1));
  annoStartInput.disabled = isFullVideo;
  annoEndInput.disabled = isFullVideo;
  const dur = layer.endTime === Infinity ? 'Full' : (layer.endTime - layer.startTime).toFixed(1) + 's';
  annoDurationEl.textContent = dur;
}

annoStartInput.addEventListener('change', () => {
  if (!annoTimingLayer) return;
  pushUndoState();
  annoTimingLayer.startTime = Math.max(0, parseFloat(annoStartInput.value) || 0);
  const dur = annoTimingLayer.endTime === Infinity ? 'Full' : (annoTimingLayer.endTime - annoTimingLayer.startTime).toFixed(1) + 's';
  annoDurationEl.textContent = dur;
  rebuildTimeline();
});

annoEndInput.addEventListener('change', () => {
  if (!annoTimingLayer) return;
  pushUndoState();
  annoTimingLayer.endTime = Math.max(annoTimingLayer.startTime + 0.1, parseFloat(annoEndInput.value) || 0);
  const dur = (annoTimingLayer.endTime - annoTimingLayer.startTime).toFixed(1) + 's';
  annoDurationEl.textContent = dur;
  rebuildTimeline();
});

annoFullVideoCb.addEventListener('change', () => {
  if (!annoTimingLayer) return;
  pushUndoState();
  if (annoFullVideoCb.checked) {
    annoTimingLayer.startTime = 0;
    annoTimingLayer.endTime = Infinity;
  } else {
    const currentTime = hasVideo ? vtTime : 0;
    annoTimingLayer.startTime = currentTime;
    annoTimingLayer.endTime = currentTime + 5;
  }
  updateAnnoTimingControls(annoTimingLayer);
  rebuildTimeline();
});

// ============================================================

// FACECAM
// ============================================================
function ensureFacecamVideo() {
  let fcv = document.getElementById('facecamVideo');
  if (!fcv) {
    fcv = document.createElement('video');
    fcv.id = 'facecamVideo';
    fcv.style.display = 'none';
    fcv.autoplay = true;
    fcv.muted = true;
    fcv.loop = true;
    fcv.playsInline = true;
    document.body.appendChild(fcv);
  }
  return fcv;
}

function enableFacecam() {
  state.facecam.enabled = true;
  state.facecam.x = -1; state.facecam.y = -1; // reset to corner default
  document.getElementById('facecamProps').style.display = 'block';
}

function disableFacecam() {
  state.facecam.enabled = false;
  if (state.facecam.stream && state.facecam.source === 'camera') {
    state.facecam.stream.getTracks().forEach(t => t.stop());
  }
  state.facecam.stream = null;
  document.getElementById('facecamProps').style.display = 'none';
  const fcv = document.getElementById('facecamVideo');
  if (fcv) { fcv.pause(); fcv.srcObject = null; fcv.src = ''; fcv.remove(); }
}

// Webcam button
document.getElementById('facecamBtn').addEventListener('click', async function() {
  if (state.facecam.enabled) { disableFacecam(); return; }
  try {
    const stream = await navigator.mediaDevices.getUserMedia({ video: true });
    state.facecam.source = 'camera';
    state.facecam.stream = stream;
    const fcv = ensureFacecamVideo();
    fcv.srcObject = stream;
    fcv.loop = false;
    enableFacecam();
  } catch (err) {
    alert('Could not access camera: ' + err.message);
  }
});

// Video file button
document.getElementById('facecamFileBtn').addEventListener('click', () => {
  document.getElementById('facecamFileInput').click();
});
document.getElementById('facecamFileInput').addEventListener('change', e => {
  const file = e.target.files[0];
  if (!file) return;
  if (state.facecam.enabled) disableFacecam();
  state.facecam.source = 'file';
  state.facecam.stream = { getTracks: () => [] }; // placeholder so render check passes
  const fcv = ensureFacecamVideo();
  fcv.srcObject = null;
  fcv.src = URL.createObjectURL(file);
  fcv.loop = true;
  fcv.load();
  fcv.play().catch(() => { fcv.muted = true; fcv.play(); });
  enableFacecam();
});

// Disable button
document.getElementById('facecamDisableBtn').addEventListener('click', () => { disableFacecam(); });

// Controls
document.getElementById('facecamSize').addEventListener('input', e => {
  state.facecam.size = parseInt(e.target.value) / 100;
  state.facecam.x = -1; state.facecam.y = -1; // recalculate position
  document.getElementById('facecamSizeVal').textContent = e.target.value + '%';
});
document.getElementById('facecamCorner').addEventListener('change', e => {
  state.facecam.corner = e.target.value;
  state.facecam.x = -1; state.facecam.y = -1; // recalculate position
});
document.getElementById('facecamShape').addEventListener('change', e => { state.facecam.shape = e.target.value; });
document.getElementById('facecamBorderColor').addEventListener('input', e => { state.facecam.borderColor = e.target.value; });
document.getElementById('facecamBorderWidth').addEventListener('input', e => { state.facecam.borderWidth = parseInt(e.target.value); });
document.getElementById('facecamShadow').addEventListener('change', e => { state.facecam.shadow = e.target.value === 'true'; });

// Dragging facecam on canvas
let draggingFacecam = false;
let fcDragOffset = { x: 0, y: 0 };

canvas.addEventListener('mousedown', e => {
  if (!state.facecam.enabled || !state.facecam.stream) return;
  const rect = canvas.getBoundingClientRect();
  const sx = canvas.width / rect.width;
  const sy = canvas.height / rect.height;
  const mx = (e.clientX - rect.left) * sx;
  const my = (e.clientY - rect.top) * sy;
  const sz2 = Math.round(Math.min(canvas.width, canvas.height) * state.facecam.size);
  const fx = state.facecam.x, fy = state.facecam.y;
  if (fx < 0 || fy < 0) return;
  // Hit test
  const cx = fx + sz2/2, cy = fy + sz2/2;
  const dist = Math.sqrt((mx-cx)**2 + (my-cy)**2);
  if (dist <= sz2/2 + 10) {
    draggingFacecam = true;
    fcDragOffset.x = mx - fx;
    fcDragOffset.y = my - fy;
    e.preventDefault();
    e.stopPropagation();
  }
}, true);

canvas.addEventListener('mousemove', e => {
  if (!draggingFacecam) return;
  const rect = canvas.getBoundingClientRect();
  const sx = canvas.width / rect.width;
  const sy = canvas.height / rect.height;
  state.facecam.x = (e.clientX - rect.left) * sx - fcDragOffset.x;
  state.facecam.y = (e.clientY - rect.top) * sy - fcDragOffset.y;
  // Switch to custom corner mode
  document.getElementById('facecamCorner').value = 'custom';
  state.facecam.corner = 'custom';
}, true);

document.addEventListener('mouseup', () => { draggingFacecam = false; }, true);

// ============================================================

// SCREENSHOT
// ============================================================
ssBtn.addEventListener('click', () => {
  const a = document.createElement('a');
  a.download = 'mockup-' + Date.now() + '.png';
  a.href = canvas.toDataURL('image/png');
  a.click();
  showToast('Screenshot saved', 'success');
});

// ============================================================
// THUMBNAIL
// ============================================================
thumbBtn.addEventListener('click', () => {
  if (!hasVideo) return;
  vtPause();
  // Render at preset size
  const sz = getCanvasSize();
  const thumbCanvas = document.createElement('canvas');
  thumbCanvas.width = sz.w;
  thumbCanvas.height = sz.h;
  const tCtx = thumbCanvas.getContext('2d');
  tCtx.drawImage(canvas, 0, 0, sz.w, sz.h);
  const a = document.createElement('a');
  a.download = 'thumbnail-' + Date.now() + '.png';
  a.href = thumbCanvas.toDataURL('image/png');
  a.click();
  showToast('Thumbnail saved', 'success');
});

// ============================================================
// VIDEO EXPORT
// ============================================================
let recorder = null;
let destNode = null;

const exportDialog = document.getElementById('exportDialog');
const edResolution = document.getElementById('edResolution');
const edQuality = document.getElementById('edQuality');
const edFramerate = document.getElementById('edFramerate');
const edAudio = document.getElementById('edAudio');
const edEstimate = document.getElementById('edEstimate');
const edFormat = document.getElementById('edFormat');
const edFormatNote = document.getElementById('edFormatNote');

function updateExportEstimate() {
  const sz = getCanvasSize();
  let w = sz.w, h = sz.h;
  const res = edResolution.value;
  if (res === '1080') { const s = 1080 / Math.max(w, h); w = Math.round(w * s); h = Math.round(h * s); }
  else if (res === '720') { const s = 720 / Math.max(w, h); w = Math.round(w * s); h = Math.round(h * s); }
  // Ensure even dimensions
  w = w % 2 === 0 ? w : w + 1;
  h = h % 2 === 0 ? h : h + 1;
  const totalDur = vtGetTotalDuration();
  const dur = totalDur ? (totalDur / state.timeline.speed).toFixed(1) : '?';
  edEstimate.textContent = '~' + dur + 's of video at ' + w + '\u00d7' + h + '  ' + edFramerate.value + ' fps';
}

function openExportDialog() {
  updateExportEstimate();
  const mp4Option = edFormat.querySelector('option[value="mp4"]');
  if (typeof VideoEncoder === 'undefined') {
    mp4Option.disabled = true;
    mp4Option.textContent = 'MP4 (not supported)';
  } else {
    mp4Option.disabled = false;
    mp4Option.textContent = 'MP4 (H.264) \u2605 Recommended';
  }
  if (edFormat.value === 'mp4' && typeof VideoEncoder !== 'undefined') {
    edFormatNote.textContent = 'H.264 via WebCodecs \u2014 best compatibility for sharing.';
    edFormatNote.style.color = '#888';
    edFormatNote.style.display = 'block';
  } else {
    edFormatNote.style.display = 'none';
  }
  exportDialog.classList.add('open');
}

function closeExportDialog() {
  exportDialog.classList.remove('open');
}

edResolution.addEventListener('change', updateExportEstimate);
edFramerate.addEventListener('change', updateExportEstimate);
edQuality.addEventListener('change', updateExportEstimate);
edFormat.addEventListener('change', () => {
  if (edFormat.value === 'mp4') {
    if (typeof VideoEncoder === 'undefined') {
      edFormatNote.textContent = '\u26a0 MP4 export requires WebCodecs API (Chrome 94+). Use WebM instead.';
      edFormatNote.style.color = '#e55';
      edFormatNote.style.display = 'block';
      edFormat.value = 'webm';
    } else {
      edFormatNote.textContent = 'H.264 via WebCodecs \u2014 best compatibility for sharing.';
      edFormatNote.style.color = '#888';
      edFormatNote.style.display = 'block';
    }
  } else {
    edFormatNote.style.display = 'none';
  }
  updateExportEstimate();
});
document.getElementById('edCancel').addEventListener('click', closeExportDialog);
exportDialog.addEventListener('click', e => { if (e.target === exportDialog) closeExportDialog(); });

exportBtn.addEventListener('click', () => {
  if (!hasVideo) return;
  if (isExporting) { stopExport(); return; }
  openExportDialog();
});

document.getElementById('edStart').addEventListener('click', () => {
  closeExportDialog();
  startExport();
});

function startExport() {
  if (edFormat.value === 'mp4') { startMp4Export(); return; }
  isExporting = true;
  exportBtn.textContent = 'Stop';
  exportBtn.classList.add('recording');
  exportStatus.classList.add('visible');
  exportText.textContent = 'Preparing...';
  exportBarFill.style.width = '0%';

  // Read settings from dialog
  const bitrate = parseInt(edQuality.value);
  const fps = parseInt(edFramerate.value);
  const includeAudio = edAudio.checked;

  const origSz = getCanvasSize();
  let expW = origSz.w, expH = origSz.h;
  const res = edResolution.value;
  if (res === '1080') { const s = 1080 / Math.max(expW, expH); expW = Math.round(expW * s); expH = Math.round(expH * s); }
  else if (res === '720') { const s = 720 / Math.max(expW, expH); expW = Math.round(expW * s); expH = Math.round(expH * s); }
  // Ensure even dimensions for codec compatibility
  expW = expW % 2 === 0 ? expW : expW + 1;
  expH = expH % 2 === 0 ? expH : expH + 1;

  // Create export canvas at target resolution
  const exportCanvas = document.createElement('canvas');
  exportCanvas.width = expW;
  exportCanvas.height = expH;
  const eCtx = exportCanvas.getContext('2d');

  let exportRAF;
  function exportLoop() {
    eCtx.clearRect(0, 0, expW, expH);
    eCtx.drawImage(canvas, 0, 0, expW, expH);
    if (isExporting) exportRAF = requestAnimationFrame(exportLoop);
  }
  exportLoop();

  // Capture stream at target framerate
  const expStream = exportCanvas.captureStream(fps);

  // Audio (uses shared AudioContext singleton)
  if (includeAudio) {
    try {
      var _actx = getSharedAudioContext();
      var _srcNode = getSharedSourceNode();
      destNode = _actx.createMediaStreamDestination();
      _srcNode.disconnect();
      _srcNode.connect(destNode);
      _srcNode.connect(_actx.destination);
      if (audioAnalyser) _srcNode.connect(audioAnalyser);
      for (const t of destNode.stream.getAudioTracks()) expStream.addTrack(t);
    } catch (err) { console.log('Audio capture skipped:', err.message); }
  }

  let mime = 'video/webm;codecs=vp9,opus';
  if (!MediaRecorder.isTypeSupported(mime)) mime = 'video/webm;codecs=vp8,opus';
  if (!MediaRecorder.isTypeSupported(mime)) mime = 'video/webm';

  const chunks = [];
  recorder = new MediaRecorder(expStream, { mimeType: mime, videoBitsPerSecond: bitrate });
  recorder.ondataavailable = e => { if (e.data.size) chunks.push(e.data); };

  recorder.onstop = () => {
    const blob = new Blob(chunks, { type: 'video/webm' });
    const a = document.createElement('a');
    a.download = 'mockup-' + Date.now() + '.webm';
    a.href = URL.createObjectURL(blob);
    a.click();
    isExporting = false;
    exportBtn.textContent = 'Export';
    exportBtn.classList.remove('recording');
    exportStatus.classList.remove('visible');
    if (exportRAF) cancelAnimationFrame(exportRAF);
    reconnectAudioGraph();
    showToast('Export complete  WebM downloaded', 'success');

    // Show success animation
    const exportSuccess = document.getElementById('exportSuccess');
    if (exportSuccess) {
      exportSuccess.style.display = 'flex';
      setTimeout(() => {
        exportSuccess.style.display = 'none';
      }, 2500);
    }
  };

  // Play from start of virtual timeline
  vtSeek(0);
  vtPlay();
  recorder.start(100);
  exportText.textContent = 'Recording...';
  showToast('Recording started...', 'info');

  const exportTotalDur = vtGetTotalDuration();
  const poll = setInterval(() => {
    if (!isExporting) { clearInterval(poll); return; }
    const p = Math.min(100, vtTime / exportTotalDur * 100);
    exportBarFill.style.width = p + '%';
    exportText.textContent = 'Exporting... ' + Math.round(p) + '%';
    // Check if timeline finished
    if (vtTime >= exportTotalDur - 0.05 && !vtPlaying) {
      clearInterval(poll);
      setTimeout(() => stopExport(), 400);
    }
  }, 250);
}

function stopExport() {
  if (recorder && recorder.state !== 'inactive') recorder.stop();
  vtPause();
  isExporting = false;
}

async function startMp4Export() {
  if (typeof VideoEncoder === 'undefined') {
    showToast('MP4 export requires WebCodecs API (Chrome 94+)', 'error');
    return;
  }

  isExporting = true;
  exportBtn.textContent = 'Stop';
  exportBtn.classList.add('recording');
  exportStatus.classList.add('visible');
  exportText.textContent = 'Preparing MP4...';
  exportBarFill.style.width = '0%';

  const bitrate = parseInt(edQuality.value);
  const fps = parseInt(edFramerate.value);
  const includeAudio = edAudio.checked;

  const origSz = getCanvasSize();
  let expW = origSz.w, expH = origSz.h;
  const res = edResolution.value;
  if (res === '1080') { const s = 1080 / Math.max(expW, expH); expW = Math.round(expW * s); expH = Math.round(expH * s); }
  else if (res === '720') { const s = 720 / Math.max(expW, expH); expW = Math.round(expW * s); expH = Math.round(expH * s); }
  expW = expW % 2 === 0 ? expW : expW + 1;
  expH = expH % 2 === 0 ? expH : expH + 1;

  const exportCanvas = document.createElement('canvas');
  exportCanvas.width = expW;
  exportCanvas.height = expH;
  const eCtx = exportCanvas.getContext('2d');

  if (typeof Mp4Muxer === 'undefined') {
    console.error('Mp4Muxer is not defined. MP4 export is unavailable. Please check your internet connection.');
    return;
  }

  // Configure mp4-muxer (uses shared AudioContext singleton)
  var mp4AudioCtx = null;
  const muxerOpts = {
    target: new Mp4Muxer.ArrayBufferTarget(),
    video: { codec: 'avc', width: expW, height: expH },
    fastStart: 'in-memory'
  };

  // Audio setup
  let audioEncoder = null;
  let scriptProcessor = null;
  let audioTimestamp = 0;

  if (includeAudio) {
    try {
      mp4AudioCtx = getSharedAudioContext();
      muxerOpts.audio = { codec: 'aac', numberOfChannels: 2, sampleRate: mp4AudioCtx.sampleRate };
    } catch (err) {
      console.log('MP4 audio context skipped:', err.message);
    }
  }

  const muxer = new Mp4Muxer.Muxer(muxerOpts);

  // Video encoder
  const videoEncoder = new VideoEncoder({
    output: (chunk, meta) => muxer.addVideoChunk(chunk, meta),
    error: (e) => console.error('VideoEncoder error:', e)
  });
  videoEncoder.configure({
    codec: 'avc1.42001f',
    width: expW,
    height: expH,
    bitrate: bitrate,
    framerate: fps
  });

  // Audio encoder
  if (muxerOpts.audio) {
    try {
      audioEncoder = new AudioEncoder({
        output: (chunk, meta) => muxer.addAudioChunk(chunk, meta),
        error: (e) => console.error('AudioEncoder error:', e)
      });
      audioEncoder.configure({
        codec: 'mp4a.40.2',
        numberOfChannels: 2,
        sampleRate: mp4AudioCtx.sampleRate,
        bitrate: 128000
      });

      scriptProcessor = mp4AudioCtx.createScriptProcessor(4096, 2, 2);

      // Connect audio source (shared singleton)
      var mp4SrcNode = getSharedSourceNode();
      mp4SrcNode.disconnect();
      mp4SrcNode.connect(scriptProcessor);
      mp4SrcNode.connect(mp4AudioCtx.destination);
      if (audioAnalyser) mp4SrcNode.connect(audioAnalyser);
      scriptProcessor.connect(mp4AudioCtx.destination);

      audioTimestamp = 0;
      scriptProcessor.onaudioprocess = (e) => {
        if (!isExporting || !audioEncoder) return;
        const nf = e.inputBuffer.length;
        const ch0 = e.inputBuffer.getChannelData(0);
        const ch1 = e.inputBuffer.numberOfChannels > 1 ? e.inputBuffer.getChannelData(1) : ch0;
        const data = new Float32Array(nf * 2);
        data.set(ch0, 0);
        data.set(ch1, nf);
        try {
          const audioData = new AudioData({
            format: 'f32-planar',
            sampleRate: mp4AudioCtx.sampleRate,
            numberOfFrames: nf,
            numberOfChannels: 2,
            timestamp: audioTimestamp,
            data: data
          });
          audioEncoder.encode(audioData);
          audioData.close();
          audioTimestamp += (nf / mp4AudioCtx.sampleRate) * 1_000_000;
        } catch (err) { /* skip frame */ }
      };
    } catch (err) {
      console.log('MP4 audio encoder skipped:', err.message);
      audioEncoder = null;
    }
  }

  // Play timeline from start
  vtSeek(0);
  vtPlay();

  const totalDur = vtGetTotalDuration();
  const exportStart = performance.now();
  let frameCount = 0;
  let lastCaptureTime = -1;
  const frameInterval = 1 / fps;
  let finalized = false;

  exportText.textContent = 'Encoding MP4...';
  showToast('MP4 export started...', 'info');

  function captureLoop() {
    if (!isExporting || finalized) {
      if (!finalized) finalize();
      return;
    }

    // Capture at target fps intervals
    if (vtTime - lastCaptureTime >= frameInterval || lastCaptureTime < 0) {
      eCtx.clearRect(0, 0, expW, expH);
      eCtx.drawImage(canvas, 0, 0, expW, expH);

      const timestamp = frameCount * (1_000_000 / fps);
      const frame = new VideoFrame(exportCanvas, { timestamp });
      videoEncoder.encode(frame, { keyFrame: frameCount % (fps * 2) === 0 });
      frame.close();
      frameCount++;
      lastCaptureTime = vtTime;

      // Progress with elapsed time, frames, estimated size
      const p = Math.min(100, vtTime / totalDur * 100);
      const elapsed = ((performance.now() - exportStart) / 1000).toFixed(1);
      const estSize = (frameCount * bitrate / fps / 8 / 1024 / 1024).toFixed(1);
      exportBarFill.style.width = p + '%';
      exportText.textContent = 'MP4: ' + Math.round(p) + '% \u00b7 ' + frameCount + ' frames \u00b7 ' + elapsed + 's \u00b7 ~' + estSize + 'MB';
    }

    // Check if timeline finished
    if (vtTime >= totalDur - 0.05 && !vtPlaying) {
      finalize();
      return;
    }

    requestAnimationFrame(captureLoop);
  }

  requestAnimationFrame(captureLoop);

  async function finalize() {
    if (finalized) return;
    finalized = true;
    exportText.textContent = 'Finalizing MP4...';

    try {
      await videoEncoder.flush();
      videoEncoder.close();
      if (audioEncoder) {
        await audioEncoder.flush();
        audioEncoder.close();
      }
      if (scriptProcessor) {
        scriptProcessor.disconnect();
        scriptProcessor.onaudioprocess = null;
      }
      reconnectAudioGraph();
      muxer.finalize();

      const buffer = muxer.target.buffer;
      const blob = new Blob([buffer], { type: 'video/mp4' });
      const a = document.createElement('a');
      a.download = 'mockup-' + Date.now() + '.mp4';
      a.href = URL.createObjectURL(blob);
      a.click();
      showToast('Export complete \u2014 MP4 downloaded', 'success');

      // Show success animation
      const exportSuccess = document.getElementById('exportSuccess');
      if (exportSuccess) {
        exportSuccess.style.display = 'flex';
        setTimeout(() => {
          exportSuccess.style.display = 'none';
        }, 2500);
      }
    } catch (err) {
      console.error('MP4 finalize error:', err);
      showToast('MP4 export failed: ' + err.message, 'error');
    }

    isExporting = false;
    exportBtn.textContent = 'Export';
    exportBtn.classList.remove('recording');
    exportStatus.classList.remove('visible');
    vtPause();
  }
}

// ============================================================

// ASSET BROWSER
// ============================================================
const assetBrowser = document.getElementById('assetBrowser');
const abSidebar = document.getElementById('abSidebar');
const abContent = document.getElementById('abContent');
const abEmpty = document.getElementById('abEmpty');
const abSearch = document.getElementById('abSearch');

let abDirHandle = null;
let abIndex = []; // { path, name, type, ext, handle, parentPath, url }
let abFolders = []; // { path, name, count, icon }
let abCurrentFolder = '';
let abSearchTerm = '';
let abSource = ''; // 'server', 'folder', or ''
const abStatus = document.getElementById('abStatus');

document.getElementById('assetBrowserBtn').addEventListener('click', async () => {
  assetBrowser.classList.add('open');
  if (abIndex.length > 0) { renderAssetBrowser(); return; }
  // Try auto-detect: manifest first, then stored handle
  await abAutoDetect();
});
document.getElementById('abClose').addEventListener('click', () => assetBrowser.classList.remove('open'));
document.addEventListener('keydown', e => { if (e.key === 'Escape' && assetBrowser.classList.contains('open')) assetBrowser.classList.remove('open'); });

document.getElementById('abPickFolder').addEventListener('click', pickAssetFolder);

async function pickAssetFolder() {
  try {
    abDirHandle = await window.showDirectoryPicker({ mode: 'read' });
    abIndex = [];
    abFolders = [];
    abSource = 'folder';
    abContent.innerHTML = `
      <div class="ab-grid">
        ${Array(6).fill('<div class="preset-skeleton"><div class="skeleton skeleton-preview"></div></div>').join('')}
      </div>
    `;
    abSidebar.innerHTML = '';
    await scanDirectory(abDirHandle, '');
    buildFolderTree();
    abUpdateStatus();
    abStoreHandle(abDirHandle);
    renderAssetBrowser();
  } catch (e) {
    if (e.name !== 'AbortError') console.error('Folder pick error:', e);
  }
}

async function scanDirectory(dirHandle, path) {
  const entries = [];
  for await (const entry of dirHandle.values()) entries.push(entry);
  // Sort: folders first, then files
  entries.sort((a, b) => {
    if (a.kind !== b.kind) return a.kind === 'directory' ? -1 : 1;
    return a.name.localeCompare(b.name);
  });
  for (const entry of entries) {
    if (entry.name.startsWith('.')) continue;
    const fullPath = path ? path + '/' + entry.name : entry.name;
    if (entry.kind === 'directory') {
      await scanDirectory(entry, fullPath);
    } else {
      const ext = entry.name.split('.').pop().toLowerCase();
      let type = 'other';
      if (ext === 'cube') type = 'lut';
      else if (['mp4','mov','webm','m4v'].includes(ext)) type = 'video';
      else if (['png','jpg','jpeg','webp','gif'].includes(ext)) type = 'image';
      else if (['mp3','wav','aac','ogg','m4a'].includes(ext)) type = 'audio';
      else if (['prproj','aep','mogrt','prfpset','ffx'].includes(ext)) type = 'preset';
      else if (['ttf','otf','woff','woff2'].includes(ext)) type = 'font';
      if (type !== 'other') {
        abIndex.push({ path: fullPath, name: entry.name, type, ext, handle: entry, parentPath: path });
      }
    }
  }
}

function buildFolderTree() {
  const folderMap = {};
  // Root
  folderMap[''] = { path: '', name: 'All Assets', count: abIndex.length, icon: '' };
  // Type filters
  const types = { lut: '', video: '', image: '', audio: '', preset: '', font: '' };
  const typeNames = { lut: 'LUTs (.cube)', video: 'Videos', image: 'Images', audio: 'Audio/SFX', preset: 'Presets', font: 'Fonts' };
  for (const [t, icon] of Object.entries(types)) {
    const count = abIndex.filter(f => f.type === t).length;
    if (count > 0) folderMap['__type__' + t] = { path: '__type__' + t, name: typeNames[t], count, icon };
  }
  // Actual folders (first level only for cleanliness)
  const topFolders = new Set();
  for (const f of abIndex) {
    const parts = f.parentPath.split('/');
    if (parts[0]) topFolders.add(parts[0]);
  }
  for (const folder of [...topFolders].sort()) {
    const count = abIndex.filter(f => f.parentPath === folder || f.parentPath.startsWith(folder + '/')).length;
    if (count > 0) {
      let icon = '';
      const fl = folder.toLowerCase();
      if (fl.includes('lut')) icon = '';
      else if (fl.includes('light') || fl.includes('leak') || fl.includes('glow') || fl.includes('flare')) icon = '';
      else if (fl.includes('film') || fl.includes('burn') || fl.includes('vhs')) icon = '';
      else if (fl.includes('smoke') || fl.includes('fog') || fl.includes('cloud')) icon = '';
      else if (fl.includes('sfx') || fl.includes('sound')) icon = '';
      else if (fl.includes('font')) icon = '';
      else if (fl.includes('transition')) icon = '';
      else if (fl.includes('particle') || fl.includes('spark')) icon = '';
      else if (fl.includes('overlay')) icon = '';
      else if (fl.includes('background') || fl.includes('motion')) icon = '';
      else if (fl.includes('text') || fl.includes('title')) icon = '';
      else if (fl.includes('emoji') || fl.includes('sticker')) icon = '';
      else if (fl.includes('glitch')) icon = '';
      else if (fl.includes('icon')) icon = '';
      folderMap['__folder__' + folder] = { path: '__folder__' + folder, name: folder, count, icon };
    }
  }
  abFolders = Object.values(folderMap);
}

function renderAssetBrowser() {
  // Sidebar
  abSidebar.innerHTML = abFolders.map(f =>
    `<div class="ab-folder${abCurrentFolder === f.path ? ' active' : ''}" data-ab-folder="${f.path}">
      <span class="ab-icon">${f.icon}</span>
      <span>${f.name}</span>
      <span class="ab-count">${f.count}</span>
    </div>`
  ).join('');

  abSidebar.querySelectorAll('.ab-folder').forEach(el => {
    el.addEventListener('click', () => {
      abCurrentFolder = el.dataset.abFolder;
      renderAssetBrowser();
    });
  });

  // Filter items
  let items = abIndex;
  if (abCurrentFolder.startsWith('__type__')) {
    const t = abCurrentFolder.replace('__type__', '');
    items = items.filter(f => f.type === t);
  } else if (abCurrentFolder.startsWith('__folder__')) {
    const folder = abCurrentFolder.replace('__folder__', '');
    items = items.filter(f => f.parentPath === folder || f.parentPath.startsWith(folder + '/'));
  }
  if (abSearchTerm) {
    const q = abSearchTerm.toLowerCase();
    items = items.filter(f => f.name.toLowerCase().includes(q) || f.path.toLowerCase().includes(q));
  }

  // Breadcrumb + content
  const badgeClass = { lut: 'ab-badge-lut', video: 'ab-badge-video', image: 'ab-badge-image', audio: 'ab-badge-audio' };
  const badgeLabel = { lut: 'LUT', video: 'VID', image: 'IMG', audio: 'SFX', preset: 'PRE', font: 'FONT' };
  const typeIcon = { lut: '', video: '', image: '', audio: '', preset: '', font: '' };

  if (items.length === 0 && !abDirHandle) return;

  abContent.innerHTML = `
    <div class="ab-breadcrumb">
      <span data-ab-nav="">All Assets</span>
      ${abCurrentFolder ? `<span class="ab-sep">/</span><span>${abFolders.find(f => f.path === abCurrentFolder)?.name || abCurrentFolder}</span>` : ''}
      <span style="margin-left:auto;color:#555;font-size:9px">${items.length} items</span>
    </div>
    <div class="ab-grid">
      ${items.map((f, i) => `
        <div class="ab-item" data-ab-idx="${abIndex.indexOf(f)}">
          <div class="ab-item-preview">
            ${typeIcon[f.type] || ''}
            <span class="ab-badge ${badgeClass[f.type] || ''}">${badgeLabel[f.type] || f.ext}</span>
          </div>
          <div class="ab-item-info">
            <div class="ab-item-name" title="${f.name}">${f.name}</div>
            <div class="ab-item-type">${f.parentPath || 'Root'}</div>
          </div>
        </div>
      `).join('')}
    </div>
  `;

  // Breadcrumb nav
  abContent.querySelectorAll('[data-ab-nav]').forEach(el => {
    el.addEventListener('click', () => { abCurrentFolder = el.dataset.abNav || ''; renderAssetBrowser(); });
  });

  // Item clicks  use URL loader for server mode, handle loader for folder mode
  abContent.querySelectorAll('.ab-item').forEach(el => {
    el.addEventListener('click', async () => {
      const idx = parseInt(el.dataset.abIdx);
      const item = abIndex[idx];
      if (!item) return;
      if (item.url && !item.handle) {
        await loadAssetItemFromURL(item);
      } else {
        await loadAssetItem(item);
      }
    });
  });

  // Load thumbnail previews for images (lazy, first 50 only)
  const imageItems = items.filter(f => f.type === 'image');
  imageItems.slice(0, 50).forEach(async (f) => {
    try {
      let url;
      if (f.url && !f.handle) {
        url = f.url;
      } else {
        const file = await f.handle.getFile();
        url = URL.createObjectURL(file);
      }
      const idx = abIndex.indexOf(f);
      const previewEl = abContent.querySelector(`[data-ab-idx="${idx}"] .ab-item-preview`);
      if (previewEl) previewEl.innerHTML = `<img src="${url}"><span class="ab-badge ${badgeClass[f.type] || ''}">${badgeLabel[f.type]}</span>`;
    } catch(e) {}
  });
}

async function loadAssetItem(item) {
  try {
    const file = await item.handle.getFile();

    if (item.type === 'lut') {
      // Load as LUT
      const text = await file.text();
      const lut = parseCubeLUT(text);
      if (!lut) { alert('Invalid .CUBE LUT file'); return; }
      state.lut.data = lut;
      state.lut.size = lut.size;
      state.lut.enabled = true;
      state.lut.name = lut.title || item.name;
      document.getElementById('lutInfo').innerHTML = '<span style="color:#4ade80">Loaded:</span> ' + state.lut.name + ' (' + lut.size + ')';
      document.getElementById('lutControls').style.display = 'block';
      document.querySelectorAll('#lutPresetGrid .dev-btn').forEach(b => b.classList.remove('active'));
      showAssetToast('LUT loaded: ' + item.name);

    } else if (item.type === 'video') {
      // Load as video overlay
      const url = URL.createObjectURL(file);
      const vid = document.createElement('video');
      vid.src = url;
      vid.loop = true;
      vid.muted = true;
      vid.playsInline = true;
      vid.play();
      // Sync with main video if playing
      if (hasVideo && !vtPlaying) vid.pause();
      const ov = { id: Date.now() + Math.random(), video: vid, name: item.name, opacity: 0.5, blendMode: 'screen' };
      state.videoOverlays.push(ov);
      rebuildOverlayList();
      showAssetToast('Overlay loaded: ' + item.name);

    } else if (item.type === 'image') {
      // Load as image overlay (static)
      const url = URL.createObjectURL(file);
      const img = new Image();
      img.src = url;
      img.onload = () => {
        // Add as a logo layer
        const layer = {
          id: state.nextLayerId++,
          type: 'logo', img: img, name: item.name,
          x: 100, y: 100, width: 200, opacity: 0.8
        };
        state.layers.push(layer);
        state.selectedLayer = state.layers.length - 1;
        showAssetToast('Image overlay loaded: ' + item.name);
      };

    } else if (item.type === 'audio') {
      // Load as background audio
      const url = URL.createObjectURL(file);
      const audio = new Audio(url);
      audio.loop = true;
      audio.volume = 0.5;
      audio.play();
      showAssetToast('Audio playing: ' + item.name);
    }

    // Close browser after loading
    assetBrowser.classList.remove('open');
  } catch (e) {
    console.error('Error loading asset:', e);
    alert('Could not load: ' + item.name);
  }
}

function showAssetToast(msg) { showToast(msg, 'success'); }

// Search
abSearch.addEventListener('input', e => {
  abSearchTerm = e.target.value.trim();
  if (abIndex.length > 0) renderAssetBrowser();
});

// ---- Status indicator ----
function abUpdateStatus() {
  if (abSource === 'server') {
    abStatus.textContent = 'Connected: Local Server';
    abStatus.style.color = '#4ade80';
  } else if (abSource === 'folder' && abDirHandle) {
    abStatus.textContent = 'Connected: ' + abDirHandle.name;
    abStatus.style.color = '#60a5fa';
  } else {
    abStatus.textContent = 'Not connected';
    abStatus.style.color = '#555';
  }
}

// ---- IndexedDB for directory handle persistence ----
function abOpenDB() {
  return new Promise((resolve, reject) => {
    const req = indexedDB.open('MockupStudioAssets', 1);
    req.onupgradeneeded = () => { req.result.createObjectStore('handles'); };
    req.onsuccess = () => resolve(req.result);
    req.onerror = () => reject(req.error);
  });
}

async function abStoreHandle(handle) {
  try {
    const db = await abOpenDB();
    const tx = db.transaction('handles', 'readwrite');
    tx.objectStore('handles').put(handle, 'assetDir');
    await new Promise((res, rej) => { tx.oncomplete = res; tx.onerror = rej; });
    db.close();
  } catch (e) { console.log('IndexedDB store failed:', e.message); }
}

async function abLoadStoredHandle() {
  try {
    const db = await abOpenDB();
    const tx = db.transaction('handles', 'readonly');
    const req = tx.objectStore('handles').get('assetDir');
    const handle = await new Promise((res, rej) => { req.onsuccess = () => res(req.result); req.onerror = rej; });
    db.close();
    return handle || null;
  } catch (e) { return null; }
}

// ---- Manifest-based asset loading (local server) ----
async function abLoadManifest() {
  try {
    const resp = await fetch('/assets-manifest.json');
    if (!resp.ok) return false;
    const manifest = await resp.json();
    if (!manifest.generated || !manifest.files) return false;

    abIndex = [];
    abFolders = [];
    const assetRoot = manifest.assetRoot || 'assets/';

    for (const f of manifest.files) {
      abIndex.push({
        path: f.path,
        name: f.name,
        type: f.type,
        ext: f.ext,
        handle: null,
        parentPath: f.parentPath,
        url: assetRoot + f.path,
        size: f.size
      });
    }

    abSource = 'server';
    buildFolderTree();
    abUpdateStatus();
    renderAssetBrowser();
    return true;
  } catch (e) { return false; }
}

// ---- Load asset from URL (server mode) or handle (folder mode) ----
async function loadAssetItemFromURL(item) {
  try {
    if (item.type === 'lut') {
      const resp = await fetch(item.url);
      const text = await resp.text();
      const lut = parseCubeLUT(text);
      if (!lut) { alert('Invalid .CUBE LUT file'); return; }
      state.lut.data = lut;
      state.lut.size = lut.size;
      state.lut.enabled = true;
      state.lut.name = lut.title || item.name;
      document.getElementById('lutInfo').innerHTML = '<span style="color:#4ade80">Loaded:</span> ' + state.lut.name + ' (' + lut.size + '\u00b3)';
      document.getElementById('lutControls').style.display = 'block';
      document.querySelectorAll('#lutPresetGrid .dev-btn').forEach(b => b.classList.remove('active'));
      showAssetToast('LUT loaded: ' + item.name);

    } else if (item.type === 'video') {
      const vid = document.createElement('video');
      vid.src = item.url;
      vid.crossOrigin = 'anonymous';
      vid.loop = true;
      vid.muted = true;
      vid.playsInline = true;
      vid.play();
      if (hasVideo && !vtPlaying) vid.pause();
      const ov = { id: Date.now() + Math.random(), video: vid, name: item.name, opacity: 0.5, blendMode: 'screen' };
      state.videoOverlays.push(ov);
      rebuildOverlayList();
      showAssetToast('Overlay loaded: ' + item.name);

    } else if (item.type === 'image') {
      const img = new Image();
      img.crossOrigin = 'anonymous';
      img.src = item.url;
      img.onload = () => {
        const layer = {
          id: state.nextLayerId++,
          type: 'logo', img: img, name: item.name,
          x: 100, y: 100, width: 200, opacity: 0.8
        };
        state.layers.push(layer);
        state.selectedLayer = state.layers.length - 1;
        showAssetToast('Image overlay loaded: ' + item.name);
      };

    } else if (item.type === 'audio') {
      const audio = new Audio(item.url);
      audio.loop = true;
      audio.volume = 0.5;
      audio.play();
      showAssetToast('Audio playing: ' + item.name);
    }

    assetBrowser.classList.remove('open');
  } catch (e) {
    console.error('Error loading asset from URL:', e);
    alert('Could not load: ' + item.name);
  }
}

// ---- Auto-detect: manifest  stored handle  show picker prompt ----
async function abAutoDetect() {
  abContent.innerHTML = `
    <div class="ab-grid">
      ${Array(6).fill('<div class="preset-skeleton"><div class="skeleton skeleton-preview"></div></div>').join('')}
    </div>
  `;
  abSidebar.innerHTML = '';
  abUpdateStatus();

  // 1. Try server manifest
  if (window.location.protocol !== 'file:') {
    const loaded = await abLoadManifest();
    if (loaded) return;
  }

  // 2. Try stored directory handle from IndexedDB
  const storedHandle = await abLoadStoredHandle();
  if (storedHandle) {
    try {
      const perm = await storedHandle.requestPermission({ mode: 'read' });
      if (perm === 'granted') {
        abDirHandle = storedHandle;
        abIndex = [];
        abFolders = [];
        abSource = 'folder';
        abContent.innerHTML = `
      <div class="ab-grid">
        ${Array(6).fill('<div class="preset-skeleton"><div class="skeleton skeleton-preview"></div></div>').join('')}
      </div>
    `;
        await scanDirectory(abDirHandle, '');
        buildFolderTree();
        abUpdateStatus();
        renderAssetBrowser();
        return;
      }
    } catch (e) { console.log('Stored handle permission denied:', e.message); }
  }

  // 3. Fall back to manual picker prompt
  abContent.innerHTML = '';
  abContent.appendChild(abEmpty);
  abUpdateStatus();
}

// ============================================================

// INIT
// ============================================================
resizeCanvas();
requestAnimationFrame(render);

window.addEventListener('resize', () => { updateDisplaySize(); });
scaleSlider.addEventListener('input', () => { state.device.scale = parseInt(scaleSlider.value) / 100; updateDisplaySize(); frameCache = {}; });
document.getElementById('videoFitMode').addEventListener('change', e => { state.videoFit = e.target.value; scheduleSave(); });
bgColorInput.addEventListener('input', e => { state.background.color = e.target.value; });
shadowSlider.addEventListener('input', e => { state.shadow = parseInt(e.target.value) / 100; });
tiltXSlider.addEventListener('input', updatePerspective);
tiltYSlider.addEventListener('input', updatePerspective);

// ============================================================
// DEVICE SELECTION
// ============================================================
function updateColorSwatches() {
  const dev = DEVICES[state.device.type];
  const container = document.getElementById('colorSwatches');
  container.innerHTML = '';
  if (state.device.type === 'none') return; // No swatches for no-device mode
  for (const [key, pal] of Object.entries(dev.colors)) {
    const s = document.createElement('div');
    s.className = 'color-swatch' + (key === state.device.color ? ' active' : '');
    s.style.background = pal.body;
    s.title = pal.label;
    s.dataset.color = key;
    s.addEventListener('click', () => {
      pushUndoState();
      state.device.color = key;
      frameCache = {};
      document.querySelectorAll('.color-swatch').forEach(x => x.classList.remove('active'));
      s.classList.add('active');
    });
    container.appendChild(s);
  }
}

deviceGrid.addEventListener('click', e => {
  const btn = e.target.closest('.dev-btn');
  if (!btn) return;
  pushUndoState();
  const devId = btn.dataset.device;
      state.device.type = devId;
      updateHandOverlayUI();  state.device.color = DEVICES[devId].defaultColor;
  frameCache = {};
  deviceGrid.querySelectorAll('.dev-btn').forEach(x => x.classList.remove('active'));
  btn.classList.add('active');
  updateColorSwatches();
  // Hide/show device-specific toggles
  const toggles = document.getElementById('deviceToggles');
  if (toggles) toggles.style.display = devId === 'none' ? 'none' : 'flex';
  // Clear full preset active state (user is customizing)
  document.querySelectorAll('#fullPresetGrid .preset-card').forEach(b => b.classList.remove('active'));
  resizeCanvas();
});

updateColorSwatches();

// ============================================================
// FULL PRESET TEMPLATE CONTROLS
// ============================================================
document.getElementById('fullPresetGrid').addEventListener('click', e => {
  const card = e.target.closest('.preset-card');
  if (!card) return;
  pushUndoState();
  const key = card.dataset.fp;
  applyFullPreset(key);
  const name = card.querySelector('.pc-name');
  showToast('Preset: ' + (name ? name.textContent : key) + ' applied', 'info');
});

document.getElementById('resetFullPresetBtn').addEventListener('click', () => {
  document.querySelectorAll('#fullPresetGrid .preset-card').forEach(b => b.classList.remove('active'));
});

// Device section collapse toggle
document.getElementById('deviceCollapseBtn').addEventListener('click', () => {
  const section = document.getElementById('deviceSection');
  const btn = document.getElementById('deviceCollapseBtn');
  const content = document.getElementById('deviceContent');
  const isCollapsed = content.style.display === 'none';
  content.style.display = isCollapsed ? '' : 'none';
  btn.textContent = isCollapsed ? '' : '';
});

// Landscape toggle
document.getElementById('landscapeBtn').addEventListener('click', function() {
  state.device.landscape = !state.device.landscape;
  this.classList.toggle('active', state.device.landscape);
  resizeCanvas();
});

// Device preset dropdown
document.getElementById('devicePresetSelect')?.addEventListener('change', e => {
  if (e.target.value) {
    applyDevicePreset(e.target.value);
    e.target.value = ''; // Reset dropdown
  }
});

// ============================================================
// PRESET SELECTION
// ============================================================
presetSelect.addEventListener('change', e => {
  // No device + device-only doesn't make sense  force to reels
  if (e.target.value === 'device' && state.device.type === 'none') {
    e.target.value = 'reels';
  }
  state.preset = e.target.value;
  customSizeWrap.style.display = e.target.value === 'custom' ? 'inline' : 'none';
  if (e.target.value === 'custom') {
    PRESETS.custom = { w: parseInt(customW.value), h: parseInt(customH.value) };
  }
  resizeCanvas();
});
customW.addEventListener('change', () => { PRESETS.custom.w = parseInt(customW.value); resizeCanvas(); });
customH.addEventListener('change', () => { PRESETS.custom.h = parseInt(customH.value); resizeCanvas(); });

// ============================================================
// VIDEO LOADING
// ============================================================
function loadVideo(file) {
  const url = URL.createObjectURL(file);
  video.src = url;
  video.muted = true;
  video.load();
  hasVideo = true;
  promptEl.classList.remove('visible');
  playbackBar.classList.add('visible');
  timelineBar.classList.add('visible');
  playbackStartTime = performance.now();
  const fnEl = document.getElementById('videoFileName');
  fnEl.textContent = file.name.length > 30 ? file.name.slice(0, 27) + '...' : file.name;
  fnEl.title = file.name;
  state.timeline.trimIn = 0;
  state.timeline.trimOut = 1;
  // Reset virtual timeline
  vtTime = 0;
  vtActiveClipIdx = 0;
  // Add clip to timeline
  state.timeline.clips = [{ video: video, name: file.name, start: 0, duration: 0, trimIn: 0, trimOut: 1 }];
  video.addEventListener('loadedmetadata', () => {
    state.timeline.clips[0].duration = video.duration;
    rebuildTimeline();
    vtPlay();

    // Show device animation controls when video is loaded
    const deviceKeyframesSection = document.getElementById('deviceKeyframesSection');
    const standstillSection = document.getElementById('standstillSection');
    if (deviceKeyframesSection) deviceKeyframesSection.style.display = 'block';
    if (standstillSection) standstillSection.style.display = 'block';

    // Initialize keyframes list
    if (typeof updateDeviceKeyframesList === 'function') {
      updateDeviceKeyframesList();
    }
  }, { once: true });
  video.addEventListener('canplay', () => {
    if (!vtPlaying && state.timeline.clips.length === 1) vtPlay();
  }, { once: true });
  showToast('Video loaded: ' + file.name, 'success');
}

loadBtn.addEventListener('click', () => fileInput.click());
canvasWrap.addEventListener('click', () => { if (!hasVideo) fileInput.click(); });
fileInput.addEventListener('change', e => { if (e.target.files[0]) loadVideo(e.target.files[0]); });

// Drag & drop
let dragN = 0;
document.addEventListener('dragenter', e => { e.preventDefault(); dragN++; dropOverlay.classList.add('active'); });
document.addEventListener('dragleave', e => { e.preventDefault(); dragN--; if (dragN <= 0) { dragN = 0; dropOverlay.classList.remove('active'); } });
document.addEventListener('dragover', e => e.preventDefault());
document.addEventListener('drop', e => {
  e.preventDefault(); dragN = 0; dropOverlay.classList.remove('active');
  const f = e.dataTransfer.files[0];
  if (f && f.type.startsWith('video/')) loadVideo(f);
});

// ============================================================
// PLAYBACK
// ============================================================
playBtn.addEventListener('click', () => { vtToggle(); });

function fmt(s) { return Math.floor(s/60) + ':' + String(Math.floor(s%60)).padStart(2, '0'); }

// Progress bar scrubbing
const progressTooltip = document.getElementById('progressTooltip');
let isScrubbing = false;
let wasPlayingBeforeScrub = false;

function scrubToX(clientX) {
  const r = progressTrack.getBoundingClientRect();
  const pct = Math.max(0, Math.min(1, (clientX - r.left) / r.width));
  const totalDur = vtGetTotalDuration() || 1;
  const t = pct * totalDur;
  vtSeek(t);
  progressTooltip.textContent = fmt(t);
  progressFill.style.width = (pct * 100) + '%';
}

progressTrack.addEventListener('mousedown', e => {
  if (!hasVideo) return;
  isScrubbing = true;
  wasPlayingBeforeScrub = vtPlaying;
  vtPause();
  progressTrack.classList.add('scrubbing');
  scrubToX(e.clientX);
});

document.addEventListener('mousemove', e => {
  if (!isScrubbing) return;
  scrubToX(e.clientX);
});

document.addEventListener('mouseup', () => {
  if (!isScrubbing) return;
  isScrubbing = false;
  progressTrack.classList.remove('scrubbing');
  if (wasPlayingBeforeScrub) vtPlay();
});

loopBtn.addEventListener('click', function() {
  isLooping = !isLooping;
  this.classList.toggle('active', isLooping);
  this.textContent = isLooping ? 'Loop' : 'No Loop';
  showToast('Loop: ' + (isLooping ? 'ON' : 'OFF'), 'info');
});
loopBtn.classList.add('active');

// Speed control
speedSelect.addEventListener('change', e => {
  state.timeline.speed = parseFloat(e.target.value);
  state.timeline.clips.forEach(c => { c.video.playbackRate = state.timeline.speed; });
});

// Timeline click to seek (on empty track area, not clip blocks)
timelineTrack.addEventListener('click', e => {
  if (e.target.closest('.clip-block')) return;
  if (!hasVideo) return;
  const rect = timelineTrack.getBoundingClientRect();
  const pct = (e.clientX - rect.left) / rect.width;
  const totalDuration = vtGetTotalDuration() || 1;
  vtSeek(pct * totalDuration);
});

// Add clip
document.getElementById('addClipBtn').addEventListener('click', () => clipInput.click());
clipInput.addEventListener('change', e => {
  const file = e.target.files[0];
  if (!file) return;
  pushUndoState();
  const v = document.createElement('video');
  v.src = URL.createObjectURL(file);
  v.preload = 'auto';
  v.muted = true;
  v.playsInline = true;
  v.style.display = 'none';
  document.body.appendChild(v);
  v.addEventListener('loadedmetadata', () => {
    state.timeline.clips.push({ video: v, name: file.name, start: 0, duration: v.duration, trimIn: 0, trimOut: 1 });
    rebuildTimeline();
    showToast('Clip added: ' + file.name, 'success');
  });
  e.target.value = '';
});

// Zoom keyframes
document.getElementById('addKeyframeBtn').addEventListener('click', () => {
  if (!hasVideo) return;
  const kf = {
    time: vtTime,
    zoom: parseInt(document.getElementById('kfZoom').value) / 100,
    panX: parseInt(document.getElementById('kfPanX').value),
    panY: parseInt(document.getElementById('kfPanY').value),
  };
  state.timeline.keyframes.push(kf);
  state.timeline.keyframes.sort((a, b) => a.time - b.time);
  rebuildTimeline();
});

// Keyboard shortcuts
const kbOverlay = document.getElementById('kbOverlay');
function toggleKbHelp() { kbOverlay.classList.toggle('open'); }

document.getElementById('kbHelpBtn').addEventListener('click', toggleKbHelp);
document.getElementById('kbClose').addEventListener('click', () => kbOverlay.classList.remove('open'));
kbOverlay.addEventListener('click', e => { if (e.target === kbOverlay) kbOverlay.classList.remove('open'); });

document.addEventListener('keydown', e => {
  // Undo/redo works everywhere (including inputs)
  if ((e.metaKey || e.ctrlKey) && e.key === 'z' && !e.shiftKey) { e.preventDefault(); undo(); return; }
  if ((e.metaKey || e.ctrlKey) && e.key === 'z' && e.shiftKey) { e.preventDefault(); redo(); return; }
  if ((e.metaKey || e.ctrlKey) && e.key === 'Z') { e.preventDefault(); redo(); return; }
  if (e.target.tagName === 'INPUT' || e.target.tagName === 'SELECT' || e.target.tagName === 'TEXTAREA') return;
  if (e.key === 'Escape' && kbOverlay.classList.contains('open')) { kbOverlay.classList.remove('open'); return; }
  if (e.key === 'Escape' && document.getElementById('exportDialog').classList.contains('open')) { document.getElementById('exportDialog').classList.remove('open'); return; }
  if (e.key === '?') { toggleKbHelp(); return; }
  if (e.code === 'Space') { e.preventDefault(); vtToggle(); }
  if (e.key === '[') { togglePanel('left'); return; }
  if (e.key === ']') { togglePanel('right'); return; }
  if (e.code === 'ArrowLeft') vtSeek(vtTime - 5);
  if (e.code === 'ArrowRight') vtSeek(vtTime + 5);
});
document.getElementById('undoBtn').addEventListener('click', undo);
document.getElementById('redoBtn').addEventListener('click', redo);

// Capture undo state when slider drag or color picker begins (before value changes)
document.addEventListener('mousedown', e => {
  if (e.target.type === 'range' || e.target.type === 'color') pushUndoState();
}, true);

// ============================================================
// COLLAPSIBLE SIDEBAR PANELS & MOBILE MENU
// ============================================================
const leftPanel = document.getElementById('leftPanel');
const rightPanel = document.getElementById('rightPanel');
const leftPanelToggle = document.getElementById('leftPanelToggle');
const rightPanelToggle = document.getElementById('rightPanelToggle');
const mobileLeftToggle = document.getElementById('mobileLeftToggle');
const mobileRightToggle = document.getElementById('mobileRightToggle');
const panelBackdrop = document.getElementById('panelBackdrop');

// Desktop toggle (collapsed state)
function togglePanel(side) {
  const panel = side === 'left' ? leftPanel : rightPanel;
  const btn = side === 'left' ? leftPanelToggle : rightPanelToggle;
  const collapsed = panel.classList.toggle('collapsed');
  if (side === 'left') {
    btn.textContent = collapsed ? '' : '';
  } else {
    btn.textContent = collapsed ? '' : '';
  }
  savePanelState();
}

// Mobile/Tablet toggle (overlay mode)
function toggleMobilePanel(side) {
  const panel = side === 'left' ? leftPanel : rightPanel;
  const otherPanel = side === 'left' ? rightPanel : leftPanel;

  // Close other panel first
  otherPanel.classList.remove('mobile-open', 'tablet-open');

  // Toggle this panel
  const isOpen = panel.classList.contains('mobile-open') || panel.classList.contains('tablet-open');

  if (window.innerWidth < 768) {
    // Mobile: use mobile-open class with backdrop
    if (isOpen) {
      panel.classList.remove('mobile-open');
      panelBackdrop.classList.remove('visible');
    } else {
      panel.classList.add('mobile-open');
      panelBackdrop.classList.add('visible');
    }
  } else if (window.innerWidth < 1024) {
    // Tablet: use tablet-open class
    if (isOpen) {
      panel.classList.remove('tablet-open');
    } else {
      panel.classList.add('tablet-open');
    }
  }
}

function savePanelState() {
  localStorage.setItem('mockupStudioPanels', JSON.stringify({
    left: leftPanel.classList.contains('collapsed'),
    right: rightPanel.classList.contains('collapsed'),
  }));
}

function loadPanelState() {
  // Auto-collapse on narrow screens
  if (window.innerWidth < 1280) {
    leftPanel.classList.add('collapsed');
    rightPanel.classList.add('collapsed');
    leftPanelToggle.textContent = '';
    rightPanelToggle.textContent = '';
  }
  // Override with saved state if it exists
  try {
    const raw = localStorage.getItem('mockupStudioPanels');
    if (raw) {
      const s = JSON.parse(raw);
      leftPanel.classList.toggle('collapsed', s.left);
      rightPanel.classList.toggle('collapsed', s.right);
      leftPanelToggle.textContent = s.left ? '' : '';
      rightPanelToggle.textContent = s.right ? '' : '';
    }
  } catch (e) { /* ignore */ }
}

// Desktop toggle buttons
if (leftPanelToggle) leftPanelToggle.addEventListener('click', () => togglePanel('left'));
if (rightPanelToggle) rightPanelToggle.addEventListener('click', () => togglePanel('right'));

// Mobile toggle buttons
if (mobileLeftToggle) mobileLeftToggle.addEventListener('click', () => toggleMobilePanel('left'));
if (mobileRightToggle) mobileRightToggle.addEventListener('click', () => toggleMobilePanel('right'));

// Close mobile panels when backdrop is clicked
if (panelBackdrop) {
  panelBackdrop.addEventListener('click', () => {
    leftPanel.classList.remove('mobile-open', 'tablet-open');
    rightPanel.classList.remove('mobile-open', 'tablet-open');
    panelBackdrop.classList.remove('visible');
  });
}

// Swipe to close panels on mobile
let touchStartX = 0;
let touchEndX = 0;

document.addEventListener('touchstart', (e) => {
  touchStartX = e.changedTouches[0].screenX;
}, { passive: true });

document.addEventListener('touchend', (e) => {
  touchEndX = e.changedTouches[0].screenX;
  handleSwipe();
}, { passive: true });

function handleSwipe() {
  const swipeDistance = touchEndX - touchStartX;
  const threshold = 100;

  // Swipe right to left (close left panel)
  if (swipeDistance < -threshold && leftPanel.classList.contains('mobile-open')) {
    leftPanel.classList.remove('mobile-open');
    panelBackdrop.classList.remove('visible');
  }

  // Swipe left to right (close right panel)
  if (swipeDistance > threshold && rightPanel.classList.contains('mobile-open')) {
    rightPanel.classList.remove('mobile-open');
    panelBackdrop.classList.remove('visible');
  }
}

loadPanelState();

// ============================================================
// HAND OVERLAY
// ============================================================
document.getElementById('handBtn').addEventListener('click', function() {
  pushUndoState();
  state.hand.enabled = !state.hand.enabled;
  updateHandOverlayUI();
  scheduleRender();
});

function updateHandOverlayUI() {
  const handBtn = document.getElementById('handBtn');
  const resetHandBtn = document.getElementById('resetHandBtn');
  const supportedDevices = ['iphone16', 'applewatch']; // Devices that support hand overlay

  if (supportedDevices.includes(state.device.type)) {
    handBtn.disabled = false;
    handBtn.classList.toggle('active', state.hand.enabled);
    handBtn.textContent = state.hand.enabled ? 'Disable Hand' : 'Enable Hand';
    resetHandBtn.style.display = state.hand.enabled ? 'inline-block' : 'none';
  } else {
    // Device not supported, disable hand overlay
    state.hand.enabled = false;
    handBtn.disabled = true;
    handBtn.classList.remove('active');
    handBtn.textContent = 'Hand Overlay (N/A for ' + DEVICES[state.device.type].name + ')';
    resetHandBtn.style.display = 'none';
  }
}
document.getElementById('handStyle').addEventListener('change', e => { state.hand.style = e.target.value; });

// ============================================================
// DEVICE COMPARISON
// ============================================================
function enableComparison() {
  state.comparison.enabled = true;
  document.getElementById('comparisonBtn').classList.add('active');
  document.getElementById('comparisonControls').classList.add('visible');
  // Default second device: different from current
  const types = Object.keys(DEVICES);
  const other = types.find(t => t !== state.device.type) || types[0];
  state.comparison.device2 = { type: other, color: DEVICES[other].defaultColor };
  updateDevice2Swatches();
}

function disableComparison() {
  state.comparison.enabled = false;
  document.getElementById('comparisonBtn').classList.remove('active');
  document.getElementById('comparisonControls').classList.remove('visible');
  const vid2 = document.getElementById('srcVideo2');
  if (vid2) { vid2.pause(); vid2.src = ''; }
  document.getElementById('video2Status').textContent = 'No video loaded for Device 2';
}

document.getElementById('comparisonBtn').addEventListener('click', function() {
  if (state.comparison.enabled) { disableComparison(); return; }
  enableComparison();
});

document.getElementById('disableCompareBtn').addEventListener('click', () => disableComparison());

// Device 2 type selection
document.getElementById('device2Grid').addEventListener('click', e => {
  const btn = e.target.closest('.dev-btn');
  if (!btn || !state.comparison.device2) return;
  const devId = btn.dataset.device;
  state.comparison.device2.type = devId;
  state.comparison.device2.color = DEVICES[devId].defaultColor;
  frameCache = {};
  document.querySelectorAll('#device2Grid .dev-btn').forEach(x => x.classList.remove('active'));
  btn.classList.add('active');
  updateDevice2Swatches();
});

function updateDevice2Swatches() {
  if (!state.comparison.device2) return;
  const dev = DEVICES[state.comparison.device2.type];
  const container = document.getElementById('colorSwatches2');
  container.innerHTML = '';
  for (const [key, pal] of Object.entries(dev.colors)) {
    const s = document.createElement('div');
    s.className = 'color-swatch' + (key === state.comparison.device2.color ? ' active' : '');
    s.style.background = pal.body;
    s.title = pal.label;
    s.addEventListener('click', () => {
      state.comparison.device2.color = key;
      frameCache = {};
      container.querySelectorAll('.color-swatch').forEach(x => x.classList.remove('active'));
      s.classList.add('active');
    });
    container.appendChild(s);
  }
}

// Load video for device 2
document.getElementById('loadVideo2Btn').addEventListener('click', () => {
  document.getElementById('video2Input').click();
});

document.getElementById('video2Input').addEventListener('change', e => {
  const file = e.target.files[0];
  if (!file) return;
  const vid2 = document.getElementById('srcVideo2');
  vid2.src = URL.createObjectURL(file);
  vid2.loop = true;
  vid2.muted = true;
  vid2.load();
  vid2.play().catch(() => {});
  document.getElementById('video2Status').textContent = 'Playing: ' + file.name;
});

// ============================================================
// BACKGROUND TYPE + GRADIENT CONTROLS
// ============================================================
document.getElementById('bgType').addEventListener('change', e => {
  pushUndoState();
  const val = e.target.value;
  state.bgType = val;
  if (val === 'gradient') {
    state.gradient.enabled = true;
    document.getElementById('bgSolidControls').style.display = 'none';
    document.getElementById('bgGradientControls').style.display = 'block';
    canvasWrap.classList.remove('checker-bg');
  } else if (val === 'transparent') {
    state.gradient.enabled = false;
    document.getElementById('bgSolidControls').style.display = 'none';
    document.getElementById('bgGradientControls').style.display = 'none';
    canvasWrap.classList.add('checker-bg');
  } else {
    state.gradient.enabled = false;
    document.getElementById('bgSolidControls').style.display = 'block';
    document.getElementById('bgGradientControls').style.display = 'none';
    canvasWrap.classList.remove('checker-bg');
  }
});
document.getElementById('gradColor1').addEventListener('input', e => { state.gradient.color1 = e.target.value; });
document.getElementById('gradColor2').addEventListener('input', e => { state.gradient.color2 = e.target.value; });
document.getElementById('gradColor3').addEventListener('input', e => { state.gradient.color3 = e.target.value; });
document.getElementById('gradAngle').addEventListener('input', e => { state.gradient.angle = parseInt(e.target.value); });
document.getElementById('gradAnimated').addEventListener('change', e => { state.gradient.animated = e.target.value === 'true'; });

// ============================================================
// PARTICLE CONTROLS
// ============================================================
document.getElementById('particleType').addEventListener('change', e => {
  pushUndoState();
  if (e.target.value === 'off') { state.particles.enabled = false; }
  else { state.particles.enabled = true; state.particles.type = e.target.value; state._particles = []; }
});
document.getElementById('particleCount').addEventListener('input', e => { state.particles.count = parseInt(e.target.value); state._particles = []; });
document.getElementById('particleColor').addEventListener('input', e => { state.particles.color = e.target.value; });

// ============================================================
// ORBIT + MOTION BLUR CONTROLS
// ============================================================
document.getElementById('orbitToggle').addEventListener('change', e => {
  pushUndoState();
  state.orbit.enabled = e.target.value === 'true';
  if (!state.orbit.enabled) updatePerspective();
});
document.getElementById('orbitSpeed').addEventListener('input', e => { state.orbit.speed = parseInt(e.target.value) / 100; });
document.getElementById('motionBlurToggle').addEventListener('change', e => { pushUndoState(); state.motionBlur.enabled = e.target.value === 'true'; });

// ============================================================
// OVERLAY CONTROLS (Progress, Waveform, Glass)
// ============================================================
document.getElementById('progressToggle').addEventListener('change', e => { pushUndoState(); state.progressBar.enabled = e.target.value === 'true'; });
document.getElementById('progressColor').addEventListener('input', e => { state.progressBar.color = e.target.value; });
document.getElementById('waveformToggle').addEventListener('change', e => {
  pushUndoState();
  state.waveform.enabled = e.target.value === 'true';
  if (state.waveform.enabled) setupAudioAnalyser();
});
document.getElementById('waveformColor').addEventListener('input', e => { state.waveform.color = e.target.value; });
document.getElementById('glassToggle').addEventListener('change', e => {
  pushUndoState();
  state.glassmorphism.enabled = e.target.value === 'true';
  document.getElementById('glassControls').style.display = state.glassmorphism.enabled ? 'block' : 'none';
  state.glassmorphism.x = -1; state.glassmorphism.y = -1;
});
document.getElementById('glassText').addEventListener('input', e => { state.glassmorphism.text = e.target.value; });
document.getElementById('glassBlur').addEventListener('input', e => { state.glassmorphism.blur = parseInt(e.target.value); });
document.getElementById('glassOpacity').addEventListener('input', e => { state.glassmorphism.opacity = parseInt(e.target.value); });

// Drag glassmorphism overlay
let draggingGlass = false, glassDragOffset = { x:0, y:0 };
canvas.addEventListener('mousedown', e => {
  if (!state.glassmorphism.enabled) return;
  const rect = canvas.getBoundingClientRect();
  const sx = canvas.width / rect.width, sy = canvas.height / rect.height;
  const mx = (e.clientX - rect.left)*sx, my = (e.clientY - rect.top)*sy;
  const g = state.glassmorphism;
  if (mx >= g.x && mx <= g.x+g.width && my >= g.y && my <= g.y+g.height) {
    draggingGlass = true; glassDragOffset.x = mx - g.x; glassDragOffset.y = my - g.y;
    e.preventDefault(); e.stopPropagation();
  }
}, true);
canvas.addEventListener('mousemove', e => {
  if (!draggingGlass) return;
  const rect = canvas.getBoundingClientRect();
  const sx = canvas.width / rect.width, sy = canvas.height / rect.height;
  state.glassmorphism.x = (e.clientX - rect.left)*sx - glassDragOffset.x;
  state.glassmorphism.y = (e.clientY - rect.top)*sy - glassDragOffset.y;
}, true);
document.addEventListener('mouseup', () => { draggingGlass = false; }, true);

// ============================================================
// SCENE TEMPLATE GRID
// ============================================================
document.getElementById('sceneGrid').addEventListener('click', e => {
  const btn = e.target.closest('.dev-btn');
  if (!btn) return;
  pushUndoState();
  const scene = btn.dataset.scene;
  document.querySelectorAll('#sceneGrid .dev-btn').forEach(b => b.classList.remove('active'));
  btn.classList.add('active');
  applyScene(scene);
  showToast('Scene: ' + btn.textContent.trim() + ' applied', 'info');
});

// ============================================================
// CHROMA KEY CONTROLS
// ============================================================
document.getElementById('chromaToggle').addEventListener('change', e => {
  pushUndoState();
  state.chromaKey.enabled = e.target.value === 'true';
  document.getElementById('chromaControls').style.display = state.chromaKey.enabled ? 'block' : 'none';
});
document.getElementById('chromaColor').addEventListener('input', e => { state.chromaKey.color = e.target.value; });
document.getElementById('chromaTolerance').addEventListener('input', e => { state.chromaKey.tolerance = parseInt(e.target.value); });
document.getElementById('chromaSoftness').addEventListener('input', e => { state.chromaKey.softness = parseInt(e.target.value); });

// ============================================================
// CLEAR / RESET BUTTONS
// ============================================================
document.getElementById('clearLayersBtn').addEventListener('click', () => {
  state.layers = [];
  state.selectedLayer = -1;
  rebuildLayerList();
  document.getElementById('textProps').style.display = 'none';
  document.getElementById('logoProps').style.display = 'none';
});

document.getElementById('clearKeyframesBtn').addEventListener('click', () => {
  state.timeline.keyframes = [];
  rebuildTimeline();
});

document.getElementById('resetEffectsBtn').addEventListener('click', () => {
  // Reset particles
  state.particles.enabled = false;
  state._particles = [];
  document.getElementById('particleType').value = 'off';
  // Reset orbit
  state.orbit.enabled = false;
  document.getElementById('orbitToggle').value = 'false';
  updatePerspective();
  // Reset motion blur
  state.motionBlur.enabled = false;
  document.getElementById('motionBlurToggle').value = 'false';
});

// Reset Scene Templates
document.getElementById('resetSceneBtn').addEventListener('click', () => {
  state.scene = 'custom';
  state.gradient.enabled = false;
  state.particles.enabled = false;
  state._particles = [];
  state.orbit.enabled = false;
  document.getElementById('particleType').value = 'off';
  document.getElementById('orbitToggle').value = 'false';
  document.getElementById('bgType').value = 'solid';
  state.bgType = 'solid';
  document.getElementById('bgSolidControls').style.display = 'block';
  document.getElementById('bgGradientControls').style.display = 'none';
  document.querySelectorAll('#sceneGrid .dev-btn').forEach(b => b.classList.remove('active'));
  document.querySelector('#sceneGrid .dev-btn[data-scene="custom"]').classList.add('active');
  updatePerspective();
});

// Reset Hand Overlay
document.getElementById('resetHandBtn').addEventListener('click', () => {
  state.hand.enabled = false;
  document.getElementById('handBtn').classList.remove('active');
  document.getElementById('handBtn').textContent = 'Enable Hand';
  document.getElementById('resetHandBtn').style.display = 'none';
});

// Reset Background
document.getElementById('resetBgBtn').addEventListener('click', () => {
  state.bgType = 'solid';
  state.background = { color: '#0a0a0a' };
  state.gradient.enabled = false;
  state.shadow = 0.6;
  document.getElementById('bgType').value = 'solid';
  document.getElementById('bgColor').value = '#0a0a0a';
  document.getElementById('bgSolidControls').style.display = 'block';
  document.getElementById('bgGradientControls').style.display = 'none';
  document.getElementById('shadowSlider').value = 60;
  document.getElementById('gradColor1').value = '#0f0c29';
  document.getElementById('gradColor2').value = '#302b63';
  document.getElementById('gradColor3').value = '#24243e';
  document.getElementById('gradAngle').value = 135;
  document.getElementById('gradAnimated').value = 'false';
  const cw = document.getElementById('canvasWrap');
  cw.classList.remove('checker-bg');
  // Also remove bg video
  state.bgVideo.enabled = false;
  const bgVidEl = document.getElementById('bgVideo');
  if (bgVidEl.src) { bgVidEl.pause(); URL.revokeObjectURL(bgVidEl.src); bgVidEl.removeAttribute('src'); }
  document.getElementById('removeBgVideoBtn').style.display = 'none';
  document.getElementById('bgVideoControls').style.display = 'none';
  document.getElementById('bgVideoStatus').textContent = '';
  document.getElementById('loadBgVideoBtn').style.display = 'block';
});

// ============================================================
// BACKGROUND VIDEO
// ============================================================
document.getElementById('loadBgVideoBtn').addEventListener('click', () => document.getElementById('bgVideoInput').click());

document.getElementById('bgVideoInput').addEventListener('change', e => {
  const file = e.target.files[0];
  if (!file) return;
  const bgVid = document.getElementById('bgVideo');
  if (bgVid.src) URL.revokeObjectURL(bgVid.src);
  bgVid.src = URL.createObjectURL(file);
  bgVid.load();
  bgVid.addEventListener('loadedmetadata', function onMeta() {
    bgVid.removeEventListener('loadedmetadata', onMeta);
    state.bgVideo.enabled = true;
    document.getElementById('bgVideoStatus').textContent = file.name + ' (' + bgVid.videoWidth + 'x' + bgVid.videoHeight + ')';
    document.getElementById('bgVideoControls').style.display = 'block';
    document.getElementById('removeBgVideoBtn').style.display = '';
    document.getElementById('loadBgVideoBtn').style.display = 'none';

    // Update timeline visibility to show the background video track
    updateTimelineVisibility();

    // Enable loop by default
    const bgLoopBtn = document.getElementById('bgLoopBtn');
    if (bgLoopBtn) {
      bgLoopBtn.classList.add('active');
    }

    // Auto-play synced with main video
    if (hasVideo && vtPlaying) bgVid.play();
    else bgVid.play(); // play anyway for preview
  });
  e.target.value = '';
});

document.getElementById('removeBgVideoBtn').addEventListener('click', () => {
  state.bgVideo.enabled = false;
  const bgVid = document.getElementById('bgVideo');
  bgVid.pause();
  if (bgVid.src) URL.revokeObjectURL(bgVid.src);
  bgVid.removeAttribute('src');
  document.getElementById('bgVideoStatus').textContent = '';
  document.getElementById('bgVideoControls').style.display = 'none';
  document.getElementById('removeBgVideoBtn').style.display = 'none';
  document.getElementById('loadBgVideoBtn').style.display = 'block';

  // Update timeline visibility to hide the background video track
  updateTimelineVisibility();
});

document.getElementById('bgVideoOpacity').addEventListener('input', e => {
  state.bgVideo.opacity = parseInt(e.target.value) / 100;
  document.getElementById('bgVideoOpacityVal').textContent = e.target.value + '%';
});

document.getElementById('bgVideoFit').addEventListener('change', e => {
  state.bgVideo.fit = e.target.value;
});

// Reset Chroma Key
document.getElementById('resetChromaBtn').addEventListener('click', () => {
  state.chromaKey.enabled = false;
  state.chromaKey.color = '#00ff00';
  state.chromaKey.tolerance = 80;
  state.chromaKey.softness = 10;
  document.getElementById('chromaToggle').value = 'false';
  document.getElementById('chromaControls').style.display = 'none';
  document.getElementById('chromaColor').value = '#00ff00';
  document.getElementById('chromaTolerance').value = 80;
  document.getElementById('chromaSoftness').value = 10;
});

// Clear Annotations
document.getElementById('clearAnnotationsBtn').addEventListener('click', () => {
  state.layers = state.layers.filter(l => l.type !== 'annotation');
});

// Reset Device Transform
document.getElementById('resetTransformBtn').addEventListener('click', () => {
  state.device.scale = 0.45;

  document.getElementById('scaleSlider').value = 45;
  document.getElementById('scaleVal').textContent = '45%';
  document.getElementById('tiltX').value = 0;
  document.getElementById('tiltY').value = 0;
  updatePerspective();
  updateDisplaySize();
});

// ============================================================
// VIDEO OVERLAY CONTROLS
// ============================================================
document.getElementById('builtinOverlayGrid').addEventListener('click', e => {
  const btn = e.target.closest('.dev-btn');
  if (!btn) return;
  pushUndoState();
  const type = btn.dataset.builtin;
  // Toggle  if already active, remove it
  const existing = state.videoOverlays.findIndex(ov => ov.builtin === type);
  if (existing >= 0) {
    state.videoOverlays.splice(existing, 1);
    btn.classList.remove('active');
    rebuildOverlayList();
    return;
  }
  const ov = { id: Date.now(), builtin: type, name: btn.textContent, opacity: 0.5, blendMode: 'screen' };
  state.videoOverlays.push(ov);
  btn.classList.add('active');
  rebuildOverlayList();
});

document.getElementById('addVideoOverlayBtn').addEventListener('click', () => document.getElementById('videoOverlayInput').click());
document.getElementById('videoOverlayInput').addEventListener('change', e => {
  for (const file of e.target.files) {
    if (!file.type.startsWith('video/')) continue;
    const vid = document.createElement('video');
    vid.src = URL.createObjectURL(file);
    vid.loop = true;
    vid.muted = true;
    vid.playsInline = true;
    vid.play();
    const ov = { id: Date.now() + Math.random(), video: vid, name: file.name, opacity: 0.5, blendMode: 'screen' };
    state.videoOverlays.push(ov);
    rebuildOverlayList();
  }
  e.target.value = '';
});
document.getElementById('clearVideoOverlaysBtn').addEventListener('click', () => {
  for (const ov of state.videoOverlays) {
    if (ov.video) { ov.video.pause(); URL.revokeObjectURL(ov.video.src); }
  }
  state.videoOverlays = [];
  document.querySelectorAll('#builtinOverlayGrid .dev-btn').forEach(b => b.classList.remove('active'));
  rebuildOverlayList();
});

function rebuildOverlayList() {
  const list = document.getElementById('videoOverlayList');
  list.innerHTML = '';
  state.videoOverlays.forEach((ov, i) => {
    const row = document.createElement('div');
    row.style.cssText = 'margin-bottom:8px;padding:6px;background:rgba(255,255,255,0.03);border-radius:6px;border:1px solid rgba(255,255,255,0.06)';
    row.innerHTML = `
      <div style="display:flex;align-items:center;justify-content:space-between;margin-bottom:4px">
        <span style="font-size:9px;color:#aaa;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;max-width:120px">${ov.name}</span>
        <button class="btn btn-danger" data-ov-remove="${i}" style="padding:2px 6px;font-size:8px">X</button>
      </div>
      <div class="prop-row" style="margin-bottom:2px"><label style="font-size:9px">Blend</label>
        <select data-ov-blend="${i}" style="font-size:9px;background:rgba(255,255,255,0.07);border:1px solid rgba(255,255,255,0.1);border-radius:4px;color:#ccc;padding:2px 4px">
          <option value="screen"${ov.blendMode==='screen'?' selected':''}>Screen</option>
          <option value="lighter"${ov.blendMode==='lighter'?' selected':''}>Add</option>
          <option value="overlay"${ov.blendMode==='overlay'?' selected':''}>Overlay</option>
          <option value="multiply"${ov.blendMode==='multiply'?' selected':''}>Multiply</option>
          <option value="soft-light"${ov.blendMode==='soft-light'?' selected':''}>Soft Light</option>
          <option value="color-dodge"${ov.blendMode==='color-dodge'?' selected':''}>Dodge</option>
          <option value="source-over"${ov.blendMode==='source-over'?' selected':''}>Normal</option>
        </select>
      </div>
      <div class="prop-row"><label style="font-size:9px">Opacity</label>
        <input type="range" data-ov-opacity="${i}" min="0" max="100" value="${Math.round(ov.opacity*100)}" style="flex:1">
        <span style="font-size:8px;color:#666;min-width:24px">${Math.round(ov.opacity*100)}%</span>
      </div>
    `;
    list.appendChild(row);
  });
  // Bind events
  list.querySelectorAll('[data-ov-remove]').forEach(btn => {
    btn.addEventListener('click', e => {
      const idx = parseInt(e.target.dataset.ovRemove);
      const ov = state.videoOverlays[idx];
      if (ov.video) {
        ov.video.pause();
        URL.revokeObjectURL(ov.video.src);
      }
      state.videoOverlays.splice(idx, 1);
      rebuildOverlayList();
    });
  });
  list.querySelectorAll('[data-ov-blend]').forEach(sel => {
    sel.addEventListener('change', e => {
      state.videoOverlays[parseInt(e.target.dataset.ovBlend)].blendMode = e.target.value;
    });
  });
  list.querySelectorAll('[data-ov-opacity]').forEach(slider => {
    slider.addEventListener('input', e => {
      const idx = parseInt(e.target.dataset.ovOpacity);
      state.videoOverlays[idx].opacity = parseInt(e.target.value) / 100;
      e.target.nextElementSibling.textContent = e.target.value + '%';
    });
  });
}

// Sync overlay playback with main video
function syncOverlays() {
  if (!hasVideo) return;
  for (const ov of state.videoOverlays) {
    if (!vtPlaying && !ov.video.paused) ov.video.pause();
    else if (vtPlaying && ov.video.paused) ov.video.play();
  }
  // Sync background video playback state
  if (state.bgVideo.enabled) {
    const bgVid = document.getElementById('bgVideo');
    if (bgVid) {
      if (!vtPlaying && !bgVid.paused) bgVid.pause();
      else if (vtPlaying && bgVid.paused) bgVid.play().catch(err => console.warn('BG video play prevented:', err));
    }
  }
}

// ============================================================
// LUT PRESET GENERATOR
// ============================================================
function generateLUTPreset(type) {
  const size = 8;
  const data = new Float32Array(size * size * size * 3);
  for (let b = 0; b < size; b++) {
    for (let g = 0; g < size; g++) {
      for (let r = 0; r < size; r++) {
        const idx = (b * size * size + g * size + r) * 3;
        let rf = r / (size - 1), gf = g / (size - 1), bf = b / (size - 1);
        if (type === 'cinematic') {
          // Lift shadows (blue), crush blacks slightly, warm highlights
          rf = Math.pow(rf, 0.95) * 1.05;
          gf = Math.pow(gf, 1.0) * 0.95;
          bf = Math.pow(bf, 0.85) * 0.9 + 0.05;
          // Desaturate shadows
          const lum = 0.299*rf + 0.587*gf + 0.114*bf;
          const shadowMix = Math.max(0, 1 - lum * 2.5);
          rf = rf + (lum - rf) * shadowMix * 0.3;
          gf = gf + (lum - gf) * shadowMix * 0.3;
        } else if (type === 'warmVintage') {
          rf = Math.pow(rf, 0.85) * 1.1;
          gf = Math.pow(gf, 0.95) * 0.95;
          bf = Math.pow(bf, 1.15) * 0.8;
          // Fade blacks
          rf = rf * 0.9 + 0.06; gf = gf * 0.88 + 0.04; bf = bf * 0.85 + 0.03;
        } else if (type === 'coolTeal') {
          rf = Math.pow(rf, 1.1) * 0.85;
          gf = Math.pow(gf, 0.95) * 1.0;
          bf = Math.pow(bf, 0.9) * 1.1;
          // Add teal to midtones
          const mid = Math.sin(gf * Math.PI);
          gf += mid * 0.06; bf += mid * 0.08;
        } else if (type === 'bleachBypass') {
          const lum = 0.299*rf + 0.587*gf + 0.114*bf;
          rf = rf + (lum - rf) * 0.5;
          gf = gf + (lum - gf) * 0.5;
          bf = bf + (lum - bf) * 0.5;
          // High contrast
          rf = Math.pow(rf, 1.3); gf = Math.pow(gf, 1.3); bf = Math.pow(bf, 1.3);
        } else if (type === 'moody') {
          rf = Math.pow(rf, 1.2) * 0.9;
          gf = Math.pow(gf, 1.15) * 0.85;
          bf = Math.pow(bf, 0.95) * 0.95;
          // Crush blacks, tint shadows blue
          const dark = Math.max(0, 1 - (rf + gf + bf));
          bf += dark * 0.08;
          rf = rf * 0.92 + 0.02; gf = gf * 0.9 + 0.015; bf = bf * 0.93 + 0.03;
        } else if (type === 'orangeTeal') {
          // Push shadows teal, highlights orange
          const lum = 0.299*rf + 0.587*gf + 0.114*bf;
          if (lum < 0.5) {
            rf -= (0.5 - lum) * 0.15;
            gf += (0.5 - lum) * 0.05;
            bf += (0.5 - lum) * 0.15;
          } else {
            rf += (lum - 0.5) * 0.2;
            gf += (lum - 0.5) * 0.05;
            bf -= (lum - 0.5) * 0.15;
          }
          rf = Math.pow(Math.max(0, rf), 0.95);
          gf = Math.pow(Math.max(0, gf), 1.0);
          bf = Math.pow(Math.max(0, bf), 1.05);
        } else if (type === 'bw') {
          const lum = 0.299*rf + 0.587*gf + 0.114*bf;
          // Film-like B&W with slight warm tone
          rf = Math.pow(lum, 0.9) * 1.02;
          gf = Math.pow(lum, 0.95) * 0.98;
          bf = Math.pow(lum, 1.05) * 0.95;
        }
        data[idx] = Math.min(1, Math.max(0, rf));
        data[idx+1] = Math.min(1, Math.max(0, gf));
        data[idx+2] = Math.min(1, Math.max(0, bf));
      }
    }
  }
  return { size, data, title: type };
}

// ============================================================
// LUT CONTROLS
// ============================================================
document.getElementById('lutPresetGrid').addEventListener('click', e => {
  const btn = e.target.closest('.dev-btn');
  if (!btn) return;
  pushUndoState();
  const preset = btn.dataset.lutPreset;
  document.querySelectorAll('#lutPresetGrid .dev-btn').forEach(b => b.classList.remove('active'));
  if (preset === 'none') {
    state.lut = { enabled: false, data: null, size: 0, intensity: 1.0, name: '', _presetKey: '' };
    document.getElementById('lutInfo').textContent = '';
    document.getElementById('lutControls').style.display = 'none';
    return;
  }
  btn.classList.add('active');
  const lut = generateLUTPreset(preset);
  state.lut.data = lut;
  state.lut.size = lut.size;
  state.lut.enabled = true;
  state.lut.name = btn.textContent;
  state.lut._presetKey = preset;
  document.getElementById('lutInfo').innerHTML = '<span style="color:#4ade80">Active:</span> ' + btn.textContent;
  document.getElementById('lutControls').style.display = 'block';
  showToast('Color grade: ' + btn.textContent + ' applied', 'info');
});

document.getElementById('loadLutBtn').addEventListener('click', () => document.getElementById('lutFileInput').click());
document.getElementById('lutFileInput').addEventListener('change', e => {
  const file = e.target.files[0];
  if (!file) return;
  pushUndoState();
  const reader = new FileReader();
  reader.onload = () => {
    const lut = parseCubeLUT(reader.result);
    if (!lut) { document.getElementById('lutInfo').textContent = 'Invalid .CUBE file'; return; }
    state.lut.data = lut;
    state.lut.size = lut.size;
    state.lut.enabled = true;
    state.lut.name = lut.title || file.name;
    state.lut._presetKey = '';
    document.getElementById('lutInfo').innerHTML = '<span style="color:#4ade80">Loaded:</span> ' + state.lut.name + ' (' + lut.size + 'x' + lut.size + 'x' + lut.size + ')';
    document.getElementById('lutControls').style.display = 'block';
    showToast('Color grade: ' + state.lut.name + ' applied', 'info');
  };
  reader.readAsText(file);
  e.target.value = '';
});
document.getElementById('clearLutBtn').addEventListener('click', () => {
  pushUndoState();
  state.lut = { enabled: false, data: null, size: 0, intensity: 1.0, name: '' };
  document.getElementById('lutInfo').textContent = '';
  document.getElementById('lutControls').style.display = 'none';
  document.querySelectorAll('#lutPresetGrid .dev-btn').forEach(b => b.classList.remove('active'));
});
document.getElementById('lutIntensity').addEventListener('input', e => {
  state.lut.intensity = parseInt(e.target.value) / 100;
  document.getElementById('lutIntensityVal').textContent = e.target.value + '%';
});

// ============================================================
// ANIMATION PRESET CONTROLS
// ============================================================
document.getElementById('animPresetGrid').addEventListener('click', e => {
  const btn = e.target.closest('.dev-btn');
  if (!btn) return;
  pushUndoState();
  const anim = btn.dataset.anim;
  state.animPreset.type = anim;
  document.querySelectorAll('#animPresetGrid .dev-btn').forEach(b => b.classList.remove('active'));
  btn.classList.add('active');
  // Auto-setup audio analyser when selecting a preset that needs it
  if (anim !== 'none' && hasVideo && !audioAnalyser) setupAudioAnalyser();
});

document.getElementById('clearAnimPresetBtn').addEventListener('click', () => {
  state.animPreset.type = 'none';
  document.querySelectorAll('#animPresetGrid .dev-btn').forEach(b => b.classList.remove('active'));
  document.querySelector('#animPresetGrid .dev-btn[data-anim="none"]').classList.add('active');
});

document.getElementById('animIntensity').addEventListener('input', e => {
  state.animPreset.intensity = parseInt(e.target.value) / 100;
});

document.getElementById('animBPM').addEventListener('input', e => {
  state.animPreset.bpm = parseInt(e.target.value);
  document.getElementById('animBPMVal').textContent = e.target.value;
});

document.getElementById('autoBPMBtn').addEventListener('click', function() {
  pushUndoState();
  state.animPreset.autoBPM = !state.animPreset.autoBPM;
  this.classList.toggle('active', state.animPreset.autoBPM);
  this.textContent = state.animPreset.autoBPM ? 'On' : 'Off';
  document.getElementById('animBPM').disabled = state.animPreset.autoBPM;
  document.getElementById('autoBPMStatus').textContent = state.animPreset.autoBPM ? 'Listening...' : '';
  if (state.animPreset.autoBPM && hasVideo) setupAudioAnalyser();
});

// CapCut Draft Import
document.getElementById('importCapcutBtn').addEventListener('click', () => {
  document.getElementById('capcutFileInput').click();
});

document.getElementById('capcutFileInput').addEventListener('change', e => {
  const file = e.target.files[0];
  if (!file) return;
  const reader = new FileReader();
  reader.onload = ev => {
    try {
      const json = JSON.parse(ev.target.result);
      importedKeyframes = parseCapcutDraft(json);
      if (importedKeyframes.length > 0) {
        state.animPreset.type = 'capcut_imported';
        document.querySelectorAll('#animPresetGrid .dev-btn').forEach(b => b.classList.remove('active'));
        // Show feedback
        const statusEl = document.getElementById('importCapcutBtn');
        statusEl.textContent = `Imported ${importedKeyframes.length} keyframes`;
        statusEl.style.borderColor = 'rgba(96,165,250,0.4)';
        setTimeout(() => {
          statusEl.textContent = 'Import CapCut Draft';
          statusEl.style.borderColor = '';
        }, 3000);
      } else {
        alert('No animation keyframes found in this file. Make sure it is a draft_content.json from a CapCut Desktop project.');
      }
    } catch (err) {
      alert('Could not parse file: ' + err.message);
    }
  };
  reader.readAsText(file);
});

document.getElementById('resetOverlaysBtn').addEventListener('click', () => {
  // Reset progress bar
  state.progressBar.enabled = false;
  document.getElementById('progressToggle').value = 'false';
  // Reset waveform
  state.waveform.enabled = false;
  document.getElementById('waveformToggle').value = 'false';
  // Reset glassmorphism
  state.glassmorphism.enabled = false;
  state.glassmorphism.x = -1;
  state.glassmorphism.y = -1;
  document.getElementById('glassToggle').value = 'false';
  document.getElementById('glassControls').style.display = 'none';
});

// ============================================================
// PROJECT SAVE / LOAD / RESET
// ============================================================
document.getElementById('saveProjectBtn').addEventListener('click', () => {
  const data = JSON.stringify(getSerializableState(), null, 2);
  const blob = new Blob([data], { type: 'application/json' });
  const a = document.createElement('a');
  a.download = 'mockup-project-' + Date.now() + '.json';
  a.href = URL.createObjectURL(blob);
  a.click();
  showToast('Project saved', 'success');
});

document.getElementById('loadProjectBtn').addEventListener('click', () => {
  document.getElementById('projectFileInput').click();
});

document.getElementById('projectFileInput').addEventListener('change', e => {
  const file = e.target.files[0];
  if (!file) return;
  const reader = new FileReader();
  reader.onload = () => {
    try {
      const s = JSON.parse(reader.result);
      if (!s || !s.device) { showToast('Invalid project file', 'error'); return; }
      applyStateToUI(s);
      updateHandOverlayUI();
      saveState();
      showToast('Project loaded: ' + file.name, 'success');
    } catch (err) {
      showToast('Failed to parse project file', 'error');
    }
  };
  reader.readAsText(file);
  e.target.value = '';
});

document.getElementById('resetAllBtn').addEventListener('click', () => {
  if (!confirm('Reset all settings to defaults? This cannot be undone.')) return;
  localStorage.removeItem(STORAGE_KEY);
  location.reload();
});

// Load saved state on startup (must be after all DOM refs are initialized)
loadState();
updateHandOverlayUI();

// ============================================================
// DEVICE DRAGGING
// ============================================================
let isDragging = false;
let dragTarget = null; // 'device' or 'device2'
let dragStartX = 0;
let dragStartY = 0;
let dragOffsetX = 0;
let dragOffsetY = 0;

canvas.addEventListener('mousedown', e => {
  const rect = canvas.getBoundingClientRect();
  const scaleX = canvas.width / rect.width;
  const scaleY = canvas.height / rect.height;
  const mx = (e.clientX - rect.left) * scaleX;
  const my = (e.clientY - rect.top) * scaleY;

  // Check if clicking on a device (simple hit test based on position)
  const sz = getCanvasSize();
  const dc = calcDevicePosition(sz.w, sz.h);

  // Check device 1
  if (state.device.type !== 'none') {
    const dev = DEVICES[state.device.type];
    let devW = dev.baseW, devH = dev.baseH;
    if (state.device.landscape) { let t = devW; devW = devH; devH = t; }
    const devRect = {
      x: dc.devX,
      y: dc.devY,
      w: devW * dc.devScale,
      h: devH * dc.devScale
    };
    if (mx >= devRect.x && mx <= devRect.x + devRect.w &&
        my >= devRect.y && my <= devRect.y + devRect.h) {
      isDragging = true;
      dragTarget = 'device';
      dragStartX = mx;
      dragStartY = my;
      dragOffsetX = state.device.x;
      dragOffsetY = state.device.y;
      canvas.style.cursor = 'grabbing';
      return;
    }
  }

  // Check device 2 if in comparison mode
  if (dc.isComparing) {
    const dev2 = DEVICES[state.comparison.device2.type];
    if (dev2) {
      let d2W = dev2.baseW, d2H = dev2.baseH;
      if (state.device.landscape) { let t = d2W; d2W = d2H; d2H = t; }
      const padFrac = 0.12;
      const areaW = sz.w * 0.45;
      const availW2 = areaW * (1 - padFrac*2);
      const availH2 = sz.h * (1 - padFrac*2);
      const fitScale2 = Math.min(availW2 / d2W, availH2 / d2H);
      const d2Scale = fitScale2 * state.device.scale;
      const d2Rect = {
        x: sz.w * 0.75 - (d2W * d2Scale) / 2 + state.comparison.x,
        y: (sz.h - d2H * d2Scale) / 2 + state.comparison.y,
        w: d2W * d2Scale,
        h: d2H * d2Scale
      };
      if (mx >= d2Rect.x && mx <= d2Rect.x + d2Rect.w &&
          my >= d2Rect.y && my <= d2Rect.y + d2Rect.h) {
        isDragging = true;
        dragTarget = 'device2';
        dragStartX = mx;
        dragStartY = my;
        dragOffsetX = state.comparison.x;
        dragOffsetY = state.comparison.y;
        canvas.style.cursor = 'grabbing';
        return;
      }
    }
  }
});

canvas.addEventListener('mousemove', e => {
  if (!isDragging) {
    // Show grab cursor when hovering over devices
    const rect = canvas.getBoundingClientRect();
    const scaleX = canvas.width / rect.width;
    const scaleY = canvas.height / rect.height;
    const mx = (e.clientX - rect.left) * scaleX;
    const my = (e.clientY - rect.top) * scaleY;

    const sz = getCanvasSize();
    const dc = calcDevicePosition(sz.w, sz.h);

    let overDevice = false;

    // Check device 1
    if (state.device.type !== 'none') {
      const dev = DEVICES[state.device.type];
      let devW = dev.baseW, devH = dev.baseH;
      if (state.device.landscape) { let t = devW; devW = devH; devH = t; }
      const devRect = {
        x: dc.devX,
        y: dc.devY,
        w: devW * dc.devScale,
        h: devH * dc.devScale
      };
      if (mx >= devRect.x && mx <= devRect.x + devRect.w &&
          my >= devRect.y && my <= devRect.y + devRect.h) {
        overDevice = true;
      }
    }

    // Check device 2
    if (!overDevice && dc.isComparing) {
      const dev2 = DEVICES[state.comparison.device2.type];
      if (dev2) {
        let d2W = dev2.baseW, d2H = dev2.baseH;
        if (state.device.landscape) { let t = d2W; d2W = d2H; d2H = t; }
        const padFrac = 0.12;
        const areaW = sz.w * 0.45;
        const availW2 = areaW * (1 - padFrac*2);
        const availH2 = sz.h * (1 - padFrac*2);
        const fitScale2 = Math.min(availW2 / d2W, availH2 / d2H);
        const d2Scale = fitScale2 * state.device.scale;
        const d2Rect = {
          x: sz.w * 0.75 - (d2W * d2Scale) / 2 + state.comparison.x,
          y: (sz.h - d2H * d2Scale) / 2 + state.comparison.y,
          w: d2W * d2Scale,
          h: d2H * d2Scale
        };
        if (mx >= d2Rect.x && mx <= d2Rect.x + d2Rect.w &&
            my >= d2Rect.y && my <= d2Rect.y + d2Rect.h) {
          overDevice = true;
        }
      }
    }

    canvas.style.cursor = overDevice ? 'grab' : 'default';
    return;
  }

  const rect = canvas.getBoundingClientRect();
  const scaleX = canvas.width / rect.width;
  const scaleY = canvas.height / rect.height;
  const mx = (e.clientX - rect.left) * scaleX;
  const my = (e.clientY - rect.top) * scaleY;

  const deltaX = mx - dragStartX;
  const deltaY = my - dragStartY;

  if (dragTarget === 'device') {
    state.device.x = dragOffsetX + deltaX;
    state.device.y = dragOffsetY + deltaY;
  } else if (dragTarget === 'device2') {
    state.comparison.x = dragOffsetX + deltaX;
    state.comparison.y = dragOffsetY + deltaY;
  }
});

canvas.addEventListener('mouseup', () => {
  if (isDragging) {
    pushUndoState();
    scheduleSave();
  }
  isDragging = false;
  dragTarget = null;
  canvas.style.cursor = 'default';
});

canvas.addEventListener('mouseleave', () => {
  if (isDragging) {
    pushUndoState();
    scheduleSave();
  }
  isDragging = false;
  dragTarget = null;
  canvas.style.cursor = 'default';
});

// ============================================================
// TOOLTIP SYSTEM
// ============================================================
const tooltip = document.getElementById('tooltip');
const tooltipContent = tooltip ? tooltip.querySelector('.tooltip-content') : null;

if (tooltip && tooltipContent) {
  document.querySelectorAll('[data-tooltip]').forEach(el => {
    el.addEventListener('mouseenter', e => {
      const text = el.dataset.tooltip;
      if (!text) return;

      tooltipContent.textContent = text;
      tooltip.classList.add('visible');

      const rect = el.getBoundingClientRect();
      const tooltipRect = tooltip.getBoundingClientRect();

      // Position tooltip above the element
      const left = rect.left + rect.width / 2;
      const top = rect.bottom + 8;

      tooltip.style.left = left + 'px';
      tooltip.style.top = top + 'px';
      tooltip.style.transform = 'translateX(-50%)';
    });

    el.addEventListener('mouseleave', () => {
      tooltip.classList.remove('visible');
    });
  });

  // Hide tooltip on scroll to prevent positioning issues
  window.addEventListener('scroll', () => {
    tooltip.classList.remove('visible');
  }, true); // Use capture to catch all scroll events
}

// ============================================================
// WELCOME MODAL
// ============================================================
const hasSeenWelcome = localStorage.getItem('mockupStudioWelcomeSeen');
const welcomeOverlay = document.getElementById('welcomeOverlay');
const dismissWelcome = document.getElementById('dismissWelcome');

if (!hasSeenWelcome && welcomeOverlay) {
  welcomeOverlay.classList.add('open');
}

if (dismissWelcome) {
  dismissWelcome.addEventListener('click', () => {
    welcomeOverlay.classList.remove('open');
    localStorage.setItem('mockupStudioWelcomeSeen', 'true');
  });
}

// ============================================================
// THEME MANAGEMENT
// ============================================================
// Initialize theme from localStorage or default to dark
const savedTheme = localStorage.getItem('mockupStudioTheme') || 'dark';
document.documentElement.setAttribute('data-theme', savedTheme);

// Theme toggle button
const themeToggleBtn = document.getElementById('themeToggleBtn');
const themeToggleIcon = document.getElementById('themeToggleIcon');

if (themeToggleBtn && themeToggleIcon) {
  // Set initial icon based on current theme
  function updateThemeIcon(theme) {
    themeToggleIcon.setAttribute('data-lucide', theme === 'dark' ? 'sun' : 'moon');
    if (typeof lucide !== 'undefined') {
      lucide.createIcons();
    }
  }

  // Set initial icon
  updateThemeIcon(savedTheme);

  // Toggle theme on click
  themeToggleBtn.addEventListener('click', () => {
    const current = document.documentElement.getAttribute('data-theme');
    const newTheme = current === 'dark' ? 'light' : 'dark';

    // Apply theme
    document.documentElement.setAttribute('data-theme', newTheme);
    localStorage.setItem('mockupStudioTheme', newTheme);

    // Update icon
    updateThemeIcon(newTheme);

    // Show toast
    showToast(`Switched to ${newTheme} theme`, 'success');
  });
}

// ============================================================
// DEVICE KEYFRAME CONTROLS
// ============================================================

// Add device keyframe at current time
const addDeviceKeyframeBtn = document.getElementById('addDeviceKeyframeBtn');
if (addDeviceKeyframeBtn) {
  addDeviceKeyframeBtn.addEventListener('click', () => {
    if (!hasVideo) {
      showToast('Load a video first', 'error');
      return;
    }

    pushUndoState();

    const kf = {
      time: vtTime,
      x: state.device.x,
      y: state.device.y,
      scale: state.device.scale,
      rotation: 0,
      perspectiveX: state.perspective.x,
      perspectiveY: state.perspective.y
    };

    if (!state.deviceKeyframes) state.deviceKeyframes = [];
    state.deviceKeyframes.push(kf);
    state.deviceKeyframes.sort((a, b) => a.time - b.time);

    updateDeviceKeyframesList();
    scheduleSave();
    showToast(`Device keyframe added at ${vtTime.toFixed(2)}s`, 'success');
  });
}

// Clear all device keyframes
const clearDeviceKeyframesBtn = document.getElementById('clearDeviceKeyframesBtn');
if (clearDeviceKeyframesBtn) {
  clearDeviceKeyframesBtn.addEventListener('click', () => {
    if (!state.deviceKeyframes || state.deviceKeyframes.length === 0) return;

    if (confirm('Delete all device keyframes?')) {
      pushUndoState();
      state.deviceKeyframes = [];
      updateDeviceKeyframesList();
      scheduleSave();
      showToast('Device keyframes cleared', 'info');
    }
  });
}

// Update device keyframes list display
function updateDeviceKeyframesList() {
  const list = document.getElementById('deviceKeyframesList');
  if (!list) return;

  const keyframes = state.deviceKeyframes || [];
  if (keyframes.length === 0) {
    list.innerHTML = '<div style="padding:8px;color:rgba(255,255,255,0.3);text-align:center">No keyframes</div>';
    return;
  }

  list.innerHTML = '';
  keyframes.forEach((kf, i) => {
    const item = document.createElement('div');
    item.className = 'keyframe-item';
    item.style.cssText = 'display:flex;align-items:center;gap:8px;padding:6px;background:rgba(255,255,255,0.05);border-radius:4px;margin-bottom:4px';

    const info = document.createElement('span');
    info.style.cssText = 'flex:1;font-size:11px';
    info.textContent = `${kf.time.toFixed(2)}s: pos(${kf.x.toFixed(0)}, ${kf.y.toFixed(0)}) scale(${kf.scale.toFixed(2)})`;

    const deleteBtn = document.createElement('button');
    deleteBtn.className = 'btn-icon';
    deleteBtn.title = 'Delete';
    deleteBtn.style.cssText = 'background:rgba(255,0,0,0.2);border:none;color:#fff;padding:2px 6px;border-radius:3px;cursor:pointer;font-size:12px';
    deleteBtn.textContent = '';
    deleteBtn.addEventListener('click', () => deleteDeviceKeyframe(i));

    item.appendChild(info);
    item.appendChild(deleteBtn);
    list.appendChild(item);
  });
}

// Delete specific device keyframe
function deleteDeviceKeyframe(index) {
  pushUndoState();
  state.deviceKeyframes.splice(index, 1);
  updateDeviceKeyframesList();
  scheduleSave();
  showToast('Keyframe deleted', 'info');
}

// Make function globally accessible for compatibility
window.deleteDeviceKeyframe = deleteDeviceKeyframe;

// ============================================================
// STANDSTILL MODE CONTROLS
// ============================================================

// Standstill mode selector
const standstillModeSelect = document.getElementById('standstillModeSelect');
if (standstillModeSelect) {
  standstillModeSelect.addEventListener('change', (e) => {
    if (!state.standstill) state.standstill = { mode: 'none', freezeTime: 0, contentLoop: { enabled: false, start: 0, end: 1 } };

    pushUndoState();
    state.standstill.mode = e.target.value;

    // Show/hide controls based on mode
    const freezeControl = document.getElementById('freezeTimeControl');
    const contentLoopControl = document.getElementById('contentLoopControl');

    if (freezeControl) {
      freezeControl.style.display = (e.target.value === 'freezeDevice' || e.target.value === 'freezeBoth') ? 'block' : 'none';
    }
    if (contentLoopControl) {
      contentLoopControl.style.display = (e.target.value === 'freezeDevice') ? 'block' : 'none';
    }

    scheduleSave();
    showToast(`Standstill mode: ${e.target.value}`, 'info');
  });
}

// Set freeze time to current playback time
const setFreezeTimeBtn = document.getElementById('setFreezeTimeBtn');
if (setFreezeTimeBtn) {
  setFreezeTimeBtn.addEventListener('click', () => {
    if (!hasVideo) return;
    if (!state.standstill) state.standstill = { mode: 'none', freezeTime: 0, contentLoop: { enabled: false, start: 0, end: 1 } };
    state.standstill.freezeTime = vtTime;
    document.getElementById('freezeTimeInput').value = vtTime.toFixed(2);
    scheduleSave();
    showToast(`Freeze time set to ${vtTime.toFixed(2)}s`, 'success');
  });
}

// Freeze time input manual control
document.getElementById('freezeTimeInput')?.addEventListener('input', (e) => {
  if (!state.standstill) state.standstill = { mode: 'none', freezeTime: 0, contentLoop: { enabled: false, start: 0, end: 1 } };
  state.standstill.freezeTime = parseFloat(e.target.value);
  scheduleSave();
});

// Content loop controls for standstill mode
document.getElementById('contentLoopStart')?.addEventListener('input', (e) => {
  if (!state.standstill) state.standstill = { mode: 'none', freezeTime: 0, contentLoop: { enabled: false, start: 0, end: 1 } };
  state.standstill.contentLoop.start = parseFloat(e.target.value);
  scheduleSave();
});

document.getElementById('contentLoopEnd')?.addEventListener('input', (e) => {
  if (!state.standstill) state.standstill = { mode: 'none', freezeTime: 0, contentLoop: { enabled: false, start: 0, end: 1 } };
  state.standstill.contentLoop.end = parseFloat(e.target.value);
  scheduleSave();
});

// ============================================================
// LUCIDE ICONS INITIALIZATION
// ============================================================
// Initialize Lucide icons after DOM is ready
if (typeof lucide !== 'undefined') {
  lucide.createIcons();
}


// ============================================================
// ENHANCED TIMELINE SYSTEM
// Background video controls and multi-track timeline management
// ============================================================

// Helper function to format time in MM:SS
function formatTime(seconds) {
  if (!seconds || isNaN(seconds)) return '0:00';
  const mins = Math.floor(seconds / 60);
  const secs = Math.floor(seconds % 60);
  return `${mins}:${secs.toString().padStart(2, '0')}`;
}

// Background video playback state
let bgVideoPlaying = false;
let bgVideoLoop = true;
let bgVideoSynced = true;
let bgVideoSpeed = 1;

// Background audio playback state
let bgAudioPlaying = false;
let bgAudioLoop = false;
let bgAudioSynced = true;
let bgAudioSpeed = 1;
let bgAudioVolume = 1;

// ============================================================
// BACKGROUND VIDEO ACTIONS
// ============================================================
const BG_VIDEO_ACTIONS = {
  fadeIn: {
    name: 'Fade In (0100%)',
    apply: (duration = 2000) => {
      const startTime = performance.now();
      const initialOpacity = state.bgVideo.opacity;

      function animate() {
        const elapsed = performance.now() - startTime;
        const progress = Math.min(elapsed / duration, 1);
        state.bgVideo.opacity = initialOpacity + (1 - initialOpacity) * progress;
        document.getElementById('bgVideoOpacity').value = state.bgVideo.opacity * 100;
        document.getElementById('bgVideoOpacityVal').textContent = Math.round(state.bgVideo.opacity * 100) + '%';

        if (progress < 1) requestAnimationFrame(animate);
        else scheduleSave();
      }
      animate();
      showToast('Fade in started', 'info');
    }
  },
  fadeOut: {
    name: 'Fade Out (1000%)',
    apply: (duration = 2000) => {
      const startTime = performance.now();
      const initialOpacity = state.bgVideo.opacity;

      function animate() {
        const elapsed = performance.now() - startTime;
        const progress = Math.min(elapsed / duration, 1);
        state.bgVideo.opacity = initialOpacity * (1 - progress);
        document.getElementById('bgVideoOpacity').value = state.bgVideo.opacity * 100;
        document.getElementById('bgVideoOpacityVal').textContent = Math.round(state.bgVideo.opacity * 100) + '%';

        if (progress < 1) requestAnimationFrame(animate);
        else scheduleSave();
      }
      animate();
      showToast('Fade out started', 'info');
    }
  },
  overlayMode: {
    name: 'Overlay Mode',
    apply: () => {
      pushUndoState();
      state.bgVideo.opacity = 0.5;
      state.bgVideo.fit = 'cover';
      document.getElementById('bgVideoOpacity').value = 50;
      document.getElementById('bgVideoOpacityVal').textContent = '50%';
      document.getElementById('bgVideoFit').value = 'cover';
      scheduleSave();
      showToast('Overlay mode applied', 'info');
    }
  },
  syncPerfect: {
    name: 'Sync Perfect',
    apply: () => {
      const bgVideo = document.getElementById('bgVideo');
      if (!bgVideo) return;
      bgVideoSynced = true;
      document.getElementById('bgSyncBtn')?.classList.add('synced');
      bgVideo.currentTime = vtTime;
      showToast('Background synced to main', 'success');
    }
  },
  speedSlow: {
    name: 'Slow Motion (0.5x)',
    apply: () => {
      pushUndoState();
      bgVideoSpeed = 0.5;
      const bgVideo = document.getElementById('bgVideo');
      if (bgVideo) bgVideo.playbackRate = 0.5;
      document.getElementById('bgSpeedSelect').value = '0.5';
      scheduleSave();
      showToast('Background speed: 0.5', 'info');
    }
  },
  speedFast: {
    name: 'Fast Forward (2x)',
    apply: () => {
      pushUndoState();
      bgVideoSpeed = 2;
      const bgVideo = document.getElementById('bgVideo');
      if (bgVideo) bgVideo.playbackRate = 2;
      document.getElementById('bgSpeedSelect').value = '2';
      scheduleSave();
      showToast('Background speed: 2', 'info');
    }
  },
  enableLoop: {
    name: 'Enable Loop',
    apply: () => {
      const bgVideo = document.getElementById('bgVideo');
      if (!bgVideo) return;
      bgVideoLoop = true;
      bgVideo.loop = true;
      document.getElementById('bgLoopBtn')?.classList.add('active');
      showToast('Background loop enabled', 'success');
    }
  },
  resetToStart: {
    name: 'Reset to Start',
    apply: () => {
      const bgVideo = document.getElementById('bgVideo');
      if (!bgVideo) return;
      bgVideo.currentTime = 0;
      updateBgVideoDisplay();
      showToast('Background reset to start', 'info');
    }
  },
  blurBackground: {
    name: 'Blur Background',
    apply: () => {
      pushUndoState();
      const bgVideo = document.getElementById('bgVideo');
      if (bgVideo) {
        bgVideo.style.filter = 'blur(10px)';
      }
      showToast('Background blurred', 'info');
    }
  },
  blackAndWhite: {
    name: 'Black & White',
    apply: () => {
      pushUndoState();
      const bgVideo = document.getElementById('bgVideo');
      if (bgVideo) {
        bgVideo.style.filter = 'grayscale(100%)';
      }
      showToast('Grayscale applied', 'info');
    }
  },
  splitScreen: {
    name: 'Split Screen (50/50)',
    apply: () => {
      pushUndoState();
      state.bgVideo.fit = 'contain';
      scheduleSave();
      showToast('Split screen layout', 'info');
    }
  },
  resetFilters: {
    name: 'Reset Filters',
    apply: () => {
      pushUndoState();
      const bgVideo = document.getElementById('bgVideo');
      if (bgVideo) {
        bgVideo.style.filter = '';
      }
      showToast('Filters reset', 'info');
    }
  },
};

function applyBgVideoAction(key, ...params) {
  const action = BG_VIDEO_ACTIONS[key];
  if (!action || !state.bgVideo.enabled) return;
  action.apply(...params);
}

// ============================================================
// BACKGROUND AUDIO ACTIONS
// ============================================================
const BG_AUDIO_ACTIONS = {
  fadeInAudio: {
    name: 'Fade In Audio',
    apply: (duration = 2000) => {
      const startTime = performance.now();
      const initialVolume = bgAudioVolume;

      function animate() {
        const elapsed = performance.now() - startTime;
        const progress = Math.min(elapsed / duration, 1);
        bgAudioVolume = initialVolume + (1 - initialVolume) * progress;
        const bgAudio = document.getElementById('bgAudio');
        if (bgAudio) bgAudio.volume = bgAudioVolume;
        document.getElementById('audioVolumeSlider').value = bgAudioVolume * 100;

        if (progress < 1) requestAnimationFrame(animate);
        else { state.bgAudio.volume = bgAudioVolume; scheduleSave(); }
      }
      animate();
      showToast('Audio fade in started', 'info');
    }
  },
  fadeOutAudio: {
    name: 'Fade Out Audio',
    apply: (duration = 2000) => {
      const startTime = performance.now();
      const initialVolume = bgAudioVolume;

      function animate() {
        const elapsed = performance.now() - startTime;
        const progress = Math.min(elapsed / duration, 1);
        bgAudioVolume = initialVolume * (1 - progress);
        const bgAudio = document.getElementById('bgAudio');
        if (bgAudio) bgAudio.volume = bgAudioVolume;
        document.getElementById('audioVolumeSlider').value = bgAudioVolume * 100;

        if (progress < 1) requestAnimationFrame(animate);
        else { state.bgAudio.volume = bgAudioVolume; scheduleSave(); }
      }
      animate();
      showToast('Audio fade out started', 'info');
    }
  },
  ducking: {
    name: 'Ducking (30%)',
    apply: () => {
      pushUndoState();
      bgAudioVolume = 0.3;
      const bgAudio = document.getElementById('bgAudio');
      if (bgAudio) bgAudio.volume = 0.3;
      document.getElementById('audioVolumeSlider').value = 30;
      state.bgAudio.volume = 0.3;
      scheduleSave();
      showToast('Audio ducking: 30% volume', 'info');
    }
  },
  loopBeat: {
    name: 'Loop Beat',
    apply: () => {
      const bgAudio = document.getElementById('bgAudio');
      if (!bgAudio) return;
      bgAudioLoop = true;
      bgAudio.loop = true;
      state.bgAudio.loop = true;
      document.getElementById('audioLoopBtn')?.classList.add('active');
      scheduleSave();
      showToast('Audio loop enabled', 'success');
    }
  },
  speedMatch: {
    name: 'Speed Match',
    apply: () => {
      pushUndoState();
      bgAudioSpeed = state.timeline.speed;
      const bgAudio = document.getElementById('bgAudio');
      if (bgAudio) bgAudio.playbackRate = bgAudioSpeed;
      document.getElementById('audioSpeedSelect').value = bgAudioSpeed.toString();
      state.bgAudio.speed = bgAudioSpeed;
      scheduleSave();
      showToast(`Audio speed matched: ${bgAudioSpeed}`, 'info');
    }
  },
  volumeBoost: {
    name: 'Volume Boost (100%)',
    apply: () => {
      pushUndoState();
      bgAudioVolume = 1.0;
      const bgAudio = document.getElementById('bgAudio');
      if (bgAudio) bgAudio.volume = 1.0;
      document.getElementById('audioVolumeSlider').value = 100;
      state.bgAudio.volume = 1.0;
      scheduleSave();
      showToast('Audio volume: 100%', 'info');
    }
  },
  syncAudio: {
    name: 'Sync to Main',
    apply: () => {
      const bgAudio = document.getElementById('bgAudio');
      if (!bgAudio) return;
      bgAudioSynced = true;
      document.getElementById('audioSyncBtn')?.classList.add('synced');
      bgAudio.currentTime = vtTime % bgAudio.duration;
      showToast('Audio synced to main', 'success');
    }
  },
  resetAudio: {
    name: 'Reset Audio',
    apply: () => {
      const bgAudio = document.getElementById('bgAudio');
      if (!bgAudio) return;
      bgAudio.currentTime = 0;
      updateAudioDisplay();
      showToast('Audio reset to start', 'info');
    }
  },
  fadeInSlow: {
    name: 'Fade In (5s)',
    apply: () => {
      applyBgAudioAction('fadeInAudio', 5000);
    }
  },
  fadeOutSlow: {
    name: 'Fade Out (5s)',
    apply: () => {
      applyBgAudioAction('fadeOutAudio', 5000);
    }
  },
  bassBoost: {
    name: 'Bass Boost',
    apply: () => {
      pushUndoState();
      showToast('Bass boost applied (placeholder)', 'info');
    }
  },
  reverb: {
    name: 'Add Reverb',
    apply: () => {
      pushUndoState();
      showToast('Reverb applied (placeholder)', 'info');
    }
  },
};

function applyBgAudioAction(key, ...params) {
  const action = BG_AUDIO_ACTIONS[key];
  if (!action || !state.bgAudio.enabled) return;
  action.apply(...params);
}

// Initialize enhanced timeline
function initEnhancedTimeline() {
  const timelineSystem = document.getElementById('timelineSystem');
  const bgVideoTrack = document.getElementById('bgVideoTrack');
  const bgVideo = document.getElementById('bgVideo');
  const bgAudio = document.getElementById('bgAudio');

  if (!timelineSystem) return;

  // Show timeline system when ANY media is loaded
  const hasBgVideo = state.bgVideo.enabled && bgVideo && bgVideo.src;
  const hasBgAudio = state.bgAudio.enabled && bgAudio && bgAudio.src;
  const shouldShowTimeline = hasVideo || hasBgVideo || hasBgAudio;

  if (shouldShowTimeline) {
    timelineSystem.classList.add('visible');
  }

  // Mark background video track as loaded when media is loaded
  if (state.bgVideo.enabled && bgVideo && bgVideo.src) {
    bgVideoTrack.classList.add('loaded');
  }
}

// ============================================================
// BACKGROUND VIDEO CONTROLS
// ============================================================

// Play/Pause background video
document.getElementById('bgTrackPlayBtn')?.addEventListener('click', () => {
  const bgVideo = document.getElementById('bgVideo');
  if (!bgVideo || !bgVideo.src) return;

  const playBtn = document.getElementById('bgTrackPlayBtn');
  const playIcon = playBtn.querySelector('.play-icon');
  const pauseIcon = playBtn.querySelector('.pause-icon');

  if (bgVideoPlaying) {
    bgVideo.pause();
    bgVideoPlaying = false;
    playIcon.style.display = 'block';
    pauseIcon.style.display = 'none';
    playBtn.classList.remove('playing');
  } else {
    bgVideo.play().catch(err => console.warn('BG video play prevented:', err));
    bgVideoPlaying = true;
    playIcon.style.display = 'none';
    pauseIcon.style.display = 'block';
    playBtn.classList.add('playing');
  }
});

// Toggle loop for background video
document.getElementById('bgLoopBtn')?.addEventListener('click', function() {
  const bgVideo = document.getElementById('bgVideo');
  if (!bgVideo) return;

  bgVideoLoop = !bgVideoLoop;
  bgVideo.loop = bgVideoLoop;
  this.classList.toggle('active', bgVideoLoop);

  showToast(bgVideoLoop ? 'Background loop enabled' : 'Background loop disabled', 'info');
});

// Background video speed control
document.getElementById('bgSpeedSelect')?.addEventListener('change', (e) => {
  const bgVideo = document.getElementById('bgVideo');
  if (!bgVideo) return;

  bgVideoSpeed = parseFloat(e.target.value);
  bgVideo.playbackRate = bgVideoSpeed;
  showToast(`Background speed: ${bgVideoSpeed}`, 'info');
});

// Background video scrubbing
const bgProgressTrack = document.getElementById('bgProgressTrack');
const bgProgressFill = document.getElementById('bgProgressFill');
let bgScrubbing = false;

bgProgressTrack?.addEventListener('mousedown', (e) => {
  const bgVideo = document.getElementById('bgVideo');
  if (!bgVideo || !bgVideo.duration) return;

  bgScrubbing = true;
  bgProgressTrack.classList.add('scrubbing');
  updateBgVideoTime(e);
});

document.addEventListener('mousemove', (e) => {
  if (!bgScrubbing) return;
  updateBgVideoTime(e);
});

document.addEventListener('mouseup', () => {
  if (bgScrubbing) {
    bgScrubbing = false;
    bgProgressTrack?.classList.remove('scrubbing');
  }
});

function updateBgVideoTime(e) {
  const bgVideo = document.getElementById('bgVideo');
  if (!bgVideo || !bgProgressTrack) return;

  const rect = bgProgressTrack.getBoundingClientRect();
  const x = Math.max(0, Math.min(e.clientX - rect.left, rect.width));
  const percent = x / rect.width;
  const newTime = percent * bgVideo.duration;

  bgVideo.currentTime = newTime;
  updateBgVideoDisplay();
}

// Sync background video with main video
document.getElementById('bgSyncBtn')?.addEventListener('click', function() {
  bgVideoSynced = !bgVideoSynced;
  this.classList.toggle('synced', bgVideoSynced);

  if (bgVideoSynced) {
    showToast('Background synced with main video', 'success');
    syncBgVideoWithMain();
  } else {
    showToast('Background independent playback', 'info');
  }
});

function syncBgVideoWithMain() {
  if (!bgVideoSynced) return;

  const bgVideo = document.getElementById('bgVideo');
  if (!bgVideo || !hasVideo) return;

  // Sync currentTime
  const mainTime = vtTime;
  if (bgVideo.duration > 0) {
    bgVideo.currentTime = mainTime % bgVideo.duration;
  }

  // Sync play/pause state
  if (vtPlaying && !bgVideoPlaying) {
    bgVideo.play().catch(err => console.warn('BG video sync play prevented:', err));
    bgVideoPlaying = true;
    updateBgPlayButtonState();
  } else if (!vtPlaying && bgVideoPlaying) {
    bgVideo.pause();
    bgVideoPlaying = false;
    updateBgPlayButtonState();
  }
}

function updateBgPlayButtonState() {
  const playBtn = document.getElementById('bgTrackPlayBtn');
  if (!playBtn) return;

  const playIcon = playBtn.querySelector('.play-icon');
  const pauseIcon = playBtn.querySelector('.pause-icon');

  if (bgVideoPlaying) {
    playIcon.style.display = 'none';
    pauseIcon.style.display = 'block';
    playBtn.classList.add('playing');
  } else {
    playIcon.style.display = 'block';
    pauseIcon.style.display = 'none';
    playBtn.classList.remove('playing');
  }
}

// Update background video display
function updateBgVideoDisplay() {
  const bgVideo = document.getElementById('bgVideo');
  const bgTimeDisplay = document.getElementById('bgTimeDisplay');

  if (!bgVideo || !bgTimeDisplay) return;

  const current = bgVideo.currentTime || 0;
  const duration = bgVideo.duration || 0;

  bgTimeDisplay.textContent = `${formatTime(current)} / ${formatTime(duration)}`;

  if (bgProgressFill && duration > 0) {
    const percent = (current / duration) * 100;
    bgProgressFill.style.width = `${percent}%`;
  }
}

// ============================================================
// MASTER PLAYBACK CONTROLS
// ============================================================

const masterPlayBtn = document.getElementById('masterPlayBtn');
masterPlayBtn?.addEventListener('click', () => {
  vtToggle();
  updateMasterPlayButtonState();
});

function updateMasterPlayButtonState() {
  const masterIconPlay = document.getElementById('masterIconPlay');
  const masterIconPause = document.getElementById('masterIconPause');

  if (vtPlaying) {
    masterIconPlay.style.display = 'none';
    masterIconPause.style.display = 'block';
    masterPlayBtn?.classList.add('playing');
  } else {
    masterIconPlay.style.display = 'block';
    masterIconPause.style.display = 'none';
    masterPlayBtn?.classList.remove('playing');
  }
}

// Update master time display
function updateMasterTimeDisplay() {
  const masterTimeDisplay = document.getElementById('masterTimeDisplay');
  if (!masterTimeDisplay || !hasVideo) return;

  const totalDur = vtGetTotalDuration();
  masterTimeDisplay.textContent = `${formatTime(vtTime)} / ${formatTime(totalDur)}`;
}

// ============================================================
// TIMELINE VISIBILITY
// ============================================================

function updateTimelineVisibility() {
  const timelineSystem = document.getElementById('timelineSystem');
  const bgVideoTrack = document.getElementById('bgVideoTrack');
  const bgAudioTrack = document.getElementById('bgAudioTrack');
  const bgVideo = document.getElementById('bgVideo');
  const bgAudio = document.getElementById('bgAudio');

  if (!timelineSystem) return;

  // Timeline always visible once ANY media is loaded
  const hasBgVideo = state.bgVideo.enabled && bgVideo?.src;
  const hasBgAudio = state.bgAudio.enabled && bgAudio?.src;
  const shouldShowTimeline = hasVideo || hasBgVideo || hasBgAudio;

  if (shouldShowTimeline) {
    timelineSystem.classList.add('visible');
  }

  // Mark tracks as loaded (for opacity change, not visibility)
  if (hasBgVideo) {
    bgVideoTrack?.classList.add('loaded');
  } else {
    bgVideoTrack?.classList.remove('loaded');
  }

  if (hasBgAudio) {
    bgAudioTrack?.classList.add('loaded');
  } else {
    bgAudioTrack?.classList.remove('loaded');
  }

  updateStageSpacing();
}

// ============================================================
// RENDER LOOP INTEGRATION
// ============================================================

// Call this in the main render loop to keep displays updated
function updateEnhancedTimelineDisplays() {
  if (!hasVideo) return;

  updateMasterTimeDisplay();
  updateBgVideoDisplay();
  updateAudioDisplay();

  // Sync background video if enabled
  if (bgVideoSynced) {
    syncBgVideoWithMain();
  }

  // Sync background audio if enabled
  if (bgAudioSynced) {
    syncAudioWithMain();
  }

  // Check loops
  checkLoops();
}

// ============================================================
// LOOP SYSTEM
// ============================================================

function checkLoops() {
  // Main video loop
  if (state.loops?.main?.enabled && hasVideo) {
    const loop = state.loops.main;
    const duration = vtGetTotalDuration();
    const loopStart = loop.start * duration;
    const loopEnd = loop.end * duration;

    if (vtTime >= loopEnd) {
      seekTo(loopStart);
    }
  }

  // Background video loop
  if (state.loops?.bgVideo?.enabled && state.bgVideo.enabled) {
    const bgVideo = document.getElementById('bgVideo');
    if (!bgVideo) return;

    const loop = state.loops.bgVideo;
    const duration = bgVideo.duration;
    if (!duration || isNaN(duration)) return;

    const loopStart = loop.start * duration;
    const loopEnd = loop.end * duration;

    if (bgVideo.currentTime >= loopEnd) {
      bgVideo.currentTime = loopStart;
    }
  }

  // Background audio loop
  if (state.loops?.bgAudio?.enabled && state.bgAudio.enabled) {
    const bgAudio = document.getElementById('bgAudio');
    if (!bgAudio) return;

    const loop = state.loops.bgAudio;
    const duration = bgAudio.duration;
    if (!duration || isNaN(duration)) return;

    const loopStart = loop.start * duration;
    const loopEnd = loop.end * duration;

    if (bgAudio.currentTime >= loopEnd) {
      bgAudio.currentTime = loopStart;
    }
  }
}

// Toggle audio loop
function toggleAudioLoop() {
  const start = parseFloat(document.getElementById('audioLoopStart').value);
  const end = parseFloat(document.getElementById('audioLoopEnd').value);

  if (!state.loops) state.loops = { main: { enabled: false, start: 0, end: 1 }, bgVideo: { enabled: false, start: 0, end: 1 }, bgAudio: { enabled: false, start: 0, end: 1 } };
  if (!state.loops.bgAudio) state.loops.bgAudio = { enabled: false, start: 0, end: 1 };

  state.loops.bgAudio.enabled = !state.loops.bgAudio.enabled;
  state.loops.bgAudio.start = start;
  state.loops.bgAudio.end = end;

  document.getElementById('audioLoopMarkerBtn')?.classList.toggle('active', state.loops.bgAudio.enabled);
  showToast(state.loops.bgAudio.enabled ? 'Audio loop enabled' : 'Audio loop disabled', 'info');
  scheduleSave();
}

// Toggle video loop
function toggleVideoLoop() {
  const start = parseFloat(document.getElementById('videoLoopStart').value);
  const end = parseFloat(document.getElementById('videoLoopEnd').value);

  if (!state.loops) state.loops = { main: { enabled: false, start: 0, end: 1 }, bgVideo: { enabled: false, start: 0, end: 1 }, bgAudio: { enabled: false, start: 0, end: 1 } };
  if (!state.loops.bgVideo) state.loops.bgVideo = { enabled: false, start: 0, end: 1 };

  state.loops.bgVideo.enabled = !state.loops.bgVideo.enabled;
  state.loops.bgVideo.start = start;
  state.loops.bgVideo.end = end;

  document.getElementById('videoLoopMarkerBtn')?.classList.toggle('active', state.loops.bgVideo.enabled);
  showToast(state.loops.bgVideo.enabled ? 'Video loop enabled' : 'Video loop disabled', 'info');
  scheduleSave();
}

// Toggle loop controls with CSS classes
document.getElementById('audioLoopMarkerBtn')?.addEventListener('click', (e) => {
  e.stopPropagation();
  const btn = e.currentTarget;
  const dropdown = document.getElementById('audioLoopControls');
  const isOpen = dropdown.classList.contains('is-open');

  // Close all dropdowns
  closeAllDropdowns();

  if (!isOpen) {
    dropdown.classList.add('is-open');
    btn.classList.add('is-open');
    btn.setAttribute('aria-expanded', 'true');

    // Focus first input
    setTimeout(() => {
      dropdown.querySelector('input')?.focus();
    }, 50);
  }
});

document.getElementById('videoLoopMarkerBtn')?.addEventListener('click', (e) => {
  e.stopPropagation();
  const btn = e.currentTarget;
  const dropdown = document.getElementById('videoLoopControls');
  const isOpen = dropdown.classList.contains('is-open');

  // Close all dropdowns
  closeAllDropdowns();

  if (!isOpen) {
    dropdown.classList.add('is-open');
    btn.classList.add('is-open');
    btn.setAttribute('aria-expanded', 'true');

    // Focus first input
    setTimeout(() => {
      dropdown.querySelector('input')?.focus();
    }, 50);
  }
});

// ============================================================
// BACKGROUND AUDIO CONTROLS
// ============================================================

// Load background audio
document.getElementById('loadBgAudioBtn')?.addEventListener('click', () => {
  document.getElementById('bgAudioInput')?.click();
});

document.getElementById('bgAudioInput')?.addEventListener('change', (e) => {
  const file = e.target.files[0];
  if (!file) return;

  const bgAudio = document.getElementById('bgAudio');
  if (!bgAudio) return;

  const url = URL.createObjectURL(file);
  bgAudio.src = url;
  bgAudio.load();

  bgAudio.addEventListener('loadedmetadata', function onMeta() {
    bgAudio.removeEventListener('loadedmetadata', onMeta);
    state.bgAudio.enabled = true;

    const status = document.getElementById('bgAudioStatus');
    if (status) {
      const duration = formatTime(bgAudio.duration);
      status.textContent = `${file.name} (${duration})`;
    }

    // Show audio track in timeline
    updateTimelineVisibility();

    showToast('Background audio loaded', 'success');
  });

  e.target.value = '';
});

// Play/Pause background audio
document.getElementById('audioTrackPlayBtn')?.addEventListener('click', () => {
  const bgAudio = document.getElementById('bgAudio');
  if (!bgAudio || !bgAudio.src) return;

  const playBtn = document.getElementById('audioTrackPlayBtn');
  const playIcon = playBtn.querySelector('.play-icon');
  const pauseIcon = playBtn.querySelector('.pause-icon');

  if (bgAudioPlaying) {
    bgAudio.pause();
    bgAudioPlaying = false;
    playIcon.style.display = 'block';
    pauseIcon.style.display = 'none';
    playBtn.classList.remove('playing');
  } else {
    bgAudio.play().catch(err => console.warn('BG audio play prevented:', err));
    bgAudioPlaying = true;
    playIcon.style.display = 'none';
    pauseIcon.style.display = 'block';
    playBtn.classList.add('playing');
  }
});

// Toggle loop for background audio
document.getElementById('audioLoopBtn')?.addEventListener('click', function() {
  const bgAudio = document.getElementById('bgAudio');
  if (!bgAudio) return;

  bgAudioLoop = !bgAudioLoop;
  bgAudio.loop = bgAudioLoop;
  state.bgAudio.loop = bgAudioLoop;
  this.classList.toggle('active', bgAudioLoop);

  showToast(bgAudioLoop ? 'Audio loop enabled' : 'Audio loop disabled', 'info');
});

// Audio volume control
document.getElementById('audioVolumeSlider')?.addEventListener('input', (e) => {
  const bgAudio = document.getElementById('bgAudio');
  if (!bgAudio) return;

  bgAudioVolume = parseInt(e.target.value) / 100;
  bgAudio.volume = bgAudioVolume;
  state.bgAudio.volume = bgAudioVolume;
});

// Audio speed control
document.getElementById('audioSpeedSelect')?.addEventListener('change', (e) => {
  const bgAudio = document.getElementById('bgAudio');
  if (!bgAudio) return;

  bgAudioSpeed = parseFloat(e.target.value);
  bgAudio.playbackRate = bgAudioSpeed;
  state.bgAudio.speed = bgAudioSpeed;
  showToast(`Audio speed: ${bgAudioSpeed}`, 'info');
});

// Audio scrubbing
const audioProgressTrack = document.getElementById('audioProgressTrack');
const audioProgressFill = document.getElementById('audioProgressFill');
let audioScrubbing = false;

audioProgressTrack?.addEventListener('mousedown', (e) => {
  const bgAudio = document.getElementById('bgAudio');
  if (!bgAudio || !bgAudio.duration) return;

  audioScrubbing = true;
  audioProgressTrack.classList.add('scrubbing');
  updateAudioTime(e);
});

document.addEventListener('mousemove', (e) => {
  if (!audioScrubbing) return;
  updateAudioTime(e);
});

document.addEventListener('mouseup', () => {
  if (audioScrubbing) {
    audioScrubbing = false;
    audioProgressTrack?.classList.remove('scrubbing');
  }
});

function updateAudioTime(e) {
  const bgAudio = document.getElementById('bgAudio');
  if (!bgAudio || !audioProgressTrack) return;

  const rect = audioProgressTrack.getBoundingClientRect();
  const x = Math.max(0, Math.min(e.clientX - rect.left, rect.width));
  const percent = x / rect.width;
  const newTime = percent * bgAudio.duration;

  bgAudio.currentTime = newTime;
  updateAudioDisplay();
}

// Sync audio with main video
document.getElementById('audioSyncBtn')?.addEventListener('click', function() {
  bgAudioSynced = !bgAudioSynced;
  this.classList.toggle('synced', bgAudioSynced);

  if (bgAudioSynced) {
    showToast('Audio synced with main video', 'success');
    syncAudioWithMain();
  } else {
    showToast('Audio independent playback', 'info');
  }
});

function syncAudioWithMain() {
  if (!bgAudioSynced) return;

  const bgAudio = document.getElementById('bgAudio');
  if (!bgAudio || !hasVideo) return;

  // Sync currentTime
  const mainTime = vtTime;
  if (bgAudio.duration > 0) {
    bgAudio.currentTime = mainTime % bgAudio.duration;
  }

  // Sync play/pause state
  if (vtPlaying && !bgAudioPlaying) {
    bgAudio.play().catch(err => console.warn('Audio sync play prevented:', err));
    bgAudioPlaying = true;
    updateAudioPlayButtonState();
  } else if (!vtPlaying && bgAudioPlaying) {
    bgAudio.pause();
    bgAudioPlaying = false;
    updateAudioPlayButtonState();
  }
}

function updateAudioPlayButtonState() {
  const playBtn = document.getElementById('audioTrackPlayBtn');
  if (!playBtn) return;

  const playIcon = playBtn.querySelector('.play-icon');
  const pauseIcon = playBtn.querySelector('.pause-icon');

  if (bgAudioPlaying) {
    playIcon.style.display = 'none';
    pauseIcon.style.display = 'block';
    playBtn.classList.add('playing');
  } else {
    playIcon.style.display = 'block';
    pauseIcon.style.display = 'none';
    playBtn.classList.remove('playing');
  }
}

// Update audio display
function updateAudioDisplay() {
  const bgAudio = document.getElementById('bgAudio');
  const audioTimeDisplay = document.getElementById('audioTimeDisplay');

  if (!bgAudio || !audioTimeDisplay) return;

  const current = bgAudio.currentTime || 0;
  const duration = bgAudio.duration || 0;

  audioTimeDisplay.textContent = `${formatTime(current)} / ${formatTime(duration)}`;

  if (audioProgressFill && duration > 0) {
    const percent = (current / duration) * 100;
    audioProgressFill.style.width = `${percent}%`;
  }
}

// Remove background audio
document.getElementById('removeAudioBtn')?.addEventListener('click', () => {
  const bgAudio = document.getElementById('bgAudio');
  if (!bgAudio) return;

  bgAudio.pause();
  if (bgAudio.src) URL.revokeObjectURL(bgAudio.src);
  bgAudio.removeAttribute('src');

  state.bgAudio.enabled = false;
  bgAudioPlaying = false;

  const status = document.getElementById('bgAudioStatus');
  if (status) status.textContent = '';

  updateTimelineVisibility();
  showToast('Background audio removed', 'info');
});

// ============================================================
// KEYBOARD SHORTCUTS
// ============================================================

document.addEventListener('keydown', (e) => {
  // Space - Play/Pause
  if (e.code === 'Space' && !e.target.matches('input, textarea, select')) {
    e.preventDefault();
    vtToggle();
    updateMasterPlayButtonState();
  }

  // B - Toggle background video play/pause
  if (e.code === 'KeyB' && state.bgVideo.enabled) {
    e.preventDefault();
    document.getElementById('bgTrackPlayBtn')?.click();
  }

  // S - Sync background video
  if (e.code === 'KeyS' && state.bgVideo.enabled) {
    e.preventDefault();
    document.getElementById('bgSyncBtn')?.click();
  }

  // M - Toggle audio play/pause
  if (e.code === 'KeyM' && state.bgAudio.enabled) {
    e.preventDefault();
    document.getElementById('audioTrackPlayBtn')?.click();
  }

  // L - Toggle audio loop
  if (e.code === 'KeyL' && state.bgAudio.enabled) {
    e.preventDefault();
    document.getElementById('audioLoopBtn')?.click();
  }
});

// ============================================================
// TRACK COLLAPSE/EXPAND CONTROLS
// ============================================================

// Background Video Track Collapse
document.getElementById('bgVideoCollapseBtn')?.addEventListener('click', (e) => {
  e.stopPropagation();
  const track = document.getElementById('bgVideoTrack');
  const btn = e.target.closest('.track-collapse-btn');

  if (track.classList.contains('collapsed')) {
    track.classList.remove('collapsed');
    btn.classList.remove('collapsed');
    btn.textContent = '';
  } else {
    track.classList.add('collapsed');
    btn.classList.add('collapsed');
    btn.textContent = '';
  }
  updateStageSpacing();
});

// Background Audio Track Collapse
document.getElementById('audioCollapseBtn')?.addEventListener('click', (e) => {
  e.stopPropagation();
  const track = document.getElementById('bgAudioTrack');
  const btn = e.target.closest('.track-collapse-btn');

  if (track.classList.contains('collapsed')) {
    track.classList.remove('collapsed');
    btn.classList.remove('collapsed');
    btn.textContent = '';
  } else {
    track.classList.add('collapsed');
    btn.classList.add('collapsed');
    btn.textContent = '';
  }
  updateStageSpacing();
});

// Main Video Track Collapse
document.getElementById('mainVideoCollapseBtn')?.addEventListener('click', (e) => {
  e.stopPropagation();
  const track = document.getElementById('mainVideoTrack');
  const btn = e.target.closest('.track-collapse-btn');

  if (track.classList.contains('collapsed')) {
    track.classList.remove('collapsed');
    btn.classList.remove('collapsed');
    btn.textContent = '';
  } else {
    track.classList.add('collapsed');
    btn.classList.add('collapsed');
    btn.textContent = '';
  }
  updateStageSpacing();
});

// Also toggle on track header click
document.getElementById('bgVideoTrackHeader')?.addEventListener('click', (e) => {
  if (e.target.classList.contains('track-sync-btn') || e.target.closest('.track-sync-btn')) {
    return; // Don't toggle if clicking sync button
  }
  document.getElementById('bgVideoCollapseBtn')?.click();
});

document.getElementById('audioTrackHeader')?.addEventListener('click', (e) => {
  if (e.target.classList.contains('track-sync-btn') || e.target.closest('.track-sync-btn')) {
    return; // Don't toggle if clicking sync button
  }
  document.getElementById('audioCollapseBtn')?.click();
});

document.getElementById('mainVideoTrackHeader')?.addEventListener('click', (e) => {
  // Don't toggle if clicking on interactive elements
  if (e.target.tagName === 'BUTTON' || e.target.tagName === 'SELECT' || e.target.tagName === 'INPUT') {
    return;
  }
  if (e.target.closest('button') || e.target.closest('select') || e.target.closest('input')) {
    return;
  }
  document.getElementById('mainVideoCollapseBtn')?.click();
});

// Update stage spacing based on timeline height
function updateStageSpacing() {
  const stage = document.getElementById('stage');
  const bgVideoTrack = document.getElementById('bgVideoTrack');
  const bgAudioTrack = document.getElementById('bgAudioTrack');
  const mainVideoTrack = document.getElementById('mainVideoTrack');

  if (!stage) return;

  // Check if any tracks are expanded
  const hasBgVideo = bgVideoTrack?.classList.contains('loaded') && !bgVideoTrack?.classList.contains('collapsed');
  const hasBgAudio = bgAudioTrack?.classList.contains('loaded') && !bgAudioTrack?.classList.contains('collapsed');
  const hasMainVideo = mainVideoTrack && !mainVideoTrack?.classList.contains('collapsed');

  // Count total expanded tracks to adjust spacing
  let expandedCount = 0;
  if (hasBgVideo) expandedCount++;
  if (hasBgAudio) expandedCount++;
  if (hasMainVideo) expandedCount++;

  if (expandedCount >= 2) {
    stage.classList.add('timeline-expanded');
  } else {
    stage.classList.remove('timeline-expanded');
  }
}

// ============================================================
// INITIALIZATION
// ============================================================

// Initialize when video is loaded
if (typeof video !== 'undefined') {
  video.addEventListener('loadedmetadata', () => {
    updateTimelineVisibility();
    initEnhancedTimeline();
  });
}

// Background video initialization handled in ui.js

// ============================================================
// ACTION DROPDOWN TOGGLES
// ============================================================

// Helper function to close all dropdowns
function closeAllDropdowns() {
  // Close action dropdowns
  const dropdowns = document.querySelectorAll('.track-actions-dropdown, .track-loop-controls');
  const buttons = document.querySelectorAll('.track-action-btn, .track-loop-btn');

  dropdowns.forEach(dd => dd.classList.remove('is-open'));
  buttons.forEach(btn => {
    btn.classList.remove('is-open');
    btn.setAttribute('aria-expanded', 'false');
  });
}

// Toggle background video actions dropdown with CSS classes
document.getElementById('bgVideoActionsBtn')?.addEventListener('click', (e) => {
  e.stopPropagation();
  const btn = e.currentTarget;
  const dropdown = document.getElementById('bgVideoActionsDropdown');
  const isOpen = dropdown.classList.contains('is-open');

  // Close all other dropdowns first
  closeAllDropdowns();

  if (!isOpen) {
    // Open this dropdown
    dropdown.classList.add('is-open');
    btn.classList.add('is-open');
    btn.setAttribute('aria-expanded', 'true');

    // Focus first button in dropdown
    setTimeout(() => {
      const firstButton = dropdown.querySelector('button:not([disabled])');
      firstButton?.focus();
    }, 50);
  }
});

// Toggle background audio actions dropdown with CSS classes
document.getElementById('bgAudioActionsBtn')?.addEventListener('click', (e) => {
  e.stopPropagation();
  const btn = e.currentTarget;
  const dropdown = document.getElementById('bgAudioActionsDropdown');
  const isOpen = dropdown.classList.contains('is-open');

  // Close all other dropdowns first
  closeAllDropdowns();

  if (!isOpen) {
    // Open this dropdown
    dropdown.classList.add('is-open');
    btn.classList.add('is-open');
    btn.setAttribute('aria-expanded', 'true');

    // Focus first button in dropdown
    setTimeout(() => {
      const firstButton = dropdown.querySelector('button:not([disabled])');
      firstButton?.focus();
    }, 50);
  }
});

// Close all dropdowns when clicking outside (generic class-based detection)
document.addEventListener('click', (e) => {
  // Check if click is inside any dropdown or its trigger button
  const clickedDropdown = e.target.closest('.track-actions-dropdown, .track-loop-controls');
  const clickedButton = e.target.closest('.track-action-btn, .track-loop-btn');

  // If clicked outside both dropdown and button, close all
  if (!clickedDropdown && !clickedButton) {
    closeAllDropdowns();
  }
});

// ============================================================
// KEYBOARD NAVIGATION FOR TRACK ACTIONS
// ============================================================

// Close dropdowns on Escape key
document.addEventListener('keydown', (e) => {
  if (e.key === 'Escape') {
    const openDropdowns = document.querySelectorAll('.track-actions-dropdown.is-open, .track-loop-controls.is-open');
    if (openDropdowns.length > 0) {
      e.preventDefault();

      // Return focus to the button that opened the dropdown
      const activeButton = document.querySelector('.track-action-btn.is-open, .track-loop-btn.is-open');

      closeAllDropdowns();

      if (activeButton) {
        activeButton.focus();
      }
    }
  }
});

// Navigate dropdown items with Arrow keys
document.addEventListener('keydown', (e) => {
  const openDropdown = document.querySelector('.track-actions-dropdown.is-open');
  if (!openDropdown) return;

  const items = Array.from(openDropdown.querySelectorAll('button:not([disabled])'));
  const currentIndex = items.findIndex(item => item === document.activeElement);

  if (e.key === 'ArrowDown') {
    e.preventDefault();
    const nextIndex = (currentIndex + 1) % items.length;
    items[nextIndex]?.focus();
  } else if (e.key === 'ArrowUp') {
    e.preventDefault();
    const prevIndex = currentIndex <= 0 ? items.length - 1 : currentIndex - 1;
    items[prevIndex]?.focus();
  } else if (e.key === 'Enter' || e.key === ' ') {
    // Space or Enter activates focused button
    if (document.activeElement && items.includes(document.activeElement)) {
      e.preventDefault();
      document.activeElement.click();
    }
  }
});

// ============================================================
// EFFECTS PANEL TOGGLES
// ============================================================

// Background audio effects panel toggle
document.getElementById('bgAudioEffectsToggle')?.addEventListener('click', function() {
  const section = document.getElementById('bgAudioEffectsSection');
  if (!section) return;

  section.classList.toggle('collapsed');
  this.textContent = section.classList.contains('collapsed') ? ' Audio Effects' : ' Hide Effects';
});

// Background video effects panel toggle
document.getElementById('bgVideoEffectsToggle')?.addEventListener('click', function() {
  const section = document.getElementById('bgVideoEffectsSection');
  if (!section) return;

  section.classList.toggle('collapsed');
  this.textContent = section.classList.contains('collapsed') ? ' Video Effects' : ' Hide Effects';
});

// Main video effects panel toggle
document.getElementById('mainVideoEffectsToggle')?.addEventListener('click', function() {
  const section = document.getElementById('mainVideoEffectsSection');
  if (!section) return;

  section.classList.toggle('collapsed');
  this.textContent = section.classList.contains('collapsed') ? ' Video Effects' : ' Hide Effects';
});

// ============================================================
// LOOP CONTROLS INPUT LISTENERS
// ============================================================

// Audio loop controls
document.getElementById('audioLoopStart')?.addEventListener('input', (e) => {
  if (!state.loops) state.loops = { main: { enabled: false, start: 0, end: 1 }, bgVideo: { enabled: false, start: 0, end: 1 }, bgAudio: { enabled: false, start: 0, end: 1 } };
  if (!state.loops.bgAudio) state.loops.bgAudio = { enabled: false, start: 0, end: 1 };
  state.loops.bgAudio.start = parseFloat(e.target.value);
  scheduleSave();
});

document.getElementById('audioLoopEnd')?.addEventListener('input', (e) => {
  if (!state.loops) state.loops = { main: { enabled: false, start: 0, end: 1 }, bgVideo: { enabled: false, start: 0, end: 1 }, bgAudio: { enabled: false, start: 0, end: 1 } };
  if (!state.loops.bgAudio) state.loops.bgAudio = { enabled: false, start: 0, end: 1 };
  state.loops.bgAudio.end = parseFloat(e.target.value);
  scheduleSave();
});

// Video loop controls
document.getElementById('videoLoopStart')?.addEventListener('input', (e) => {
  if (!state.loops) state.loops = { main: { enabled: false, start: 0, end: 1 }, bgVideo: { enabled: false, start: 0, end: 1 }, bgAudio: { enabled: false, start: 0, end: 1 } };
  if (!state.loops.bgVideo) state.loops.bgVideo = { enabled: false, start: 0, end: 1 };
  state.loops.bgVideo.start = parseFloat(e.target.value);
  scheduleSave();
});

document.getElementById('videoLoopEnd')?.addEventListener('input', (e) => {
  if (!state.loops) state.loops = { main: { enabled: false, start: 0, end: 1 }, bgVideo: { enabled: false, start: 0, end: 1 }, bgAudio: { enabled: false, start: 0, end: 1 } };
  if (!state.loops.bgVideo) state.loops.bgVideo = { enabled: false, start: 0, end: 1 };
  state.loops.bgVideo.end = parseFloat(e.target.value);
  scheduleSave();
});

// ============================================================
// AUDIO EFFECTS CONTROLS
// ============================================================

// Background Audio EQ Controls
document.getElementById('bgAudioEQLow')?.addEventListener('input', (e) => {
  state.audioEffects.bgAudio.eq.low = parseFloat(e.target.value);
  e.target.nextElementSibling.textContent = e.target.value + ' dB';
  scheduleSave();
});

document.getElementById('bgAudioEQMid')?.addEventListener('input', (e) => {
  state.audioEffects.bgAudio.eq.mid = parseFloat(e.target.value);
  e.target.nextElementSibling.textContent = e.target.value + ' dB';
  scheduleSave();
});

document.getElementById('bgAudioEQHigh')?.addEventListener('input', (e) => {
  state.audioEffects.bgAudio.eq.high = parseFloat(e.target.value);
  e.target.nextElementSibling.textContent = e.target.value + ' dB';
  scheduleSave();
});

// Background Audio Volume FX
document.getElementById('bgAudioVolumeFX')?.addEventListener('input', (e) => {
  state.audioEffects.bgAudio.volume = parseFloat(e.target.value) / 100;
  e.target.nextElementSibling.textContent = e.target.value + '%';
  scheduleSave();
});

// Background Audio Pan
document.getElementById('bgAudioPan')?.addEventListener('input', (e) => {
  state.audioEffects.bgAudio.pan = parseFloat(e.target.value);
  const val = e.target.value;
  const label = val == 0 ? 'Center' : (val < 0 ? val + ' L' : '+' + val + ' R');
  e.target.nextElementSibling.textContent = label;
  scheduleSave();
});

// Compressor Enable
document.getElementById('bgAudioCompressorEnable')?.addEventListener('change', (e) => {
  state.audioEffects.bgAudio.compressor.enabled = e.target.checked;
  const controls = document.getElementById('bgAudioCompressorControls');
  if (controls) controls.style.display = e.target.checked ? 'block' : 'none';
  scheduleSave();
});

// Compressor Controls
document.getElementById('bgAudioCompThreshold')?.addEventListener('input', (e) => {
  state.audioEffects.bgAudio.compressor.threshold = parseFloat(e.target.value);
  e.target.nextElementSibling.textContent = e.target.value + ' dB';
  scheduleSave();
});

document.getElementById('bgAudioCompRatio')?.addEventListener('change', (e) => {
  state.audioEffects.bgAudio.compressor.ratio = parseFloat(e.target.value);
  scheduleSave();
});

// Reverb Enable
document.getElementById('bgAudioReverbEnable')?.addEventListener('change', (e) => {
  state.audioEffects.bgAudio.reverb.enabled = e.target.checked;
  scheduleSave();
});

// Echo Enable
document.getElementById('bgAudioEchoEnable')?.addEventListener('change', (e) => {
  state.audioEffects.bgAudio.echo.enabled = e.target.checked;
  scheduleSave();
});

// Audio Preset Selector
document.getElementById('bgAudioPreset')?.addEventListener('change', (e) => {
  const preset = e.target.value;
  if (!preset) return;

  // Apply preset values
  const presets = {
    podcast: { eq: { low: -2, mid: 3, high: 2 }, compressor: { enabled: true, threshold: -18, ratio: 3 } },
    music: { eq: { low: 2, mid: 0, high: 3 }, compressor: { enabled: false } },
    bass: { eq: { low: 8, mid: -2, high: 0 }, compressor: { enabled: true, threshold: -12, ratio: 1.5 } },
    vocal: { eq: { low: -3, mid: 5, high: 4 }, compressor: { enabled: true, threshold: -15, ratio: 3 } },
    radio: { eq: { low: -5, mid: 4, high: -2 }, compressor: { enabled: true, threshold: -10, ratio: 8 } },
    spacious: { eq: { low: 0, mid: 0, high: 2 }, reverb: { enabled: true } }
  };

  if (presets[preset]) {
    Object.assign(state.audioEffects.bgAudio, presets[preset]);
    // Update UI
    document.getElementById('bgAudioEQLow').value = state.audioEffects.bgAudio.eq.low;
    document.getElementById('bgAudioEQMid').value = state.audioEffects.bgAudio.eq.mid;
    document.getElementById('bgAudioEQHigh').value = state.audioEffects.bgAudio.eq.high;
    if (presets[preset].compressor) {
      document.getElementById('bgAudioCompressorEnable').checked = presets[preset].compressor.enabled;
    }
    if (presets[preset].reverb) {
      document.getElementById('bgAudioReverbEnable').checked = presets[preset].reverb.enabled;
    }
    showToast('Preset applied: ' + preset, 'success');
  }

  e.target.value = ''; // Reset dropdown
  scheduleSave();
});

// ============================================================
// VIDEO EFFECTS CONTROLS
// ============================================================

// Background Video Color Correction
document.getElementById('bgVideoBrightness')?.addEventListener('input', (e) => {
  state.videoEffects.bgVideo.brightness = parseInt(e.target.value);
  e.target.nextElementSibling.textContent = e.target.value;
  scheduleSave();
});

document.getElementById('bgVideoContrast')?.addEventListener('input', (e) => {
  state.videoEffects.bgVideo.contrast = parseInt(e.target.value);
  e.target.nextElementSibling.textContent = e.target.value;
  scheduleSave();
});

document.getElementById('bgVideoSaturation')?.addEventListener('input', (e) => {
  state.videoEffects.bgVideo.saturation = parseInt(e.target.value);
  e.target.nextElementSibling.textContent = e.target.value;
  scheduleSave();
});

document.getElementById('bgVideoHue')?.addEventListener('input', (e) => {
  state.videoEffects.bgVideo.hue = parseInt(e.target.value);
  e.target.nextElementSibling.textContent = e.target.value + '';
  scheduleSave();
});

document.getElementById('bgVideoTemp')?.addEventListener('input', (e) => {
  state.videoEffects.bgVideo.temperature = parseInt(e.target.value);
  e.target.nextElementSibling.textContent = e.target.value;
  scheduleSave();
});

// Background Video Blend Mode
document.getElementById('bgVideoBlendMode')?.addEventListener('change', (e) => {
  state.videoEffects.bgVideo.blendMode = e.target.value;
  scheduleSave();
});

// Background Video Preset
document.getElementById('bgVideoPreset')?.addEventListener('change', (e) => {
  const preset = e.target.value;
  if (!preset) return;

  const presets = {
    cinematic: { brightness: 0, contrast: 15, saturation: -10, hue: 0, temperature: 5 },
    vibrant: { brightness: 10, contrast: 20, saturation: 30, hue: 0, temperature: 0 },
    vintage: { brightness: -5, contrast: 10, saturation: -20, hue: 15, temperature: 20 },
    bwContrast: { brightness: 0, contrast: 40, saturation: -100, hue: 0, temperature: 0 },
    cool: { brightness: 0, contrast: 5, saturation: 0, hue: 0, temperature: -30 },
    warm: { brightness: 5, contrast: 5, saturation: 5, hue: 0, temperature: 30 },
    fade: { brightness: 15, contrast: -15, saturation: -25, hue: 0, temperature: 10 },
    dramatic: { brightness: -10, contrast: 35, saturation: -5, hue: 0, temperature: -5 }
  };

  if (presets[preset]) {
    Object.assign(state.videoEffects.bgVideo, presets[preset]);
    // Update UI
    document.getElementById('bgVideoBrightness').value = presets[preset].brightness;
    document.getElementById('bgVideoContrast').value = presets[preset].contrast;
    document.getElementById('bgVideoSaturation').value = presets[preset].saturation;
    document.getElementById('bgVideoHue').value = presets[preset].hue;
    document.getElementById('bgVideoTemp').value = presets[preset].temperature;
    showToast('Preset applied: ' + preset, 'success');
  }

  e.target.value = ''; // Reset dropdown
  scheduleSave();
});

// Main Video Color Correction (same as background)
document.getElementById('mainVideoBrightness')?.addEventListener('input', (e) => {
  state.videoEffects.main.brightness = parseInt(e.target.value);
  e.target.nextElementSibling.textContent = e.target.value;
  scheduleSave();
});

document.getElementById('mainVideoContrast')?.addEventListener('input', (e) => {
  state.videoEffects.main.contrast = parseInt(e.target.value);
  e.target.nextElementSibling.textContent = e.target.value;
  scheduleSave();
});

document.getElementById('mainVideoSaturation')?.addEventListener('input', (e) => {
  state.videoEffects.main.saturation = parseInt(e.target.value);
  e.target.nextElementSibling.textContent = e.target.value;
  scheduleSave();
});

document.getElementById('mainVideoHue')?.addEventListener('input', (e) => {
  state.videoEffects.main.hue = parseInt(e.target.value);
  e.target.nextElementSibling.textContent = e.target.value + '';
  scheduleSave();
});

document.getElementById('mainVideoTemp')?.addEventListener('input', (e) => {
  state.videoEffects.main.temperature = parseInt(e.target.value);
  e.target.nextElementSibling.textContent = e.target.value;
  scheduleSave();
});

document.getElementById('mainVideoPreset')?.addEventListener('change', (e) => {
  const preset = e.target.value;
  if (!preset) return;

  const presets = {
    cinematic: { brightness: 0, contrast: 15, saturation: -10, hue: 0, temperature: 5 },
    vibrant: { brightness: 10, contrast: 20, saturation: 30, hue: 0, temperature: 0 },
    vintage: { brightness: -5, contrast: 10, saturation: -20, hue: 15, temperature: 20 },
    bwContrast: { brightness: 0, contrast: 40, saturation: -100, hue: 0, temperature: 0 },
    cool: { brightness: 0, contrast: 5, saturation: 0, hue: 0, temperature: -30 },
    warm: { brightness: 5, contrast: 5, saturation: 5, hue: 0, temperature: 30 },
    fade: { brightness: 15, contrast: -15, saturation: -25, hue: 0, temperature: 10 },
    dramatic: { brightness: -10, contrast: 35, saturation: -5, hue: 0, temperature: -5 }
  };

  if (presets[preset]) {
    Object.assign(state.videoEffects.main, presets[preset]);
    // Update UI
    document.getElementById('mainVideoBrightness').value = presets[preset].brightness;
    document.getElementById('mainVideoContrast').value = presets[preset].contrast;
    document.getElementById('mainVideoSaturation').value = presets[preset].saturation;
    document.getElementById('mainVideoHue').value = presets[preset].hue;
    document.getElementById('mainVideoTemp').value = presets[preset].temperature;
    showToast('Preset applied: ' + preset, 'success');
  }

  e.target.value = ''; // Reset dropdown
  scheduleSave();
});

// Update displays every frame
if (typeof requestAnimationFrame !== 'undefined') {
  function enhancedTimelineRenderLoop() {
    updateEnhancedTimelineDisplays();
    requestAnimationFrame(enhancedTimelineRenderLoop);
  }
  enhancedTimelineRenderLoop();
}

// ============================================================
// EVENT DELEGATION & CLEANUP
// ============================================================

// Store delegated handlers for cleanup
const _timelineHandlers = {
  clickHandler: null,
  inputHandler: null,
  changeHandler: null
};

// Event delegation for timeline controls
function initTimelineDelegation() {
  const timelineSystem = document.getElementById('timelineSystem');
  if (!timelineSystem) return;

  // Remove existing handlers if any
  cleanupTimelineHandlers();

  // Single click handler for all buttons in timeline
  _timelineHandlers.clickHandler = (e) => {
    const button = e.target.closest('button');
    if (!button) return;

    // Handle by button ID or class
    const id = button.id;
    if (id === 'bgTrackPlayBtn' || id === 'audioTrackPlayBtn' || id === 'masterPlayBtn') {
      // Play button clicks already have handlers, let them work
      return;
    }
  };

  // Single input handler for all range sliders - throttled for performance
  _timelineHandlers.inputHandler = throttle((e) => {
    const input = e.target;
    if (input.type !== 'range' && input.type !== 'number') return;

    // Update corresponding value display
    const valueDisplay = input.nextElementSibling;
    if (valueDisplay && valueDisplay.classList.contains('value')) {
      const suffix = input.id.includes('Hue') ? '' : '';
      valueDisplay.textContent = input.value + suffix;
    }
  }, 16); // ~60fps

  // Single change handler for all selects - debounced
  _timelineHandlers.changeHandler = debounce((e) => {
    const select = e.target;
    if (select.tagName !== 'SELECT') return;

    // All selects already have specific handlers, this is for future additions
  }, 100);

  // Attach delegated listeners
  timelineSystem.addEventListener('click', _timelineHandlers.clickHandler);
  timelineSystem.addEventListener('input', _timelineHandlers.inputHandler);
  timelineSystem.addEventListener('change', _timelineHandlers.changeHandler);
}

// Cleanup function to remove all event listeners
function cleanupTimelineHandlers() {
  const timelineSystem = document.getElementById('timelineSystem');
  if (!timelineSystem) return;

  if (_timelineHandlers.clickHandler) {
    timelineSystem.removeEventListener('click', _timelineHandlers.clickHandler);
  }
  if (_timelineHandlers.inputHandler) {
    timelineSystem.removeEventListener('input', _timelineHandlers.inputHandler);
  }
  if (_timelineHandlers.changeHandler) {
    timelineSystem.removeEventListener('change', _timelineHandlers.changeHandler);
  }

  _timelineHandlers.clickHandler = null;
  _timelineHandlers.inputHandler = null;
  _timelineHandlers.changeHandler = null;
}

// Initialize delegation (this augments existing handlers, doesn't replace them)
if (typeof debounce !== 'undefined' && typeof throttle !== 'undefined') {
  initTimelineDelegation();
}

// Export cleanup for potential use
window.cleanupTimelineEnhanced = cleanupTimelineHandlers;

// EFFECT UI EVENT HANDLERS
// ============================================================
// UI event handlers for audio and video effects

// ============================================================
// INITIALIZE EFFECTS ON VIDEO/AUDIO LOAD
// ============================================================

// Initialize audio effects when audio element is loaded
function initializeAudioEffectsForTrack(trackName) {
  const chain = initAudioChain(trackName);
  if (chain) {
    updateAudioEffects(trackName);
    showToast(`Audio effects ready for ${trackName}`, 'success');
  }
}

// ============================================================
// TOGGLE EFFECTS PANELS
// ============================================================

// Background Audio Effects Toggle
document.getElementById('bgAudioEffectsToggle')?.addEventListener('click', () => {
  const section = document.getElementById('bgAudioEffectsSection');
  section.classList.toggle('collapsed');
});

// Background Video Effects Toggle
document.getElementById('bgVideoEffectsToggle')?.addEventListener('click', () => {
  const section = document.getElementById('bgVideoEffectsSection');
  section.classList.toggle('collapsed');
});

// Main Video Effects Toggle
document.getElementById('mainVideoEffectsToggle')?.addEventListener('click', () => {
  const section = document.getElementById('mainVideoEffectsSection');
  section.classList.toggle('collapsed');
});

// ============================================================
// AUDIO EFFECT CONTROLS - Background Audio
// ============================================================

// Volume
document.getElementById('bgAudioVolumeFX')?.addEventListener('input', (e) => {
  const value = parseFloat(e.target.value) / 100;
  state.audioEffects.bgAudio.volume = value;
  updateAudioEffects('bgAudio');
  e.target.nextElementSibling.textContent = Math.round(value * 100) + '%';
  scheduleSave();
});

// Pan
document.getElementById('bgAudioPan')?.addEventListener('input', (e) => {
  const value = parseFloat(e.target.value) / 100;
  state.audioEffects.bgAudio.pan = value;
  updateAudioEffects('bgAudio');
  const label = value < -0.1 ? `L ${Math.abs(Math.round(value * 100))}` :
                value > 0.1 ? `R ${Math.round(value * 100)}` : 'Center';
  e.target.nextElementSibling.textContent = label;
  scheduleSave();
});

// EQ Low
document.getElementById('bgAudioEQLow')?.addEventListener('input', (e) => {
  const value = parseFloat(e.target.value);
  state.audioEffects.bgAudio.eq.low = value;
  updateAudioEffects('bgAudio');
  e.target.nextElementSibling.textContent = value.toFixed(1) + ' dB';
  drawEQGraph('bgAudio');
  scheduleSave();
});

// EQ Mid
document.getElementById('bgAudioEQMid')?.addEventListener('input', (e) => {
  const value = parseFloat(e.target.value);
  state.audioEffects.bgAudio.eq.mid = value;
  updateAudioEffects('bgAudio');
  e.target.nextElementSibling.textContent = value.toFixed(1) + ' dB';
  drawEQGraph('bgAudio');
  scheduleSave();
});

// EQ High
document.getElementById('bgAudioEQHigh')?.addEventListener('input', (e) => {
  const value = parseFloat(e.target.value);
  state.audioEffects.bgAudio.eq.high = value;
  updateAudioEffects('bgAudio');
  e.target.nextElementSibling.textContent = value.toFixed(1) + ' dB';
  drawEQGraph('bgAudio');
  scheduleSave();
});

// Compressor Enable
document.getElementById('bgAudioCompressorEnable')?.addEventListener('change', (e) => {
  state.audioEffects.bgAudio.compressor.enabled = e.target.checked;
  updateAudioEffects('bgAudio');
  document.getElementById('bgAudioCompressorControls').style.display = e.target.checked ? 'block' : 'none';
  scheduleSave();
});

// Compressor Threshold
document.getElementById('bgAudioCompThreshold')?.addEventListener('input', (e) => {
  const value = parseFloat(e.target.value);
  state.audioEffects.bgAudio.compressor.threshold = value;
  updateAudioEffects('bgAudio');
  e.target.nextElementSibling.textContent = value + ' dB';
  scheduleSave();
});

// Compressor Ratio
document.getElementById('bgAudioCompRatio')?.addEventListener('change', (e) => {
  const value = parseFloat(e.target.value);
  state.audioEffects.bgAudio.compressor.ratio = value;
  updateAudioEffects('bgAudio');
  scheduleSave();
});

// Reverb Enable
document.getElementById('bgAudioReverbEnable')?.addEventListener('change', (e) => {
  state.audioEffects.bgAudio.reverb.enabled = e.target.checked;
  updateAudioEffects('bgAudio');
  scheduleSave();
});

// Echo Enable
document.getElementById('bgAudioEchoEnable')?.addEventListener('change', (e) => {
  state.audioEffects.bgAudio.echo.enabled = e.target.checked;
  updateAudioEffects('bgAudio');
  scheduleSave();
});

// Presets
document.getElementById('bgAudioPreset')?.addEventListener('change', (e) => {
  if (e.target.value) {
    pushUndoState();
    loadAudioPreset('bgAudio', e.target.value);
    showToast(`Loaded preset: ${e.target.value}`, 'success');
    e.target.value = '';
  }
});

// Save Custom Preset
document.getElementById('bgAudioSavePreset')?.addEventListener('click', () => {
  const name = prompt('Enter preset name:');
  if (name) {
    saveCustomPreset('audio', 'bgAudio', name, state.audioEffects.bgAudio);
  }
});

// Solo/Mute Buttons
document.querySelectorAll('.solo-btn').forEach(btn => {
  btn.addEventListener('click', (e) => {
    const track = e.target.dataset.track;
    const isSolo = btn.classList.toggle('active');
    state.audioEffects[track].solo = isSolo;

    if (isSolo) {
      // Mute all other tracks
      Object.keys(state.audioEffects).forEach(t => {
        if (t !== track) {
          const chain = audioChains[t];
          if (chain) chain.setVolume(0);
        }
      });
    } else {
      // Restore volumes
      Object.keys(state.audioEffects).forEach(t => {
        const chain = audioChains[t];
        if (chain) chain.setVolume(state.audioEffects[t].volume);
      });
    }
  });
});

document.querySelectorAll('.mute-btn').forEach(btn => {
  btn.addEventListener('click', (e) => {
    const track = e.target.dataset.track;
    const isMuted = btn.classList.toggle('active');
    state.audioEffects[track].mute = isMuted;

    const chain = audioChains[track];
    if (chain) {
      chain.setVolume(isMuted ? 0 : state.audioEffects[track].volume);
    }
  });
});

// ============================================================
// VIDEO EFFECT CONTROLS - Background Video
// ============================================================

// Brightness
document.getElementById('bgVideoBrightness')?.addEventListener('input', (e) => {
  const value = parseInt(e.target.value);
  state.videoEffects.bgVideo.brightness = value;
  e.target.nextElementSibling.textContent = value;
  applyVideoEffectsToElement('bgVideo');
  scheduleSave();
});

// Contrast
document.getElementById('bgVideoContrast')?.addEventListener('input', (e) => {
  const value = parseInt(e.target.value);
  state.videoEffects.bgVideo.contrast = value;
  e.target.nextElementSibling.textContent = value;
  applyVideoEffectsToElement('bgVideo');
  scheduleSave();
});

// Saturation
document.getElementById('bgVideoSaturation')?.addEventListener('input', (e) => {
  const value = parseInt(e.target.value);
  state.videoEffects.bgVideo.saturation = value;
  e.target.nextElementSibling.textContent = value;
  applyVideoEffectsToElement('bgVideo');
  scheduleSave();
});

// Hue
document.getElementById('bgVideoHue')?.addEventListener('input', (e) => {
  const value = parseInt(e.target.value);
  state.videoEffects.bgVideo.hue = value;
  e.target.nextElementSibling.textContent = value + '';
  applyVideoEffectsToElement('bgVideo');
  scheduleSave();
});

// Temperature
document.getElementById('bgVideoTemp')?.addEventListener('input', (e) => {
  const value = parseInt(e.target.value);
  state.videoEffects.bgVideo.temperature = value;
  e.target.nextElementSibling.textContent = value;
  applyVideoEffectsToElement('bgVideo');
  scheduleSave();
});

// Add Effect
document.getElementById('bgVideoAddEffect')?.addEventListener('change', (e) => {
  if (e.target.value) {
    pushUndoState();
    addVideoEffect('bgVideo', e.target.value);
    e.target.value = '';
    scheduleSave();
  }
});

// Blend Mode
document.getElementById('bgVideoBlendMode')?.addEventListener('change', (e) => {
  state.videoEffects.bgVideo.blendMode = e.target.value;
  scheduleSave();
});

// Preset
document.getElementById('bgVideoPreset')?.addEventListener('change', (e) => {
  if (e.target.value) {
    pushUndoState();
    loadVideoPreset('bgVideo', e.target.value);
    showToast(`Loaded preset: ${e.target.value}`, 'success');
    e.target.value = '';
  }
});

// Save Custom Preset
document.getElementById('bgVideoSavePreset')?.addEventListener('click', () => {
  const name = prompt('Enter preset name:');
  if (name) {
    saveCustomPreset('video', 'bgVideo', name, state.videoEffects.bgVideo);
  }
});

// ============================================================
// VIDEO EFFECT CONTROLS - Main Video
// ============================================================

// Brightness
document.getElementById('mainVideoBrightness')?.addEventListener('input', (e) => {
  const value = parseInt(e.target.value);
  state.videoEffects.main.brightness = value;
  e.target.nextElementSibling.textContent = value;
  applyVideoEffectsToElement('main');
  scheduleSave();
});

// Contrast
document.getElementById('mainVideoContrast')?.addEventListener('input', (e) => {
  const value = parseInt(e.target.value);
  state.videoEffects.main.contrast = value;
  e.target.nextElementSibling.textContent = value;
  applyVideoEffectsToElement('main');
  scheduleSave();
});

// Saturation
document.getElementById('mainVideoSaturation')?.addEventListener('input', (e) => {
  const value = parseInt(e.target.value);
  state.videoEffects.main.saturation = value;
  e.target.nextElementSibling.textContent = value;
  applyVideoEffectsToElement('main');
  scheduleSave();
});

// Hue
document.getElementById('mainVideoHue')?.addEventListener('input', (e) => {
  const value = parseInt(e.target.value);
  state.videoEffects.main.hue = value;
  e.target.nextElementSibling.textContent = value + '';
  applyVideoEffectsToElement('main');
  scheduleSave();
});

// Temperature
document.getElementById('mainVideoTemp')?.addEventListener('input', (e) => {
  const value = parseInt(e.target.value);
  state.videoEffects.main.temperature = value;
  e.target.nextElementSibling.textContent = value;
  applyVideoEffectsToElement('main');
  scheduleSave();
});

// Add Effect
document.getElementById('mainVideoAddEffect')?.addEventListener('change', (e) => {
  if (e.target.value) {
    pushUndoState();
    addVideoEffect('main', e.target.value);
    e.target.value = '';
    scheduleSave();
  }
});

// Preset
document.getElementById('mainVideoPreset')?.addEventListener('change', (e) => {
  if (e.target.value) {
    pushUndoState();
    loadVideoPreset('main', e.target.value);
    showToast(`Loaded preset: ${e.target.value}`, 'success');
    e.target.value = '';
  }
});

// Save Custom Preset
document.getElementById('mainVideoSavePreset')?.addEventListener('click', () => {
  const name = prompt('Enter preset name:');
  if (name) {
    saveCustomPreset('video', 'main', name, state.videoEffects.main);
  }
});

// ============================================================
// HELPER FUNCTIONS
// ============================================================

// Apply video effects to element (CSS filters)
function applyVideoEffectsToElement(trackName) {
  let videoEl = null;

  if (trackName === 'main') {
    videoEl = document.getElementById('srcVideo');
  } else if (trackName === 'bgVideo') {
    videoEl = document.getElementById('bgVideo');
  }

  if (!videoEl) return;

  const effects = state.videoEffects[trackName];
  const processor = videoProcessors[trackName];

  processor.applyCSSFilters(videoEl, effects);
}

// Add video effect to stack
function addVideoEffect(trackName, effectType) {
  const effects = state.videoEffects[trackName];

  const newEffect = { type: effectType, id: Date.now() };

  switch (effectType) {
    case 'blur':
      newEffect.amount = 5;
      break;
    case 'pixelate':
      newEffect.blockSize = 10;
      break;
    case 'posterize':
      newEffect.levels = 8;
      break;
    case 'sepia':
      newEffect.amount = 100;
      break;
  }

  effects.filters.push(newEffect);
  updateVideoEffectStack(trackName);
  applyVideoEffectsToElement(trackName);
  showToast(`Added ${effectType} effect`, 'success');
}

// Remove video effect from stack
function removeVideoEffect(trackName, effectId) {
  const effects = state.videoEffects[trackName];
  effects.filters = effects.filters.filter(f => f.id !== effectId);
  updateVideoEffectStack(trackName);
  applyVideoEffectsToElement(trackName);
}

// Update video effect stack UI
function updateVideoEffectStack(trackName) {
  const stackEl = document.getElementById(`${trackName}VideoEffectStack`);
  if (!stackEl) return;

  const effects = state.videoEffects[trackName].filters;

  if (effects.length === 0) {
    stackEl.innerHTML = '<span style="font-size: 10px; color: #666;">No effects added</span>';
    return;
  }

  stackEl.innerHTML = effects.map(effect => `
    <div class="effect-stack-item">
      <span class="effect-name">${effect.type}</span>
      <div class="effect-controls">
        <button onclick="removeVideoEffect('${trackName}', ${effect.id})"></button>
      </div>
    </div>
  `).join('');
}

// Draw EQ graph
function drawEQGraph(trackName) {
  const canvas = document.getElementById(`${trackName}EQGraph`);
  if (!canvas) return;

  const ctx = canvas.getContext('2d');
  const w = canvas.width;
  const h = canvas.height;

  ctx.clearRect(0, 0, w, h);

  const eq = state.audioEffects[trackName].eq;
  const bands = [
    { freq: 'Low', gain: eq.low, x: w * 0.25 },
    { freq: 'Mid', gain: eq.mid, x: w * 0.5 },
    { freq: 'High', gain: eq.high, x: w * 0.75 }
  ];

  // Draw zero line
  ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
  ctx.lineWidth = 1;
  ctx.beginPath();
  ctx.moveTo(0, h / 2);
  ctx.lineTo(w, h / 2);
  ctx.stroke();

  // Draw EQ curve
  ctx.strokeStyle = '#60a5fa';
  ctx.lineWidth = 2;
  ctx.beginPath();

  for (let i = 0; i < bands.length; i++) {
    const band = bands[i];
    const y = h / 2 - (band.gain / 12) * (h / 2);

    if (i === 0) {
      ctx.moveTo(band.x, y);
    } else {
      ctx.lineTo(band.x, y);
    }
  }

  ctx.stroke();

  // Draw points
  bands.forEach(band => {
    const y = h / 2 - (band.gain / 12) * (h / 2);
    ctx.fillStyle = '#60a5fa';
    ctx.beginPath();
    ctx.arc(band.x, y, 4, 0, Math.PI * 2);
    ctx.fill();
  });
}

// Update audio effect UI from state
function updateAudioEffectUI(trackName) {
  const effects = state.audioEffects[trackName];
  const prefix = trackName === 'bgAudio' ? 'bgAudio' : 'mainAudio';

  // Volume
  const volumeFx = document.getElementById(`${prefix}VolumeFX`);
  if (volumeFx) {
    volumeFx.value = effects.volume * 100;
    volumeFx.nextElementSibling.textContent = Math.round(effects.volume * 100) + '%';
  }

  // Pan
  const pan = document.getElementById(`${prefix}Pan`);
  if (pan) {
    pan.value = effects.pan * 100;
    const label = effects.pan < -0.1 ? `L ${Math.abs(Math.round(effects.pan * 100))}` :
                  effects.pan > 0.1 ? `R ${Math.round(effects.pan * 100)}` : 'Center';
    pan.nextElementSibling.textContent = label;
  }

  // EQ
  const eqLow = document.getElementById(`${prefix}EQLow`);
  if (eqLow) {
    eqLow.value = effects.eq.low;
    eqLow.nextElementSibling.textContent = effects.eq.low.toFixed(1) + ' dB';
  }

  const eqMid = document.getElementById(`${prefix}EQMid`);
  if (eqMid) {
    eqMid.value = effects.eq.mid;
    eqMid.nextElementSibling.textContent = effects.eq.mid.toFixed(1) + ' dB';
  }

  const eqHigh = document.getElementById(`${prefix}EQHigh`);
  if (eqHigh) {
    eqHigh.value = effects.eq.high;
    eqHigh.nextElementSibling.textContent = effects.eq.high.toFixed(1) + ' dB';
  }

  drawEQGraph(trackName);

  // Compressor
  const compEnable = document.getElementById(`${prefix}CompressorEnable`);
  if (compEnable) {
    compEnable.checked = effects.compressor.enabled;
    const compControls = document.getElementById(`${prefix}CompressorControls`);
    if (compControls) {
      compControls.style.display = effects.compressor.enabled ? 'block' : 'none';
    }
  }

  // Reverb
  const reverbEnable = document.getElementById(`${prefix}ReverbEnable`);
  if (reverbEnable) {
    reverbEnable.checked = effects.reverb.enabled;
  }

  // Echo
  const echoEnable = document.getElementById(`${prefix}EchoEnable`);
  if (echoEnable) {
    echoEnable.checked = effects.echo.enabled;
  }
}

// Update video effect UI from state
function updateVideoEffectUI(trackName) {
  const effects = state.videoEffects[trackName];
  const prefix = trackName === 'bgVideo' ? 'bgVideo' : 'mainVideo';

  // Brightness
  const brightness = document.getElementById(`${prefix}Brightness`);
  if (brightness) {
    brightness.value = effects.brightness;
    brightness.nextElementSibling.textContent = effects.brightness;
  }

  // Contrast
  const contrast = document.getElementById(`${prefix}Contrast`);
  if (contrast) {
    contrast.value = effects.contrast;
    contrast.nextElementSibling.textContent = effects.contrast;
  }

  // Saturation
  const saturation = document.getElementById(`${prefix}Saturation`);
  if (saturation) {
    saturation.value = effects.saturation;
    saturation.nextElementSibling.textContent = effects.saturation;
  }

  // Hue
  const hue = document.getElementById(`${prefix}Hue`);
  if (hue) {
    hue.value = effects.hue;
    hue.nextElementSibling.textContent = effects.hue + '';
  }

  // Temperature
  const temp = document.getElementById(`${prefix}Temp`);
  if (temp) {
    temp.value = effects.temperature;
    temp.nextElementSibling.textContent = effects.temperature;
  }

  // Update effect stack
  updateVideoEffectStack(trackName);

  // Apply effects
  applyVideoEffectsToElement(trackName);
}


</script>
</body>
</html>
